# Arxiv Analysis: Modelling and Model-Checking a ROS2 Multi-Robot System using Timed Rebeca

**ID:** 2511.15227
**Date:** 2025-11-19
**Link:** https://arxiv.org/html/2511.15227

## 1. Executive Summary
This paper bridges the gap between formal verification and practical robotics. It uses **Timed Rebeca** (an actor-based modeling language) to model a **ROS2** multi-robot system. It introduces strategies to **discretize** continuous physical dynamics (map positions, laser scans, rotation) into finite states that can be model-checked for deadlocks and collisions. It demonstrates a workflow where the formal model acts as a blueprint for the actual C++/Python ROS2 code.

## 2. Detailed Key Concepts

### 2.1. Discretization Strategies
-   **Space:** Continuous maps are converted to **Occupancy Grids**.
-   **Movement:** Instead of $x(t) = v \cdot t$, robots "hop" between grid cells. Time $\Delta t$ is calculated based on velocity.
-   **Sensing:** Laser scans are simulated at fixed intervals (e.g., every 100ms) with fixed angular steps (2Â°).
-   **Nyquist Analogy:** The "Action Time" (movement step) must be > 2 * "Signal Period" (scan rate) to avoid missing obstacles.

### 2.2. Model-Code Alignment
The authors manually ensured that the ROS2 code structure (Nodes, Topics, Callbacks) mirrored the Rebeca model (Actors, Messages, Handlers). This makes the verification results applicable to the real code.

## 3. Gap Analysis

| Feature/Concept | Current CodeSwarm | Gap |
| :--- | :--- | :--- |
| **Formal Verification** | None | **High:** We don't verify agent interactions for deadlocks (e.g., Agent A waiting for B, B waiting for A). |
| **Discretization** | N/A | **Low:** Most coding tasks are discrete, but for "GUI Navigation" or "Data Science" tasks, we might need to discretize continuous spaces. |
| **Simulation-First** | Code-First | **Medium:** We write code immediately. We should simulate complex multi-agent flows (e.g. 5 agents editing 1 file) before executing. |

## 4. Implementation Plan (Agno + SurrealDB + Gemini)

### Phase 1: Interaction Modeling
-   **Action:** Before launching a complex multi-agent task, the **PlannerAgent** should generate a "Sequence Diagram" or simple state machine.
-   **Check:** Use a simple script to check this graph for cycles (deadlocks).

### Phase 2: Discrete "World Model" for GUI Agents
-   **Action:** If we implement a "WebSurfer" agent, use the paper's discretization strategy:
    -   Divide screen into grid.
    -   Define atomic actions (Click Cell X,Y).
    -   This simplifies the LLM's decision space compared to pixel-perfect coordinates.

### Phase 3: The "Twin" Verification
-   **Action:** Use the "Repo Twin" (from 2511.15206) to run the discrete simulation. If it passes, run the real agents.
