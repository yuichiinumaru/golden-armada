import argparse
import os
import json
import concurrent.futures
from typing import List, Dict, Any

from . import config
from . import agents
from .models import TaskAssignment

def parse_args():
    parser = argparse.ArgumentParser(description="CodeSwarm Agno Controller")
    parser.add_argument("--path", type=str, default=config.DEFAULT_PROJECT_PATH, help="Project path")
    parser.add_argument("--goal", type=str, default=config.DEFAULT_GOAL, help="Project goal")
    parser.add_argument("--pairs", type=int, default=int(config.DEFAULT_PAIRS), help="Number of Dev/Revisor pairs")
    parser.add_argument("--rounds", type=int, default=int(config.DEFAULT_ROUNDS), help="Number of rounds")
    return parser.parse_args()

def run_dev_revisor_pair(task: TaskAssignment, round_num: int):
    """Runs a single Dev -> Revisor cycle for a given task."""
    print(f"  [Pair {task.dev_id}] Starting task: {task.dev_task_description}")

    # Dev Agent
    dev_agent = agents.get_dev_agent(task.dev_id)
    dev_input = {
        "dev_task_description": task.dev_task_description,
        "file_to_edit_or_create": task.file_to_edit_or_create,
        "dev_id": task.dev_id,
        "round": round_num
    }

    print(f"  [Dev {task.dev_id}] Working on {task.file_to_edit_or_create}...")
    dev_response = dev_agent.run(json.dumps(dev_input))
    dev_output = dev_response.content
    print(f"  [Dev {task.dev_id}] Finished. Status: {dev_output.status}")

    # Revisor Agent
    revisor_agent = agents.get_revisor_agent(task.revisor_id)
    revisor_input = {
        "file_to_edit_or_create": task.file_to_edit_or_create,
        "dev_task_description": task.dev_task_description,
        "revisor_focus_areas": task.revisor_focus_areas,
        "revisor_id": task.revisor_id,
        "round": round_num
    }

    print(f"  [Revisor {task.revisor_id}] Reviewing {task.file_to_edit_or_create}...")
    revisor_response = revisor_agent.run(json.dumps(revisor_input))
    revisor_output = revisor_response.content
    print(f"  [Revisor {task.revisor_id}] Finished. Approved: {revisor_output.approved}")

    return {
        "task": task.model_dump(),
        "dev_output": dev_output.model_dump(),
        "revisor_output": revisor_output.model_dump()
    }

def main():
    args = parse_args()

    target_project_path = os.path.abspath(args.path)
    os.makedirs(target_project_path, exist_ok=True)

    print(f"Starting CodeSwarm Agno")
    print(f"Goal: {args.goal}")
    print(f"Path: {target_project_path}")
    print(f"Pairs: {args.pairs}, Rounds: {args.rounds}")

    session_state = {
        "overall_project_goal": args.goal,
        "target_project_path": target_project_path,
        "previous_summaries": []
    }

    admin_agent = agents.get_admin_agent()
    logger_agent = agents.get_admin_logger_agent()

    for r in range(1, args.rounds + 1):
        print(f"\n=== Round {r} ===")

        # Phase 1: Task Assignment
        session_state["round"] = r
        session_state["current_phase"] = "task_assignment"

        print("Admin Agent: Generating tasks...")
        admin_response = admin_agent.run(json.dumps(session_state))

        tasks_output = admin_response.content
        tasks = tasks_output.tasks

        if not tasks:
            print("No tasks generated by Admin Agent.")
            continue

        print(f"Generated {len(tasks)} tasks.")

        # Phase 2: Execution (Dev + Revisor)
        # Filter tasks based on available pairs?
        # The prompt asks Admin to generate tasks. It generates dev_id/revisor_id.
        # We should respect the number of pairs requested if the Admin generated more than intended?
        # Or assumes Admin knows the limit? The prompt doesn't explicitly limit pairs unless 'pairs' was passed in input (it wasn't).
        # But Admin generates 'dev_id' and 'revisor_id'.

        # Run tasks in parallel
        round_results = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=args.pairs) as executor:
            futures = [executor.submit(run_dev_revisor_pair, task, r) for task in tasks]
            for future in concurrent.futures.as_completed(futures):
                try:
                    result = future.result()
                    round_results.append(result)
                except Exception as e:
                    print(f"Error in task execution: {e}")

        # Phase 3: Logging and Updates
        session_state["current_phase"] = "logging_and_updates"
        # We need to pass the results of the round to the logger
        session_state["dev_outputs"] = [res["dev_output"] for res in round_results]
        session_state["revisor_feedback"] = [res["revisor_output"] for res in round_results]

        print("Admin Logger Agent: Updating logs...")
        logger_response = logger_agent.run(json.dumps(session_state))
        logger_output = logger_response.content
        print(f"Logger Status: {logger_output.status}. Message: {logger_output.message}")

        # Update summaries for next round if needed
        # (The original code had logic to extract summary, here we rely on logs or previous_summaries being updated)
        # Maybe add a summary of this round to 'previous_summaries'
        summary = f"Round {r} completed. {len(tasks)} tasks executed."
        session_state["previous_summaries"].append(summary)

        # Cleanup large objects from session state to avoid token limit issues if history grows?
        # Agno Agents usually maintain their own memory/history.
        # But here we are passing full state as input message.
        del session_state["dev_outputs"]
        del session_state["revisor_feedback"]

    print("\nCodeSwarm Agno Finished.")

if __name__ == "__main__":
    main()
