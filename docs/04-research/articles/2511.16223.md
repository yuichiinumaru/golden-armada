# DynaMimicGen: Dynamic Robot Data Generation

**Source:** [DynaMimicGen: A Data Generation Framework for Robot Learning of Dynamic Tasks](https://arxiv.org/html/2511.16223)

## Synthesis
This paper introduces **DynaMimicGen (D-MG)**, a framework for generating large-scale robot manipulation datasets from a single human demonstration.
*   **Problem:** Robots need massive datasets to learn, but collecting human demos is expensive. Existing augmentation methods (MimicGen) assume static scenes (the mug is always in the same place).
*   **Solution:** D-MG segments a demonstration into **Object-Centric Subtasks** (e.g., "Grasp Mug", "Move Mug"). It then encodes each segment as a **Dynamic Movement Primitive (DMP)**.
*   **Dynamic Adaptation:** DMPs allow the robot to adapt the trajectory in real-time if the object moves. The authors use this to generate thousands of valid trajectories by randomizing object positions in simulation.
*   **Result:** A policy trained on D-MG data (generated from 1 demo) outperforms policies trained on 10 human demos, especially in dynamic environments where objects move during execution.

## Core Strategic Ideas
1.  **Single-Shot to Many-Shot:** The ability to turn *one* high-quality example into a robust dataset is crucial for scaling. Instead of asking a human to do 100 times, ask them once and use simulation + DMPs to generate variations.
2.  **Object-Centric Primitives:** Breaking a complex task into "Move relative to Object A" and "Move relative to Object B" allows for modularity. If Object A moves, only the first part of the plan needs adjustment.
3.  **DMPs as Bridge:** Dynamic Movement Primitives are an older robotic control theory concept. This paper successfully bridges them with modern Deep Learning (Diffusion Policy), using DMPs as a data generator for the DL model.

## Integration Plan (Agno + SurrealDB + Gemini 3)
We can apply this "Data Augmentation" philosophy to **Code Generation**:

1.  **Code-DMP (Concept):**
    *   Instead of "Dynamic Movement Primitives", we have "Dynamic Code Templates".
    *   From one good code example (e.g., a perfect FastAPI endpoint), we can generate 100 variations (different variable names, different error handling styles, different docstring formats).
    *   This creates a synthetic dataset for fine-tuning or testing our agents.

2.  **Test Case Generation:**
    *   Use Gemini 3 to take *one* unit test and generate 50 variations (boundary cases, different inputs) to stress-test the code.
    *   Store these variations in `SurrealDB` as a "Test Suite".

3.  **Refactoring Gym:**
    *   Take a clean function. Use an agent to introduce "Mutations" (bad variable names, long functions, missing types).
    *   Train a "Refactoring Agent" to restore the original clean state. This is essentially "DynaMimicGen for Code".
