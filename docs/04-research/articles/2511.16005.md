# InfCode-C++: Structured Retrieval for C++ Issue Resolution

**Source:** [InfCode-C++: Intent-Guided Semantic Retrieval and AST-Structured Search for C++ Issue Resolution](https://arxiv.org/html/2511.16005)

## Synthesis
This paper addresses the poor performance of standard LLM coding agents on C++ codebases (e.g., 14% vs 75% on Python). The core problem is that "Lexical Retrieval" (grep, keyword search) fails in C++ due to **Overloading, Namespace Shadowing, and Template Instantiation**. Searching for `Search` might return a class, a function, a forward declaration, and a variable, confusing the agent.

The authors propose **InfCode-C++**, which uses a two-stage retrieval process:
1.  **Semantic Code-Intent Retrieval:** Finds *files* and *modules* relevant to the high-level intent (e.g., "serialization") using vector embeddings.
2.  **AST-Structured Querying:** Once inside a module, the agent uses *deterministic tools* (`FindClass`, `FindFunction`, `GetInheritanceChain`) that query the **Abstract Syntax Tree (AST)** instead of text.

Using this approach, InfCode-C++ achieves **25.58%** on the MultiSWE-bench-CPP benchmark, doubling the performance of prior agents.

## Core Strategic Ideas
1.  **Language-Specific Tooling:** Generalist "Code Agents" that rely on `grep` and `read_file` are insufficient for statically typed, complex languages. We need language-specific agents (e.g., a "C++ Specialist") equipped with AST tools.
2.  **Intent vs. Structure:** The "Intent" (What feature?) should be found via semantic search (Vector DB). The "Structure" (Where is the definition?) should be found via AST search. Mixing these up leads to poor context.
3.  **Selector Agent pattern:** Instead of one agent deciding if a patch is good, generate $N$ patches and have a separate **Selector Agent** prune, validate (run tests), and vote on the best one.

## Integration Plan (Agno + SurrealDB + Gemini 3)
1.  **AST-Based Tools:**
    *   Integrate `tree-sitter` into our Python-based agent tools.
    *   Create `tools/ast_search.py` with functions like `find_class_definition(file, class_name)` that return the exact lines of the class body, filtering out forward declarations.

2.  **SurrealDB as Semantic Index:**
    *   Store embeddings of *module descriptions* (not just raw code) in SurrealDB.
    *   `DEFINE FIELD embedding ON table modules TYPE array<float>;`
    *   When an issue comes in, query this index to find the "Intent Cluster" before grepping.

3.  **Selector Pattern in CodeSwarm:**
    *   Implement the `SelectorAgent` role.
    *   When the Developer Agent submits a PR, the Selector Agent:
        *   Checks out the branch.
        *   Runs tests.
        *   *Generates new test cases* targeting the changed lines (Behavioral Validation).
        *   If the new tests fail, it rejects the PR with a specific failure log.
