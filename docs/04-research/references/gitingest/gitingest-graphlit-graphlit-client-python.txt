Directory structure:
└── graphlit-graphlit-client-python/
    ├── README.md
    ├── __init__.py
    ├── azure-pipelines.yml
    ├── LICENSE
    ├── pyproject.toml
    ├── setup.py
    ├── documents/
    │   ├── alert/
    │   │   ├── CountAlerts.graphql
    │   │   ├── CreateAlert.graphql
    │   │   ├── DeleteAlert.graphql
    │   │   ├── DeleteAlerts.graphql
    │   │   ├── DeleteAllAlerts.graphql
    │   │   ├── DisableAlert.graphql
    │   │   ├── EnableAlert.graphql
    │   │   ├── GetAlert.graphql
    │   │   ├── QueryAlerts.graphql
    │   │   └── UpdateAlert.graphql
    │   ├── category/
    │   │   ├── CountCategories.graphql
    │   │   ├── CreateCategory.graphql
    │   │   ├── DeleteAllCategories.graphql
    │   │   ├── DeleteCategories.graphql
    │   │   ├── DeleteCategory.graphql
    │   │   ├── GetCategory.graphql
    │   │   ├── QueryCategories.graphql
    │   │   ├── UpdateCategory.graphql
    │   │   └── UpsertCategory.graphql
    │   ├── collection/
    │   │   ├── AddContentsToCollections.graphql
    │   │   ├── CountCollections.graphql
    │   │   ├── CreateCollection.graphql
    │   │   ├── DeleteAllCollections.graphql
    │   │   ├── DeleteCollection.graphql
    │   │   ├── DeleteCollections.graphql
    │   │   ├── GetCollection.graphql
    │   │   ├── QueryCollections.graphql
    │   │   ├── RemoveContentsFromCollection.graphql
    │   │   └── UpdateCollection.graphql
    │   ├── content/
    │   │   ├── CountContents.graphql
    │   │   ├── DeleteAllContents.graphql
    │   │   ├── DeleteContent.graphql
    │   │   ├── DeleteContents.graphql
    │   │   ├── DescribeEncodedImage.graphql
    │   │   ├── DescribeImage.graphql
    │   │   ├── ExtractContents.graphql
    │   │   ├── ExtractText.graphql
    │   │   ├── GetContent.graphql
    │   │   ├── IngestBatch.graphql
    │   │   ├── IngestEncodedFile.graphql
    │   │   ├── IngestMemory.graphql
    │   │   ├── IngestText.graphql
    │   │   ├── IngestTextBatch.graphql
    │   │   ├── IngestUri.graphql
    │   │   ├── IsContentDone.graphql
    │   │   ├── PublishContents.graphql
    │   │   ├── PublishText.graphql
    │   │   ├── QueryContents.graphql
    │   │   ├── QueryContentsFacets.graphql
    │   │   ├── QueryContentsGraph.graphql
    │   │   ├── ScreenshotPage.graphql
    │   │   ├── SummarizeContents.graphql
    │   │   ├── SummarizeText.graphql
    │   │   └── UpdateContent.graphql
    │   ├── conversation/
    │   │   ├── AskGraphlit.graphql
    │   │   ├── ClearConversation.graphql
    │   │   ├── CloseConversation.graphql
    │   │   ├── CompleteConversation.graphql
    │   │   ├── ContinueConversation.graphql
    │   │   ├── CountConversations.graphql
    │   │   ├── CreateConversation.graphql
    │   │   ├── DeleteAllConversations.graphql
    │   │   ├── DeleteConversation.graphql
    │   │   ├── DeleteConversations.graphql
    │   │   ├── FormatConversation.graphql
    │   │   ├── GetConversation.graphql
    │   │   ├── Prompt.graphql
    │   │   ├── PromptConversation.graphql
    │   │   ├── PublishConversation.graphql
    │   │   ├── QueryConversations.graphql
    │   │   ├── RetrieveSources.graphql
    │   │   ├── ReviseContent.graphql
    │   │   ├── ReviseEncodedImage.graphql
    │   │   ├── ReviseImage.graphql
    │   │   ├── ReviseText.graphql
    │   │   ├── SuggestConversation.graphql
    │   │   └── UpdateConversation.graphql
    │   ├── event/
    │   │   ├── CountEvents.graphql
    │   │   ├── CreateEvent.graphql
    │   │   ├── DeleteAllEvents.graphql
    │   │   ├── DeleteEvent.graphql
    │   │   ├── DeleteEvents.graphql
    │   │   ├── GetEvent.graphql
    │   │   ├── QueryEvents.graphql
    │   │   └── UpdateEvent.graphql
    │   ├── feed/
    │   │   ├── CountFeeds.graphql
    │   │   ├── CreateFeed.graphql
    │   │   ├── DeleteAllFeeds.graphql
    │   │   ├── DeleteFeed.graphql
    │   │   ├── DeleteFeeds.graphql
    │   │   ├── DisableFeed.graphql
    │   │   ├── EnableFeed.graphql
    │   │   ├── FeedExists.graphql
    │   │   ├── GetFeed.graphql
    │   │   ├── GetSharePointConsentUri.graphql
    │   │   ├── IsFeedDone.graphql
    │   │   ├── QueryFeeds.graphql
    │   │   ├── QueryLinearProjects.graphql
    │   │   ├── QueryMicrosoftTeamsChannels.graphql
    │   │   ├── QueryMicrosoftTeamsTeams.graphql
    │   │   ├── QueryNotionDatabases.graphql
    │   │   ├── QueryNotionPages.graphql
    │   │   ├── QueryOneDriveFolders.graphql
    │   │   ├── QuerySharePointFolders.graphql
    │   │   ├── QuerySharePointLibraries.graphql
    │   │   ├── QuerySlackChannels.graphql
    │   │   └── UpdateFeed.graphql
    │   ├── label/
    │   │   ├── CountLabels.graphql
    │   │   ├── CreateLabel.graphql
    │   │   ├── DeleteAllLabels.graphql
    │   │   ├── DeleteLabel.graphql
    │   │   ├── DeleteLabels.graphql
    │   │   ├── GetLabel.graphql
    │   │   ├── QueryLabels.graphql
    │   │   ├── UpdateLabel.graphql
    │   │   └── UpsertLabel.graphql
    │   ├── medicalCondition/
    │   │   ├── CountMedicalConditions.graphql
    │   │   ├── CreateMedicalCondition.graphql
    │   │   ├── DeleteAllMedicalConditions.graphql
    │   │   ├── DeleteMedicalCondition.graphql
    │   │   ├── DeleteMedicalConditions.graphql
    │   │   ├── GetMedicalCondition.graphql
    │   │   ├── QueryMedicalConditions.graphql
    │   │   └── UpdateMedicalCondition.graphql
    │   ├── medicalContraindication/
    │   │   ├── CountMedicalContraindications.graphql
    │   │   ├── CreateMedicalContraindication.graphql
    │   │   ├── DeleteAllMedicalContraindications.graphql
    │   │   ├── DeleteMedicalContraindication.graphql
    │   │   ├── DeleteMedicalContraindications.graphql
    │   │   ├── GetMedicalContraindication.graphql
    │   │   ├── QueryMedicalContraindications.graphql
    │   │   └── UpdateMedicalContraindication.graphql
    │   ├── medicalDevice/
    │   │   ├── CountMedicalDevices.graphql
    │   │   ├── CreateMedicalDevice.graphql
    │   │   ├── DeleteAllMedicalDevices.graphql
    │   │   ├── DeleteMedicalDevice.graphql
    │   │   ├── DeleteMedicalDevices.graphql
    │   │   ├── GetMedicalDevice.graphql
    │   │   ├── QueryMedicalDevices.graphql
    │   │   └── UpdateMedicalDevice.graphql
    │   ├── medicalDrug/
    │   │   ├── CountMedicalDrugs.graphql
    │   │   ├── CreateMedicalDrug.graphql
    │   │   ├── DeleteAllMedicalDrugs.graphql
    │   │   ├── DeleteMedicalDrug.graphql
    │   │   ├── DeleteMedicalDrugs.graphql
    │   │   ├── GetMedicalDrug.graphql
    │   │   ├── QueryMedicalDrugs.graphql
    │   │   └── UpdateMedicalDrug.graphql
    │   ├── medicalDrugClass/
    │   │   ├── CountMedicalDrugClasses.graphql
    │   │   ├── CreateMedicalDrugClass.graphql
    │   │   ├── DeleteAllMedicalDrugClasses.graphql
    │   │   ├── DeleteMedicalDrugClass.graphql
    │   │   ├── DeleteMedicalDrugClasses.graphql
    │   │   ├── GetMedicalDrugClass.graphql
    │   │   ├── QueryMedicalDrugClasses.graphql
    │   │   └── UpdateMedicalDrugClass.graphql
    │   ├── medicalGuideline/
    │   │   ├── CountMedicalGuidelines.graphql
    │   │   ├── CreateMedicalGuideline.graphql
    │   │   ├── DeleteAllMedicalGuidelines.graphql
    │   │   ├── DeleteMedicalGuideline.graphql
    │   │   ├── DeleteMedicalGuidelines.graphql
    │   │   ├── GetMedicalGuideline.graphql
    │   │   ├── QueryMedicalGuidelines.graphql
    │   │   └── UpdateMedicalGuideline.graphql
    │   ├── medicalIndication/
    │   │   ├── CountMedicalIndications.graphql
    │   │   ├── CreateMedicalIndication.graphql
    │   │   ├── DeleteAllMedicalIndications.graphql
    │   │   ├── DeleteMedicalIndication.graphql
    │   │   ├── DeleteMedicalIndications.graphql
    │   │   ├── GetMedicalIndication.graphql
    │   │   ├── QueryMedicalIndications.graphql
    │   │   └── UpdateMedicalIndication.graphql
    │   ├── medicalProcedure/
    │   │   ├── CountMedicalProcedures.graphql
    │   │   ├── CreateMedicalProcedure.graphql
    │   │   ├── DeleteAllMedicalProcedures.graphql
    │   │   ├── DeleteMedicalProcedure.graphql
    │   │   ├── DeleteMedicalProcedures.graphql
    │   │   ├── GetMedicalProcedure.graphql
    │   │   ├── QueryMedicalProcedures.graphql
    │   │   └── UpdateMedicalProcedure.graphql
    │   ├── medicalStudy/
    │   │   ├── CountMedicalStudies.graphql
    │   │   ├── CreateMedicalStudy.graphql
    │   │   ├── DeleteAllMedicalStudies.graphql
    │   │   ├── DeleteMedicalStudies.graphql
    │   │   ├── DeleteMedicalStudy.graphql
    │   │   ├── GetMedicalStudy.graphql
    │   │   ├── QueryMedicalStudies.graphql
    │   │   └── UpdateMedicalStudy.graphql
    │   ├── medicalTest/
    │   │   ├── CountMedicalTests.graphql
    │   │   ├── CreateMedicalTest.graphql
    │   │   ├── DeleteAllMedicalTests.graphql
    │   │   ├── DeleteMedicalTest.graphql
    │   │   ├── DeleteMedicalTests.graphql
    │   │   ├── GetMedicalTest.graphql
    │   │   ├── QueryMedicalTests.graphql
    │   │   └── UpdateMedicalTest.graphql
    │   ├── medicalTherapy/
    │   │   ├── CountMedicalTherapies.graphql
    │   │   ├── CreateMedicalTherapy.graphql
    │   │   ├── DeleteAllMedicalTherapies.graphql
    │   │   ├── DeleteMedicalTherapies.graphql
    │   │   ├── DeleteMedicalTherapy.graphql
    │   │   ├── GetMedicalTherapy.graphql
    │   │   ├── QueryMedicalTherapies.graphql
    │   │   └── UpdateMedicalTherapy.graphql
    │   ├── notification/
    │   │   └── SendNotification.graphql
    │   ├── observation/
    │   │   ├── CreateObservation.graphql
    │   │   ├── DeleteObservation.graphql
    │   │   └── UpdateObservation.graphql
    │   ├── organization/
    │   │   ├── CountOrganizations.graphql
    │   │   ├── CreateOrganization.graphql
    │   │   ├── DeleteAllOrganizations.graphql
    │   │   ├── DeleteOrganization.graphql
    │   │   ├── DeleteOrganizations.graphql
    │   │   ├── GetOrganization.graphql
    │   │   ├── QueryOrganizations.graphql
    │   │   └── UpdateOrganization.graphql
    │   ├── person/
    │   │   ├── CountPersons.graphql
    │   │   ├── CreatePerson.graphql
    │   │   ├── DeleteAllPersons.graphql
    │   │   ├── DeletePerson.graphql
    │   │   ├── DeletePersons.graphql
    │   │   ├── GetPerson.graphql
    │   │   ├── QueryPersons.graphql
    │   │   └── UpdatePerson.graphql
    │   ├── place/
    │   │   ├── CountPlaces.graphql
    │   │   ├── CreatePlace.graphql
    │   │   ├── DeleteAllPlaces.graphql
    │   │   ├── DeletePlace.graphql
    │   │   ├── DeletePlaces.graphql
    │   │   ├── GetPlace.graphql
    │   │   ├── QueryPlaces.graphql
    │   │   └── UpdatePlace.graphql
    │   ├── product/
    │   │   ├── CountProducts.graphql
    │   │   ├── CreateProduct.graphql
    │   │   ├── DeleteAllProducts.graphql
    │   │   ├── DeleteProduct.graphql
    │   │   ├── DeleteProducts.graphql
    │   │   ├── GetProduct.graphql
    │   │   ├── QueryProducts.graphql
    │   │   └── UpdateProduct.graphql
    │   ├── project/
    │   │   ├── GetProject.graphql
    │   │   ├── LookupCredits.graphql
    │   │   ├── LookupUsage.graphql
    │   │   ├── QueryCredits.graphql
    │   │   ├── QueryTokens.graphql
    │   │   ├── QueryUsage.graphql
    │   │   └── UpdateProject.graphql
    │   ├── repo/
    │   │   ├── CountRepos.graphql
    │   │   ├── CreateRepo.graphql
    │   │   ├── DeleteAllRepos.graphql
    │   │   ├── DeleteRepo.graphql
    │   │   ├── DeleteRepos.graphql
    │   │   ├── GetRepo.graphql
    │   │   ├── QueryRepos.graphql
    │   │   └── UpdateRepo.graphql
    │   ├── search/
    │   │   ├── MapWeb.graphql
    │   │   └── SearchWeb.graphql
    │   ├── software/
    │   │   ├── CountSoftwares.graphql
    │   │   ├── CreateSoftware.graphql
    │   │   ├── DeleteAllSoftwares.graphql
    │   │   ├── DeleteSoftware.graphql
    │   │   ├── DeleteSoftwares.graphql
    │   │   ├── GetSoftware.graphql
    │   │   ├── QuerySoftwares.graphql
    │   │   └── UpdateSoftware.graphql
    │   ├── specification/
    │   │   ├── CountSpecifications.graphql
    │   │   ├── CreateSpecification.graphql
    │   │   ├── DeleteAllSpecifications.graphql
    │   │   ├── DeleteSpecification.graphql
    │   │   ├── DeleteSpecifications.graphql
    │   │   ├── GetSpecification.graphql
    │   │   ├── PromptSpecifications.graphql
    │   │   ├── QueryModels.graphql
    │   │   ├── QuerySpecifications.graphql
    │   │   ├── SpecificationExists.graphql
    │   │   ├── UpdateSpecification.graphql
    │   │   └── UpsertSpecification.graphql
    │   ├── user/
    │   │   ├── CountUsers.graphql
    │   │   ├── CreateUser.graphql
    │   │   ├── DeleteUser.graphql
    │   │   ├── DisableUser.graphql
    │   │   ├── EnableUser.graphql
    │   │   ├── GetUser.graphql
    │   │   ├── QueryUsers.graphql
    │   │   └── UpdateUser.graphql
    │   └── workflow/
    │       ├── CountWorkflows.graphql
    │       ├── CreateWorkflow.graphql
    │       ├── DeleteAllWorkflows.graphql
    │       ├── DeleteWorkflow.graphql
    │       ├── DeleteWorkflows.graphql
    │       ├── GetWorkflow.graphql
    │       ├── QueryWorkflows.graphql
    │       ├── UpdateWorkflow.graphql
    │       ├── UpsertWorkflow.graphql
    │       └── WorkflowExists.graphql
    ├── graphlit/
    │   ├── __init__.py
    │   └── graphlit.py
    ├── graphlit_api/
    │   ├── __init__.py
    │   ├── add_contents_to_collections.py
    │   ├── ask_graphlit.py
    │   ├── async_base_client.py
    │   ├── base_model.py
    │   ├── clear_conversation.py
    │   ├── client.py
    │   ├── close_conversation.py
    │   ├── complete_conversation.py
    │   ├── continue_conversation.py
    │   ├── count_alerts.py
    │   ├── count_categories.py
    │   ├── count_collections.py
    │   ├── count_contents.py
    │   ├── count_conversations.py
    │   ├── count_events.py
    │   ├── count_feeds.py
    │   ├── count_labels.py
    │   ├── count_medical_conditions.py
    │   ├── count_medical_contraindications.py
    │   ├── count_medical_devices.py
    │   ├── count_medical_drug_classes.py
    │   ├── count_medical_drugs.py
    │   ├── count_medical_guidelines.py
    │   ├── count_medical_indications.py
    │   ├── count_medical_procedures.py
    │   ├── count_medical_studies.py
    │   ├── count_medical_tests.py
    │   ├── count_medical_therapies.py
    │   ├── count_organizations.py
    │   ├── count_persons.py
    │   ├── count_places.py
    │   ├── count_products.py
    │   ├── count_repos.py
    │   ├── count_softwares.py
    │   ├── count_specifications.py
    │   ├── count_users.py
    │   ├── count_workflows.py
    │   ├── create_alert.py
    │   ├── create_category.py
    │   ├── create_collection.py
    │   ├── create_conversation.py
    │   ├── create_event.py
    │   ├── create_feed.py
    │   ├── create_label.py
    │   ├── create_medical_condition.py
    │   ├── create_medical_contraindication.py
    │   ├── create_medical_device.py
    │   ├── create_medical_drug.py
    │   ├── create_medical_drug_class.py
    │   ├── create_medical_guideline.py
    │   ├── create_medical_indication.py
    │   ├── create_medical_procedure.py
    │   ├── create_medical_study.py
    │   ├── create_medical_test.py
    │   ├── create_medical_therapy.py
    │   ├── create_observation.py
    │   ├── create_organization.py
    │   ├── create_person.py
    │   ├── create_place.py
    │   ├── create_product.py
    │   ├── create_repo.py
    │   ├── create_software.py
    │   ├── create_specification.py
    │   ├── create_user.py
    │   ├── create_workflow.py
    │   ├── delete_alert.py
    │   ├── delete_alerts.py
    │   ├── delete_all_alerts.py
    │   ├── delete_all_categories.py
    │   ├── delete_all_collections.py
    │   ├── delete_all_contents.py
    │   ├── delete_all_conversations.py
    │   ├── delete_all_events.py
    │   ├── delete_all_feeds.py
    │   ├── delete_all_labels.py
    │   ├── delete_all_medical_conditions.py
    │   ├── delete_all_medical_contraindications.py
    │   ├── delete_all_medical_devices.py
    │   ├── delete_all_medical_drug_classes.py
    │   ├── delete_all_medical_drugs.py
    │   ├── delete_all_medical_guidelines.py
    │   ├── delete_all_medical_indications.py
    │   ├── delete_all_medical_procedures.py
    │   ├── delete_all_medical_studies.py
    │   ├── delete_all_medical_tests.py
    │   ├── delete_all_medical_therapies.py
    │   ├── delete_all_organizations.py
    │   ├── delete_all_persons.py
    │   ├── delete_all_places.py
    │   ├── delete_all_products.py
    │   ├── delete_all_repos.py
    │   ├── delete_all_softwares.py
    │   ├── delete_all_specifications.py
    │   ├── delete_all_workflows.py
    │   ├── delete_categories.py
    │   ├── delete_category.py
    │   ├── delete_collection.py
    │   ├── delete_collections.py
    │   ├── delete_content.py
    │   ├── delete_contents.py
    │   ├── delete_conversation.py
    │   ├── delete_conversations.py
    │   ├── delete_event.py
    │   ├── delete_events.py
    │   ├── delete_feed.py
    │   ├── delete_feeds.py
    │   ├── delete_label.py
    │   ├── delete_labels.py
    │   ├── delete_medical_condition.py
    │   ├── delete_medical_conditions.py
    │   ├── delete_medical_contraindication.py
    │   ├── delete_medical_contraindications.py
    │   ├── delete_medical_device.py
    │   ├── delete_medical_devices.py
    │   ├── delete_medical_drug.py
    │   ├── delete_medical_drug_class.py
    │   ├── delete_medical_drug_classes.py
    │   ├── delete_medical_drugs.py
    │   ├── delete_medical_guideline.py
    │   ├── delete_medical_guidelines.py
    │   ├── delete_medical_indication.py
    │   ├── delete_medical_indications.py
    │   ├── delete_medical_procedure.py
    │   ├── delete_medical_procedures.py
    │   ├── delete_medical_studies.py
    │   ├── delete_medical_study.py
    │   ├── delete_medical_test.py
    │   ├── delete_medical_tests.py
    │   ├── delete_medical_therapies.py
    │   ├── delete_medical_therapy.py
    │   ├── delete_observation.py
    │   ├── delete_organization.py
    │   ├── delete_organizations.py
    │   ├── delete_person.py
    │   ├── delete_persons.py
    │   ├── delete_place.py
    │   ├── delete_places.py
    │   ├── delete_product.py
    │   ├── delete_products.py
    │   ├── delete_repo.py
    │   ├── delete_repos.py
    │   ├── delete_software.py
    │   ├── delete_softwares.py
    │   ├── delete_specification.py
    │   ├── delete_specifications.py
    │   ├── delete_user.py
    │   ├── delete_workflow.py
    │   ├── delete_workflows.py
    │   ├── describe_encoded_image.py
    │   ├── describe_image.py
    │   ├── disable_alert.py
    │   ├── disable_feed.py
    │   ├── disable_user.py
    │   ├── enable_alert.py
    │   ├── enable_feed.py
    │   ├── enable_user.py
    │   ├── enums.py
    │   ├── exceptions.py
    │   ├── extract_contents.py
    │   ├── extract_text.py
    │   ├── feed_exists.py
    │   ├── format_conversation.py
    │   ├── get_alert.py
    │   ├── get_category.py
    │   ├── get_collection.py
    │   ├── get_content.py
    │   ├── get_conversation.py
    │   ├── get_event.py
    │   ├── get_feed.py
    │   ├── get_label.py
    │   ├── get_medical_condition.py
    │   ├── get_medical_contraindication.py
    │   ├── get_medical_device.py
    │   ├── get_medical_drug.py
    │   ├── get_medical_drug_class.py
    │   ├── get_medical_guideline.py
    │   ├── get_medical_indication.py
    │   ├── get_medical_procedure.py
    │   ├── get_medical_study.py
    │   ├── get_medical_test.py
    │   ├── get_medical_therapy.py
    │   ├── get_organization.py
    │   ├── get_person.py
    │   ├── get_place.py
    │   ├── get_product.py
    │   ├── get_project.py
    │   ├── get_repo.py
    │   ├── get_share_point_consent_uri.py
    │   ├── get_software.py
    │   ├── get_specification.py
    │   ├── get_user.py
    │   ├── get_workflow.py
    │   ├── ingest_batch.py
    │   ├── ingest_encoded_file.py
    │   ├── ingest_memory.py
    │   ├── ingest_text.py
    │   ├── ingest_text_batch.py
    │   ├── ingest_uri.py
    │   ├── input_types.py
    │   ├── is_content_done.py
    │   ├── is_feed_done.py
    │   ├── lookup_credits.py
    │   ├── lookup_usage.py
    │   ├── map_web.py
    │   ├── operations.py
    │   ├── prompt.py
    │   ├── prompt_conversation.py
    │   ├── prompt_specifications.py
    │   ├── publish_contents.py
    │   ├── publish_conversation.py
    │   ├── publish_text.py
    │   ├── query_alerts.py
    │   ├── query_categories.py
    │   ├── query_collections.py
    │   ├── query_contents.py
    │   ├── query_contents_facets.py
    │   ├── query_contents_graph.py
    │   ├── query_conversations.py
    │   ├── query_credits.py
    │   ├── query_events.py
    │   ├── query_feeds.py
    │   ├── query_labels.py
    │   ├── query_linear_projects.py
    │   ├── query_medical_conditions.py
    │   ├── query_medical_contraindications.py
    │   ├── query_medical_devices.py
    │   ├── query_medical_drug_classes.py
    │   ├── query_medical_drugs.py
    │   ├── query_medical_guidelines.py
    │   ├── query_medical_indications.py
    │   ├── query_medical_procedures.py
    │   ├── query_medical_studies.py
    │   ├── query_medical_tests.py
    │   ├── query_medical_therapies.py
    │   ├── query_microsoft_teams_channels.py
    │   ├── query_microsoft_teams_teams.py
    │   ├── query_models.py
    │   ├── query_notion_databases.py
    │   ├── query_notion_pages.py
    │   ├── query_one_drive_folders.py
    │   ├── query_organizations.py
    │   ├── query_persons.py
    │   ├── query_places.py
    │   ├── query_products.py
    │   ├── query_repos.py
    │   ├── query_share_point_folders.py
    │   ├── query_share_point_libraries.py
    │   ├── query_slack_channels.py
    │   ├── query_softwares.py
    │   ├── query_specifications.py
    │   ├── query_tokens.py
    │   ├── query_usage.py
    │   ├── query_users.py
    │   ├── query_workflows.py
    │   ├── remove_contents_from_collection.py
    │   ├── retrieve_sources.py
    │   ├── revise_content.py
    │   ├── revise_encoded_image.py
    │   ├── revise_image.py
    │   ├── revise_text.py
    │   ├── screenshot_page.py
    │   ├── search_web.py
    │   ├── send_notification.py
    │   ├── specification_exists.py
    │   ├── suggest_conversation.py
    │   ├── summarize_contents.py
    │   ├── summarize_text.py
    │   ├── update_alert.py
    │   ├── update_category.py
    │   ├── update_collection.py
    │   ├── update_content.py
    │   ├── update_conversation.py
    │   ├── update_event.py
    │   ├── update_feed.py
    │   ├── update_label.py
    │   ├── update_medical_condition.py
    │   ├── update_medical_contraindication.py
    │   ├── update_medical_device.py
    │   ├── update_medical_drug.py
    │   ├── update_medical_drug_class.py
    │   ├── update_medical_guideline.py
    │   ├── update_medical_indication.py
    │   ├── update_medical_procedure.py
    │   ├── update_medical_study.py
    │   ├── update_medical_test.py
    │   ├── update_medical_therapy.py
    │   ├── update_observation.py
    │   ├── update_organization.py
    │   ├── update_person.py
    │   ├── update_place.py
    │   ├── update_product.py
    │   ├── update_project.py
    │   ├── update_repo.py
    │   ├── update_software.py
    │   ├── update_specification.py
    │   ├── update_user.py
    │   ├── update_workflow.py
    │   ├── upsert_category.py
    │   ├── upsert_label.py
    │   ├── upsert_specification.py
    │   ├── upsert_workflow.py
    │   └── workflow_exists.py
    └── .github/
        └── ISSUE_TEMPLATE/
            └── bug_report.md

================================================
FILE: README.md
================================================
# Python Client for Graphlit Platform

## Overview

The Graphlit Client for Python enables easy interaction with the Graphlit API, allowing developers to execute queries and mutations against the Graphlit service. This document outlines the setup process and provides a basic example of using the client.

## Prerequisites

Before you begin, ensure you have the following:

- Python 3.x installed on your system.
- An active account on the [Graphlit Platform](https://portal.graphlit.dev) with access to the API settings dashboard.

## Installation

To install the Graphlit Client, use pip:

```bash
pip install graphlit-client
```

## Configuration

The Graphlit Client supports environment variables to be set for authentication and configuration:

- `GRAPHLIT_ENVIRONMENT_ID`: Your environment ID.
- `GRAPHLIT_ORGANIZATION_ID`: Your organization ID.
- `GRAPHLIT_JWT_SECRET`: Your JWT secret for signing the JWT token.

Alternately, you can pass these values with the constructor of the Graphlit client.

You can find these values in the API settings dashboard on the [Graphlit Platform](https://portal.graphlit.dev).

For example, to use Graphlit in a Google Colab notebook, you need to assign these properties as Colab secrets: GRAPHLIT_ORGANIZATION_ID, GRAPHLIT_ENVIRONMENT_ID and GRAPHLIT_JWT_SECRET.

```python
import os
from google.colab import userdata
from graphlit import Graphlit

os.environ['GRAPHLIT_ORGANIZATION_ID'] = userdata.get('GRAPHLIT_ORGANIZATION_ID')
os.environ['GRAPHLIT_ENVIRONMENT_ID'] = userdata.get('GRAPHLIT_ENVIRONMENT_ID')
os.environ['GRAPHLIT_JWT_SECRET'] = userdata.get('GRAPHLIT_JWT_SECRET')

graphlit = Graphlit()
```

### Setting Environment Variables

To set these environment variables on your system, use the following commands, replacing `your_value` with the actual values from your account.

For Unix/Linux/macOS:

```bash
export GRAPHLIT_ENVIRONMENT_ID=your_environment_id_value
export GRAPHLIT_ORGANIZATION_ID=your_organization_id_value
export GRAPHLIT_JWT_SECRET=your_secret_key_value
```

For Windows Command Prompt (CMD):

```cmd
set GRAPHLIT_ENVIRONMENT_ID=your_environment_id_value
set GRAPHLIT_ORGANIZATION_ID=your_organization_id_value
set GRAPHLIT_JWT_SECRET=your_secret_key_value
```

For Windows PowerShell:

```powershell
$env:GRAPHLIT_ENVIRONMENT_ID="your_environment_id_value"
$env:GRAPHLIT_ORGANIZATION_ID="your_organization_id_value"
$env:GRAPHLIT_JWT_SECRET="your_secret_key_value"
```

## Support

Please refer to the [Graphlit API Documentation](https://docs.graphlit.dev/).

For support with the Graphlit Client, please submit a [GitHub Issue](https://github.com/graphlit/graphlit-client-python/issues).  

For further support with the Graphlit Platform, please join our [Discord](https://discord.gg/ygFmfjy3Qx) community.



================================================
FILE: __init__.py
================================================
from graphlit import Graphlit


================================================
FILE: azure-pipelines.yml
================================================
trigger:
  branches:
    include:
      - main

name: $(Date:yyyyMMdd)$(Rev:rrr)

pool:
  vmImage: "ubuntu-latest"

steps:
  - task: UsePythonVersion@0
    inputs:
      versionSpec: "3.x"
      addToPath: true

  - script: |
      echo "##vso[task.setvariable variable=PACKAGE_VERSION]1.0.$(Build.BuildNumber)"
    displayName: "Set package version"

  - script: |
      python -m pip install --upgrade pip
      pip install setuptools wheel twine
      python setup.py sdist bdist_wheel
    displayName: "Install dependencies and build"

  - script: |
      twine upload dist/* -u __token__ -p $(PYPI_TOKEN) --skip-existing
    displayName: "Upload to PyPI"
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2024 Unstruk Data Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: pyproject.toml
================================================
[tool.ariadne-codegen]
remote_schema_url = "https://data-scus.graphlit.io/api/v1/graphql"
queries_path = "./documents"
target_package_name = "graphlit_api"
client_name = "Client"
client_file_name = "client"

plugins = ["ariadne_codegen.contrib.extract_operations.ExtractOperationsPlugin"]


================================================
FILE: setup.py
================================================
from setuptools import setup, find_packages
import os

# Read the content of your README file
with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

version = os.getenv('PACKAGE_VERSION', '1.0.0')

setup(
    name='graphlit-client',
    version=version,
    packages=find_packages(),
    install_requires=[
        'httpx',
        'pydantic>=2.0.0,<3.0.0',
        'PyJWT',
        'websockets'
    ],
    python_requires='>=3.6',
    author='Unstruk Data Inc.',
    author_email='questions@graphlit.com',
    description='Graphlit API Python Client',
    url='https://github.com/graphlit/graphlit-client-python',
    long_description=long_description,
    long_description_content_type="text/markdown",
)



================================================
FILE: documents/alert/CountAlerts.graphql
================================================
query CountAlerts($filter: AlertFilter, $correlationId: String) {
  countAlerts(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/alert/CreateAlert.graphql
================================================
mutation CreateAlert($alert: AlertInput!, $correlationId: String) {
  createAlert(alert: $alert, correlationId: $correlationId) {
    id
    name
    state
    type
  }
}



================================================
FILE: documents/alert/DeleteAlert.graphql
================================================
mutation DeleteAlert($id: ID!) {
  deleteAlert(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/alert/DeleteAlerts.graphql
================================================
mutation DeleteAlerts($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteAlerts(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/alert/DeleteAllAlerts.graphql
================================================
mutation DeleteAllAlerts($filter: AlertFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllAlerts(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/alert/DisableAlert.graphql
================================================
mutation DisableAlert($id: ID!) {
  disableAlert(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/alert/EnableAlert.graphql
================================================
mutation EnableAlert($id: ID!) {
  enableAlert(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/alert/GetAlert.graphql
================================================
query GetAlert($id: ID!, $correlationId: String) {
  alert(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    correlationId
    type
    summaryPrompt
    publishPrompt
    filter {
      dateRange {
        from
        to
      }
      inLast
      creationDateRange {
        from
        to
      }
      createdInLast
      types
      fileTypes
      formats
      fileExtensions
      similarContents {
        id
      }
      contents {
        id
      }
      feeds {
        id
      }
      workflows {
        id
      }
      collections {
        id
      }
      users {
        id
      }
      observations {
        type
        observable {
          id
        }
        states
      }
      or {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
      and {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
    }
    integration {
      type
      uri
      slack {
        token
        channel
      }
      email {
        from
        subject
        to
      }
      twitter {
        consumerKey
        consumerSecret
        accessTokenKey
        accessTokenSecret
      }
    }
    publishing {
      type
      elevenLabs {
        model
        voice
      }
      openAIImage {
        model
        count
        seed {
          id
        }
      }
    }
    summarySpecification {
      id
    }
    publishSpecification {
      id
    }
    lastAlertDate
  }
}



================================================
FILE: documents/alert/QueryAlerts.graphql
================================================
query QueryAlerts($filter: AlertFilter, $correlationId: String) {
  alerts(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      correlationId
      type
      summaryPrompt
      publishPrompt
      filter {
        dateRange {
          from
          to
        }
        inLast
        creationDateRange {
          from
          to
        }
        createdInLast
        types
        fileTypes
        formats
        fileExtensions
        similarContents {
          id
        }
        contents {
          id
        }
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
        or {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
        and {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
      }
      integration {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
      publishing {
        type
        elevenLabs {
          model
          voice
        }
        openAIImage {
          model
          count
          seed {
            id
          }
        }
      }
      summarySpecification {
        id
      }
      publishSpecification {
        id
      }
      lastAlertDate
    }
  }
}



================================================
FILE: documents/alert/UpdateAlert.graphql
================================================
mutation UpdateAlert($alert: AlertUpdateInput!) {
  updateAlert(alert: $alert) {
    id
    name
    state
    type
  }
}



================================================
FILE: documents/category/CountCategories.graphql
================================================
query CountCategories($filter: CategoryFilter, $correlationId: String) {
  countCategories(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/category/CreateCategory.graphql
================================================
mutation CreateCategory($category: CategoryInput!) {
  createCategory(category: $category) {
    id
    name
  }
}



================================================
FILE: documents/category/DeleteAllCategories.graphql
================================================
mutation DeleteAllCategories($filter: CategoryFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllCategories(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/category/DeleteCategories.graphql
================================================
mutation DeleteCategories($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteCategories(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/category/DeleteCategory.graphql
================================================
mutation DeleteCategory($id: ID!) {
  deleteCategory(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/category/GetCategory.graphql
================================================
query GetCategory($id: ID!, $correlationId: String) {
  category(id: $id, correlationId: $correlationId) {
    id
    name
    description
    creationDate
    relevance
  }
}



================================================
FILE: documents/category/QueryCategories.graphql
================================================
query QueryCategories($filter: CategoryFilter, $correlationId: String) {
  categories(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      description
      creationDate
      relevance
    }
  }
}



================================================
FILE: documents/category/UpdateCategory.graphql
================================================
mutation UpdateCategory($category: CategoryUpdateInput!) {
  updateCategory(category: $category) {
    id
    name
  }
}



================================================
FILE: documents/category/UpsertCategory.graphql
================================================
mutation UpsertCategory($category: CategoryInput!) {
  upsertCategory(category: $category) {
    id
    name
  }
}



================================================
FILE: documents/collection/AddContentsToCollections.graphql
================================================
mutation AddContentsToCollections($contents: [EntityReferenceInput!]!, $collections: [EntityReferenceInput!]!) {
  addContentsToCollections(contents: $contents, collections: $collections) {
    id
    name
    state
    type
    contents {
      id
      name
    }
  }
}



================================================
FILE: documents/collection/CountCollections.graphql
================================================
query CountCollections($filter: CollectionFilter, $correlationId: String) {
  countCollections(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/collection/CreateCollection.graphql
================================================
mutation CreateCollection($collection: CollectionInput!) {
  createCollection(collection: $collection) {
    id
    name
    state
    type
  }
}



================================================
FILE: documents/collection/DeleteAllCollections.graphql
================================================
mutation DeleteAllCollections($filter: CollectionFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllCollections(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/collection/DeleteCollection.graphql
================================================
mutation DeleteCollection($id: ID!) {
  deleteCollection(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/collection/DeleteCollections.graphql
================================================
mutation DeleteCollections($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteCollections(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/collection/GetCollection.graphql
================================================
query GetCollection($id: ID!, $correlationId: String) {
  collection(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    type
    contents {
      id
      name
    }
  }
}



================================================
FILE: documents/collection/QueryCollections.graphql
================================================
query QueryCollections($filter: CollectionFilter, $correlationId: String) {
  collections(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      type
      contents {
        id
        name
      }
    }
  }
}



================================================
FILE: documents/collection/RemoveContentsFromCollection.graphql
================================================
mutation RemoveContentsFromCollection($contents: [EntityReferenceInput!]!, $collection: EntityReferenceInput!) {
  removeContentsFromCollection(contents: $contents, collection: $collection) {
    id
    name
    state
    type
    contents {
      id
      name
    }
  }
}



================================================
FILE: documents/collection/UpdateCollection.graphql
================================================
mutation UpdateCollection($collection: CollectionUpdateInput!) {
  updateCollection(collection: $collection) {
    id
    name
    state
    type
  }
}



================================================
FILE: documents/content/CountContents.graphql
================================================
query CountContents($filter: ContentFilter, $correlationId: String) {
  countContents(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/content/DeleteAllContents.graphql
================================================
mutation DeleteAllContents($filter: ContentFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllContents(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/content/DeleteContent.graphql
================================================
mutation DeleteContent($id: ID!) {
  deleteContent(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/content/DeleteContents.graphql
================================================
mutation DeleteContents($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteContents(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/content/DescribeEncodedImage.graphql
================================================
mutation DescribeEncodedImage($prompt: String!, $mimeType: String!, $data: String!, $specification: EntityReferenceInput, $correlationId: String) {
  describeEncodedImage(prompt: $prompt, mimeType: $mimeType, data: $data, specification: $specification, correlationId: $correlationId) {
    role
    author
    message
    citations {
      content {
        id
        name
        state
        originalDate
        identifier
        uri
        type
        fileType
        mimeType
        format
        formatName
        fileExtension
        fileName
        fileSize
        masterUri
        imageUri
        textUri
        audioUri
        transcriptUri
        summary
        customSummary
        keywords
        bullets
        headlines
        posts
        chapters
        questions
        video {
          width
          height
          duration
          make
          model
          software
          title
          description
          keywords
          author
        }
        audio {
          keywords
          author
          series
          episode
          episodeType
          season
          publisher
          copyright
          genre
          title
          description
          bitrate
          channels
          sampleRate
          bitsPerSample
          duration
        }
        image {
          width
          height
          resolutionX
          resolutionY
          bitsPerComponent
          components
          projectionType
          orientation
          description
          make
          model
          software
          lens
          focalLength
          exposureTime
          fNumber
          iso
          heading
          pitch
        }
        document {
          title
          subject
          summary
          author
          publisher
          description
          keywords
          pageCount
          worksheetCount
          slideCount
          wordCount
          lineCount
          paragraphCount
          isEncrypted
          hasDigitalSignature
        }
      }
      index
      text
      startTime
      endTime
      pageNumber
      frameNumber
    }
    toolCalls {
      id
      name
      arguments
    }
    tokens
    throughput
    completionTime
    timestamp
    modelService
    model
    data
    mimeType
    toolCallId
    toolCallResponse
  }
}



================================================
FILE: documents/content/DescribeImage.graphql
================================================
mutation DescribeImage($prompt: String!, $uri: URL!, $specification: EntityReferenceInput, $correlationId: String) {
  describeImage(prompt: $prompt, uri: $uri, specification: $specification, correlationId: $correlationId) {
    role
    author
    message
    citations {
      content {
        id
        name
        state
        originalDate
        identifier
        uri
        type
        fileType
        mimeType
        format
        formatName
        fileExtension
        fileName
        fileSize
        masterUri
        imageUri
        textUri
        audioUri
        transcriptUri
        summary
        customSummary
        keywords
        bullets
        headlines
        posts
        chapters
        questions
        video {
          width
          height
          duration
          make
          model
          software
          title
          description
          keywords
          author
        }
        audio {
          keywords
          author
          series
          episode
          episodeType
          season
          publisher
          copyright
          genre
          title
          description
          bitrate
          channels
          sampleRate
          bitsPerSample
          duration
        }
        image {
          width
          height
          resolutionX
          resolutionY
          bitsPerComponent
          components
          projectionType
          orientation
          description
          make
          model
          software
          lens
          focalLength
          exposureTime
          fNumber
          iso
          heading
          pitch
        }
        document {
          title
          subject
          summary
          author
          publisher
          description
          keywords
          pageCount
          worksheetCount
          slideCount
          wordCount
          lineCount
          paragraphCount
          isEncrypted
          hasDigitalSignature
        }
      }
      index
      text
      startTime
      endTime
      pageNumber
      frameNumber
    }
    toolCalls {
      id
      name
      arguments
    }
    tokens
    throughput
    completionTime
    timestamp
    modelService
    model
    data
    mimeType
    toolCallId
    toolCallResponse
  }
}



================================================
FILE: documents/content/ExtractContents.graphql
================================================
mutation ExtractContents($prompt: String!, $filter: ContentFilter, $specification: EntityReferenceInput, $tools: [ToolDefinitionInput!]!, $correlationId: String) {
  extractContents(prompt: $prompt, filter: $filter, specification: $specification, tools: $tools, correlationId: $correlationId) {
    specification {
      id
    }
    content {
      id
    }
    name
    value
    startTime
    endTime
    pageNumber
    error
  }
}



================================================
FILE: documents/content/ExtractText.graphql
================================================
mutation ExtractText($prompt: String!, $text: String!, $textType: TextTypes, $specification: EntityReferenceInput, $tools: [ToolDefinitionInput!]!, $correlationId: String) {
  extractText(prompt: $prompt, text: $text, textType: $textType, specification: $specification, tools: $tools, correlationId: $correlationId) {
    specification {
      id
    }
    content {
      id
    }
    name
    value
    startTime
    endTime
    pageNumber
    error
  }
}



================================================
FILE: documents/content/GetContent.graphql
================================================
query GetContent($id: ID!, $correlationId: String) {
  content(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    owner {
      id
    }
    state
    originalDate
    finishedDate
    workflowDuration
    uri
    description
    identifier
    markdown
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
    location {
      latitude
      longitude
    }
    c4id
    type
    fileType
    mimeType
    format
    formatName
    fileName
    fileSize
    masterUri
    imageUri
    textUri
    audioUri
    transcriptUri
    summary
    customSummary
    keywords
    bullets
    headlines
    posts
    chapters
    questions
    video {
      width
      height
      duration
      make
      model
      software
      title
      description
      keywords
      author
    }
    audio {
      keywords
      author
      series
      episode
      episodeType
      season
      publisher
      copyright
      genre
      title
      description
      bitrate
      channels
      sampleRate
      bitsPerSample
      duration
    }
    image {
      width
      height
      resolutionX
      resolutionY
      bitsPerComponent
      components
      projectionType
      orientation
      description
      make
      model
      software
      lens
      focalLength
      exposureTime
      fNumber
      iso
      heading
      pitch
    }
    document {
      title
      subject
      summary
      author
      publisher
      description
      keywords
      pageCount
      worksheetCount
      slideCount
      wordCount
      lineCount
      paragraphCount
      isEncrypted
      hasDigitalSignature
    }
    email {
      identifier
      threadIdentifier
      subject
      labels
      sensitivity
      priority
      importance
      from {
        name
        email
        givenName
        familyName
      }
      to {
        name
        email
        givenName
        familyName
      }
      cc {
        name
        email
        givenName
        familyName
      }
      bcc {
        name
        email
        givenName
        familyName
      }
    }
    issue {
      identifier
      title
      project
      team
      status
      priority
      type
      labels
    }
    package {
      fileCount
      folderCount
      isEncrypted
    }
    language {
      languages
    }
    parent {
      id
      name
    }
    children {
      id
      name
    }
    feed {
      id
      name
    }
    collections {
      id
      name
    }
    links {
      uri
      linkType
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
    workflow {
      id
      name
    }
    pages {
      index
      text
      relevance
      images {
        id
        mimeType
        data
        left
        right
        top
        bottom
      }
      chunks {
        index
        pageIndex
        rowIndex
        columnIndex
        confidence
        text
        role
        language
        relevance
      }
    }
    segments {
      startTime
      endTime
      text
      relevance
    }
    frames {
      index
      description
      text
      relevance
    }
    error
  }
}



================================================
FILE: documents/content/IngestBatch.graphql
================================================
mutation IngestBatch($uris: [URL!]!, $workflow: EntityReferenceInput, $collections: [EntityReferenceInput!], $observations: [ObservationReferenceInput!], $correlationId: String) {
  ingestBatch(uris: $uris, workflow: $workflow, collections: $collections, observations: $observations, correlationId: $correlationId) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}



================================================
FILE: documents/content/IngestEncodedFile.graphql
================================================
mutation IngestEncodedFile($name: String!, $data: String!, $mimeType: String!, $id: ID, $isSynchronous: Boolean, $collections: [EntityReferenceInput!], $observations: [ObservationReferenceInput!], $workflow: EntityReferenceInput, $correlationId: String) {
  ingestEncodedFile(name: $name, data: $data, mimeType: $mimeType, id: $id, isSynchronous: $isSynchronous, collections: $collections, observations: $observations, workflow: $workflow, correlationId: $correlationId) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}



================================================
FILE: documents/content/IngestMemory.graphql
================================================
mutation IngestMemory($text: String!, $name: String, $textType: TextTypes, $collections: [EntityReferenceInput!], $correlationId: String) {
  ingestMemory(name: $name, text: $text, textType: $textType, collections: $collections, correlationId: $correlationId) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}



================================================
FILE: documents/content/IngestText.graphql
================================================
mutation IngestText($text: String!, $name: String, $textType: TextTypes, $uri: URL, $id: ID, $isSynchronous: Boolean, $workflow: EntityReferenceInput, $collections: [EntityReferenceInput!], $observations: [ObservationReferenceInput!], $correlationId: String) {
  ingestText(name: $name, text: $text, textType: $textType, uri: $uri, id: $id, isSynchronous: $isSynchronous, workflow: $workflow, collections: $collections, observations: $observations, correlationId: $correlationId) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}



================================================
FILE: documents/content/IngestTextBatch.graphql
================================================
mutation IngestTextBatch($batch: [TextContentInput!]!, $textType: TextTypes, $workflow: EntityReferenceInput, $collections: [EntityReferenceInput!], $observations: [ObservationReferenceInput!], $correlationId: String) {
  ingestTextBatch(batch: $batch, workflow: $workflow, textType: $textType, collections: $collections, observations: $observations, correlationId: $correlationId) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}



================================================
FILE: documents/content/IngestUri.graphql
================================================
mutation IngestUri($name: String, $uri: URL!, $id: ID, $mimeType: String, $isSynchronous: Boolean, $workflow: EntityReferenceInput, $collections: [EntityReferenceInput!], $observations: [ObservationReferenceInput!], $correlationId: String) {
  ingestUri(name: $name, uri: $uri, id: $id, mimeType: $mimeType, workflow: $workflow, collections: $collections, observations: $observations, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}



================================================
FILE: documents/content/IsContentDone.graphql
================================================
query IsContentDone($id: ID!) {
  isContentDone(id: $id) {
    result
  }
}



================================================
FILE: documents/content/PublishContents.graphql
================================================
mutation PublishContents($summaryPrompt: String, $publishPrompt: String!, $connector: ContentPublishingConnectorInput!, $filter: ContentFilter, $includeDetails: Boolean, $isSynchronous: Boolean, $correlationId: String, $name: String, $summarySpecification: EntityReferenceInput, $publishSpecification: EntityReferenceInput, $workflow: EntityReferenceInput) {
  publishContents(summaryPrompt: $summaryPrompt, publishPrompt: $publishPrompt, connector: $connector, filter: $filter, includeDetails: $includeDetails, isSynchronous: $isSynchronous, correlationId: $correlationId, name: $name, summarySpecification: $summarySpecification, publishSpecification: $publishSpecification, workflow: $workflow) {
    contents {
      id
      name
      state
      originalDate
      identifier
      markdown
      uri
      type
      fileType
      mimeType
      format
      formatName
      fileExtension
      fileName
      fileSize
      masterUri
      imageUri
      textUri
      audioUri
      transcriptUri
      summary
      customSummary
      keywords
      bullets
      headlines
      posts
      chapters
      questions
      video {
        width
        height
        duration
        make
        model
        software
        title
        description
        keywords
        author
      }
      audio {
        keywords
        author
        series
        episode
        episodeType
        season
        publisher
        copyright
        genre
        title
        description
        bitrate
        channels
        sampleRate
        bitsPerSample
        duration
      }
      image {
        width
        height
        resolutionX
        resolutionY
        bitsPerComponent
        components
        projectionType
        orientation
        description
        make
        model
        software
        lens
        focalLength
        exposureTime
        fNumber
        iso
        heading
        pitch
      }
      document {
        title
        subject
        summary
        author
        publisher
        description
        keywords
        pageCount
        worksheetCount
        slideCount
        wordCount
        lineCount
        paragraphCount
        isEncrypted
        hasDigitalSignature
      }
    }
    details {
      contents {
        id
      }
      summaries
      text
      textType
      summarySpecification
      publishSpecification
      summaryTime
      publishTime
    }
  }
}



================================================
FILE: documents/content/PublishText.graphql
================================================
mutation PublishText($text: String!, $textType: TextTypes, $connector: ContentPublishingConnectorInput!, $isSynchronous: Boolean, $correlationId: String, $name: String, $workflow: EntityReferenceInput) {
  publishText(text: $text, textType: $textType, connector: $connector, isSynchronous: $isSynchronous, correlationId: $correlationId, name: $name, workflow: $workflow) {
    contents {
      id
      name
      state
      originalDate
      identifier
      markdown
      uri
      type
      fileType
      mimeType
      format
      formatName
      fileExtension
      fileName
      fileSize
      masterUri
      imageUri
      textUri
      audioUri
      transcriptUri
      summary
      customSummary
      keywords
      bullets
      headlines
      posts
      chapters
      questions
      video {
        width
        height
        duration
        make
        model
        software
        title
        description
        keywords
        author
      }
      audio {
        keywords
        author
        series
        episode
        episodeType
        season
        publisher
        copyright
        genre
        title
        description
        bitrate
        channels
        sampleRate
        bitsPerSample
        duration
      }
      image {
        width
        height
        resolutionX
        resolutionY
        bitsPerComponent
        components
        projectionType
        orientation
        description
        make
        model
        software
        lens
        focalLength
        exposureTime
        fNumber
        iso
        heading
        pitch
      }
      document {
        title
        subject
        summary
        author
        publisher
        description
        keywords
        pageCount
        worksheetCount
        slideCount
        wordCount
        lineCount
        paragraphCount
        isEncrypted
        hasDigitalSignature
      }
    }
    details {
      contents {
        id
      }
      summaries
      text
      textType
      summarySpecification
      publishSpecification
      summaryTime
      publishTime
    }
  }
}



================================================
FILE: documents/content/QueryContents.graphql
================================================
query QueryContents($filter: ContentFilter, $correlationId: String) {
  contents(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      originalDate
      finishedDate
      workflowDuration
      uri
      description
      identifier
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
      location {
        latitude
        longitude
      }
      type
      fileType
      mimeType
      fileName
      fileSize
      masterUri
      imageUri
      textUri
      audioUri
      transcriptUri
      summary
      customSummary
      keywords
      bullets
      headlines
      posts
      chapters
      questions
      video {
        width
        height
        duration
        make
        model
        software
        title
        description
        keywords
        author
      }
      audio {
        keywords
        author
        series
        episode
        episodeType
        season
        publisher
        copyright
        genre
        title
        description
        bitrate
        channels
        sampleRate
        bitsPerSample
        duration
      }
      image {
        width
        height
        resolutionX
        resolutionY
        bitsPerComponent
        components
        projectionType
        orientation
        description
        make
        model
        software
        lens
        focalLength
        exposureTime
        fNumber
        iso
        heading
        pitch
      }
      document {
        title
        subject
        summary
        author
        publisher
        description
        keywords
        pageCount
        worksheetCount
        slideCount
        wordCount
        lineCount
        paragraphCount
        isEncrypted
        hasDigitalSignature
      }
      email {
        identifier
        threadIdentifier
        subject
        labels
        sensitivity
        priority
        importance
        from {
          name
          email
          givenName
          familyName
        }
        to {
          name
          email
          givenName
          familyName
        }
        cc {
          name
          email
          givenName
          familyName
        }
        bcc {
          name
          email
          givenName
          familyName
        }
      }
      issue {
        identifier
        title
        project
        team
        status
        priority
        type
        labels
      }
      package {
        fileCount
        folderCount
        isEncrypted
      }
      language {
        languages
      }
      feed {
        id
        name
      }
      collections {
        id
        name
      }
      links {
        uri
        linkType
      }
      observations {
        id
        type
        observable {
          id
          name
        }
        related {
          id
          name
        }
        relatedType
        relation
        occurrences {
          type
          confidence
          startTime
          endTime
          pageIndex
          boundingBox {
            left
            top
            width
            height
          }
        }
        state
      }
      workflow {
        id
        name
      }
      pages {
        index
        text
        relevance
        images {
          id
          mimeType
          data
          left
          right
          top
          bottom
        }
        chunks {
          index
          pageIndex
          rowIndex
          columnIndex
          confidence
          text
          role
          language
          relevance
        }
      }
      segments {
        startTime
        endTime
        text
        relevance
      }
      frames {
        index
        description
        text
        relevance
      }
      error
    }
  }
}



================================================
FILE: documents/content/QueryContentsFacets.graphql
================================================
query QueryContentsFacets($filter: ContentFilter, $facets: [ContentFacetInput!], $correlationId: String) {
  contents(filter: $filter, facets: $facets, correlationId: $correlationId) {
    facets {
      facet
      count
      type
      value
      range {
        from
        to
      }
      observable {
        type
        observable {
          id
          name
        }
      }
    }
  }
}



================================================
FILE: documents/content/QueryContentsGraph.graphql
================================================
query QueryContentsGraph($filter: ContentFilter, $graph: ContentGraphInput, $correlationId: String) {
  contents(filter: $filter, graph: $graph, correlationId: $correlationId) {
    graph {
      nodes {
        id
        name
        type
        metadata
      }
      edges {
        from
        to
        relation
      }
    }
  }
}



================================================
FILE: documents/content/ScreenshotPage.graphql
================================================
mutation ScreenshotPage($uri: URL!, $maximumHeight: Int, $isSynchronous: Boolean, $workflow: EntityReferenceInput, $collections: [EntityReferenceInput!], $correlationId: String) {
  screenshotPage(uri: $uri, maximumHeight: $maximumHeight, workflow: $workflow, collections: $collections, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}



================================================
FILE: documents/content/SummarizeContents.graphql
================================================
mutation SummarizeContents($summarizations: [SummarizationStrategyInput!]!, $filter: ContentFilter, $correlationId: String) {
  summarizeContents(summarizations: $summarizations, filter: $filter, correlationId: $correlationId) {
    specification {
      id
    }
    content {
      id
    }
    type
    items {
      text
      tokens
      summarizationTime
    }
    error
  }
}



================================================
FILE: documents/content/SummarizeText.graphql
================================================
mutation SummarizeText($summarization: SummarizationStrategyInput!, $text: String!, $textType: TextTypes, $correlationId: String) {
  summarizeText(summarization: $summarization, text: $text, textType: $textType, correlationId: $correlationId) {
    specification {
      id
    }
    content {
      id
    }
    type
    items {
      text
      tokens
      summarizationTime
    }
    error
  }
}



================================================
FILE: documents/content/UpdateContent.graphql
================================================
mutation UpdateContent($content: ContentUpdateInput!) {
  updateContent(content: $content) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}



================================================
FILE: documents/conversation/AskGraphlit.graphql
================================================
mutation AskGraphlit($prompt: String!, $type: SdkTypes, $id: ID, $specification: EntityReferenceInput, $correlationId: String) {
  askGraphlit(prompt: $prompt, type: $type, id: $id, specification: $specification, correlationId: $correlationId) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
  }
}



================================================
FILE: documents/conversation/ClearConversation.graphql
================================================
mutation ClearConversation($id: ID!) {
  clearConversation(id: $id) {
    id
    name
    state
    type
  }
}



================================================
FILE: documents/conversation/CloseConversation.graphql
================================================
mutation CloseConversation($id: ID!) {
  closeConversation(id: $id) {
    id
    name
    state
    type
  }
}



================================================
FILE: documents/conversation/CompleteConversation.graphql
================================================
mutation CompleteConversation($completion: String!, $id: ID!, $correlationId: String) {
  completeConversation(completion: $completion, id: $id, correlationId: $correlationId) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
    facets {
      type
      value
      range {
        from
        to
      }
      count
      facet
      observable {
        type
        observable {
          id
          name
        }
      }
    }
    graph {
      nodes {
        id
        name
        type
        metadata
      }
      edges {
        from
        to
        relation
      }
    }
    details {
      modelService
      model
      supportsToolCalling
      sourceCount
      observableCount
      toolCount
      renderedSourceCount
      renderedObservableCount
      renderedToolCount
      rankedSourceCount
      rankedObservableCount
      rankedToolCount
      tokenLimit
      completionTokenLimit
      sources
      formattedSources
      formattedObservables
      formattedInstructions
      formattedTools
      specification
      messages {
        role
        author
        message
        citations {
          content {
            id
            name
            state
            originalDate
            identifier
            uri
            type
            fileType
            mimeType
            format
            formatName
            fileExtension
            fileName
            fileSize
            masterUri
            imageUri
            textUri
            audioUri
            transcriptUri
            summary
            customSummary
            keywords
            bullets
            headlines
            posts
            chapters
            questions
            video {
              width
              height
              duration
              make
              model
              software
              title
              description
              keywords
              author
            }
            audio {
              keywords
              author
              series
              episode
              episodeType
              season
              publisher
              copyright
              genre
              title
              description
              bitrate
              channels
              sampleRate
              bitsPerSample
              duration
            }
            image {
              width
              height
              resolutionX
              resolutionY
              bitsPerComponent
              components
              projectionType
              orientation
              description
              make
              model
              software
              lens
              focalLength
              exposureTime
              fNumber
              iso
              heading
              pitch
            }
            document {
              title
              subject
              summary
              author
              publisher
              description
              keywords
              pageCount
              worksheetCount
              slideCount
              wordCount
              lineCount
              paragraphCount
              isEncrypted
              hasDigitalSignature
            }
          }
          index
          text
          startTime
          endTime
          pageNumber
          frameNumber
        }
        toolCalls {
          id
          name
          arguments
        }
        tokens
        throughput
        completionTime
        timestamp
        modelService
        model
        data
        mimeType
        toolCallId
        toolCallResponse
      }
    }
  }
}



================================================
FILE: documents/conversation/ContinueConversation.graphql
================================================
mutation ContinueConversation($id: ID!, $responses: [ConversationToolResponseInput!]!, $correlationId: String) {
  continueConversation(id: $id, responses: $responses, correlationId: $correlationId) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
    facets {
      type
      value
      range {
        from
        to
      }
      count
      facet
      observable {
        type
        observable {
          id
          name
        }
      }
    }
    graph {
      nodes {
        id
        name
        type
        metadata
      }
      edges {
        from
        to
        relation
      }
    }
    details {
      modelService
      model
      supportsToolCalling
      sourceCount
      observableCount
      toolCount
      renderedSourceCount
      renderedObservableCount
      renderedToolCount
      rankedSourceCount
      rankedObservableCount
      rankedToolCount
      tokenLimit
      completionTokenLimit
      sources
      formattedSources
      formattedObservables
      formattedInstructions
      formattedTools
      specification
      messages {
        role
        author
        message
        citations {
          content {
            id
            name
            state
            originalDate
            identifier
            uri
            type
            fileType
            mimeType
            format
            formatName
            fileExtension
            fileName
            fileSize
            masterUri
            imageUri
            textUri
            audioUri
            transcriptUri
            summary
            customSummary
            keywords
            bullets
            headlines
            posts
            chapters
            questions
            video {
              width
              height
              duration
              make
              model
              software
              title
              description
              keywords
              author
            }
            audio {
              keywords
              author
              series
              episode
              episodeType
              season
              publisher
              copyright
              genre
              title
              description
              bitrate
              channels
              sampleRate
              bitsPerSample
              duration
            }
            image {
              width
              height
              resolutionX
              resolutionY
              bitsPerComponent
              components
              projectionType
              orientation
              description
              make
              model
              software
              lens
              focalLength
              exposureTime
              fNumber
              iso
              heading
              pitch
            }
            document {
              title
              subject
              summary
              author
              publisher
              description
              keywords
              pageCount
              worksheetCount
              slideCount
              wordCount
              lineCount
              paragraphCount
              isEncrypted
              hasDigitalSignature
            }
          }
          index
          text
          startTime
          endTime
          pageNumber
          frameNumber
        }
        toolCalls {
          id
          name
          arguments
        }
        tokens
        throughput
        completionTime
        timestamp
        modelService
        model
        data
        mimeType
        toolCallId
        toolCallResponse
      }
    }
  }
}



================================================
FILE: documents/conversation/CountConversations.graphql
================================================
query CountConversations($filter: ConversationFilter, $correlationId: String) {
  countConversations(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/conversation/CreateConversation.graphql
================================================
mutation CreateConversation($conversation: ConversationInput!, $correlationId: String) {
  createConversation(conversation: $conversation, correlationId: $correlationId) {
    id
    name
    state
    type
  }
}



================================================
FILE: documents/conversation/DeleteAllConversations.graphql
================================================
mutation DeleteAllConversations($filter: ConversationFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllConversations(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/conversation/DeleteConversation.graphql
================================================
mutation DeleteConversation($id: ID!) {
  deleteConversation(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/conversation/DeleteConversations.graphql
================================================
mutation DeleteConversations($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteConversations(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/conversation/FormatConversation.graphql
================================================
mutation FormatConversation($prompt: String!, $id: ID, $specification: EntityReferenceInput, $includeDetails: Boolean, $correlationId: String) {
  formatConversation(prompt: $prompt, id: $id, specification: $specification, includeDetails: $includeDetails, correlationId: $correlationId) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
    facets {
      type
      value
      range {
        from
        to
      }
      count
      facet
      observable {
        type
        observable {
          id
          name
        }
      }
    }
    graph {
      nodes {
        id
        name
        type
        metadata
      }
      edges {
        from
        to
        relation
      }
    }
    details {
      modelService
      model
      supportsToolCalling
      sourceCount
      observableCount
      toolCount
      renderedSourceCount
      renderedObservableCount
      renderedToolCount
      rankedSourceCount
      rankedObservableCount
      rankedToolCount
      tokenLimit
      completionTokenLimit
      sources
      formattedSources
      formattedObservables
      formattedInstructions
      formattedTools
      specification
      messages {
        role
        author
        message
        citations {
          content {
            id
            name
            state
            originalDate
            identifier
            uri
            type
            fileType
            mimeType
            format
            formatName
            fileExtension
            fileName
            fileSize
            masterUri
            imageUri
            textUri
            audioUri
            transcriptUri
            summary
            customSummary
            keywords
            bullets
            headlines
            posts
            chapters
            questions
            video {
              width
              height
              duration
              make
              model
              software
              title
              description
              keywords
              author
            }
            audio {
              keywords
              author
              series
              episode
              episodeType
              season
              publisher
              copyright
              genre
              title
              description
              bitrate
              channels
              sampleRate
              bitsPerSample
              duration
            }
            image {
              width
              height
              resolutionX
              resolutionY
              bitsPerComponent
              components
              projectionType
              orientation
              description
              make
              model
              software
              lens
              focalLength
              exposureTime
              fNumber
              iso
              heading
              pitch
            }
            document {
              title
              subject
              summary
              author
              publisher
              description
              keywords
              pageCount
              worksheetCount
              slideCount
              wordCount
              lineCount
              paragraphCount
              isEncrypted
              hasDigitalSignature
            }
          }
          index
          text
          startTime
          endTime
          pageNumber
          frameNumber
        }
        toolCalls {
          id
          name
          arguments
        }
        tokens
        throughput
        completionTime
        timestamp
        modelService
        model
        data
        mimeType
        toolCallId
        toolCallResponse
      }
    }
  }
}



================================================
FILE: documents/conversation/GetConversation.graphql
================================================
query GetConversation($id: ID!, $correlationId: String) {
  conversation(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    correlationId
    type
    messages {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    specification {
      id
      name
    }
    fallbacks {
      id
      name
    }
    filter {
      dateRange {
        from
        to
      }
      inLast
      creationDateRange {
        from
        to
      }
      createdInLast
      types
      fileTypes
      formats
      fileExtensions
      similarContents {
        id
      }
      contents {
        id
      }
      feeds {
        id
      }
      workflows {
        id
      }
      collections {
        id
      }
      users {
        id
      }
      observations {
        type
        observable {
          id
        }
        states
      }
      or {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
      and {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
    }
    augmentedFilter {
      dateRange {
        from
        to
      }
      inLast
      creationDateRange {
        from
        to
      }
      createdInLast
      types
      fileTypes
      formats
      fileExtensions
      similarContents {
        id
      }
      contents {
        id
      }
      feeds {
        id
      }
      workflows {
        id
      }
      collections {
        id
      }
      users {
        id
      }
      observations {
        type
        observable {
          id
        }
        states
      }
      or {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
      and {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
    }
  }
}



================================================
FILE: documents/conversation/Prompt.graphql
================================================
mutation Prompt($prompt: String, $mimeType: String, $data: String, $specification: EntityReferenceInput, $messages: [ConversationMessageInput!], $correlationId: String) {
  prompt(prompt: $prompt, mimeType: $mimeType, data: $data, specification: $specification, messages: $messages, correlationId: $correlationId) {
    specification {
      id
    }
    messages {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    error
  }
}



================================================
FILE: documents/conversation/PromptConversation.graphql
================================================
mutation PromptConversation($prompt: String!, $mimeType: String, $data: String, $id: ID, $specification: EntityReferenceInput, $tools: [ToolDefinitionInput!], $requireTool: Boolean, $includeDetails: Boolean, $correlationId: String) {
  promptConversation(prompt: $prompt, id: $id, mimeType: $mimeType, data: $data, specification: $specification, tools: $tools, requireTool: $requireTool, includeDetails: $includeDetails, correlationId: $correlationId) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
    facets {
      type
      value
      range {
        from
        to
      }
      count
      facet
      observable {
        type
        observable {
          id
          name
        }
      }
    }
    graph {
      nodes {
        id
        name
        type
        metadata
      }
      edges {
        from
        to
        relation
      }
    }
    details {
      modelService
      model
      supportsToolCalling
      sourceCount
      observableCount
      toolCount
      renderedSourceCount
      renderedObservableCount
      renderedToolCount
      rankedSourceCount
      rankedObservableCount
      rankedToolCount
      tokenLimit
      completionTokenLimit
      sources
      formattedSources
      formattedObservables
      formattedInstructions
      formattedTools
      specification
      messages {
        role
        author
        message
        citations {
          content {
            id
            name
            state
            originalDate
            identifier
            uri
            type
            fileType
            mimeType
            format
            formatName
            fileExtension
            fileName
            fileSize
            masterUri
            imageUri
            textUri
            audioUri
            transcriptUri
            summary
            customSummary
            keywords
            bullets
            headlines
            posts
            chapters
            questions
            video {
              width
              height
              duration
              make
              model
              software
              title
              description
              keywords
              author
            }
            audio {
              keywords
              author
              series
              episode
              episodeType
              season
              publisher
              copyright
              genre
              title
              description
              bitrate
              channels
              sampleRate
              bitsPerSample
              duration
            }
            image {
              width
              height
              resolutionX
              resolutionY
              bitsPerComponent
              components
              projectionType
              orientation
              description
              make
              model
              software
              lens
              focalLength
              exposureTime
              fNumber
              iso
              heading
              pitch
            }
            document {
              title
              subject
              summary
              author
              publisher
              description
              keywords
              pageCount
              worksheetCount
              slideCount
              wordCount
              lineCount
              paragraphCount
              isEncrypted
              hasDigitalSignature
            }
          }
          index
          text
          startTime
          endTime
          pageNumber
          frameNumber
        }
        toolCalls {
          id
          name
          arguments
        }
        tokens
        throughput
        completionTime
        timestamp
        modelService
        model
        data
        mimeType
        toolCallId
        toolCallResponse
      }
    }
  }
}



================================================
FILE: documents/conversation/PublishConversation.graphql
================================================
mutation PublishConversation($id: ID!, $connector: ContentPublishingConnectorInput!, $name: String, $isSynchronous: Boolean, $workflow: EntityReferenceInput, $correlationId: String) {
  publishConversation(id: $id, connector: $connector, name: $name, isSynchronous: $isSynchronous, workflow: $workflow, correlationId: $correlationId) {
    contents {
      id
      name
      state
      originalDate
      identifier
      markdown
      uri
      type
      fileType
      mimeType
      format
      formatName
      fileExtension
      fileName
      fileSize
      masterUri
      imageUri
      textUri
      audioUri
      transcriptUri
      summary
      customSummary
      keywords
      bullets
      headlines
      posts
      chapters
      questions
      video {
        width
        height
        duration
        make
        model
        software
        title
        description
        keywords
        author
      }
      audio {
        keywords
        author
        series
        episode
        episodeType
        season
        publisher
        copyright
        genre
        title
        description
        bitrate
        channels
        sampleRate
        bitsPerSample
        duration
      }
      image {
        width
        height
        resolutionX
        resolutionY
        bitsPerComponent
        components
        projectionType
        orientation
        description
        make
        model
        software
        lens
        focalLength
        exposureTime
        fNumber
        iso
        heading
        pitch
      }
      document {
        title
        subject
        summary
        author
        publisher
        description
        keywords
        pageCount
        worksheetCount
        slideCount
        wordCount
        lineCount
        paragraphCount
        isEncrypted
        hasDigitalSignature
      }
    }
    details {
      contents {
        id
      }
      summaries
      text
      textType
      summarySpecification
      publishSpecification
      summaryTime
      publishTime
    }
  }
}



================================================
FILE: documents/conversation/QueryConversations.graphql
================================================
query QueryConversations($filter: ConversationFilter, $correlationId: String) {
  conversations(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      correlationId
      type
      messages {
        role
        author
        message
        citations {
          content {
            id
            name
            state
            originalDate
            identifier
            uri
            type
            fileType
            mimeType
            format
            formatName
            fileExtension
            fileName
            fileSize
            masterUri
            imageUri
            textUri
            audioUri
            transcriptUri
            summary
            customSummary
            keywords
            bullets
            headlines
            posts
            chapters
            questions
            video {
              width
              height
              duration
              make
              model
              software
              title
              description
              keywords
              author
            }
            audio {
              keywords
              author
              series
              episode
              episodeType
              season
              publisher
              copyright
              genre
              title
              description
              bitrate
              channels
              sampleRate
              bitsPerSample
              duration
            }
            image {
              width
              height
              resolutionX
              resolutionY
              bitsPerComponent
              components
              projectionType
              orientation
              description
              make
              model
              software
              lens
              focalLength
              exposureTime
              fNumber
              iso
              heading
              pitch
            }
            document {
              title
              subject
              summary
              author
              publisher
              description
              keywords
              pageCount
              worksheetCount
              slideCount
              wordCount
              lineCount
              paragraphCount
              isEncrypted
              hasDigitalSignature
            }
          }
          index
          text
          startTime
          endTime
          pageNumber
          frameNumber
        }
        toolCalls {
          id
          name
          arguments
        }
        tokens
        throughput
        completionTime
        timestamp
        modelService
        model
        data
        mimeType
        toolCallId
        toolCallResponse
      }
      specification {
        id
        name
      }
      fallbacks {
        id
        name
      }
      filter {
        dateRange {
          from
          to
        }
        inLast
        creationDateRange {
          from
          to
        }
        createdInLast
        types
        fileTypes
        formats
        fileExtensions
        similarContents {
          id
        }
        contents {
          id
        }
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
        or {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
        and {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
      }
      augmentedFilter {
        dateRange {
          from
          to
        }
        inLast
        creationDateRange {
          from
          to
        }
        createdInLast
        types
        fileTypes
        formats
        fileExtensions
        similarContents {
          id
        }
        contents {
          id
        }
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
        or {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
        and {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
      }
    }
  }
}



================================================
FILE: documents/conversation/RetrieveSources.graphql
================================================
mutation RetrieveSources($prompt: String!, $filter: ContentFilter, $augmentedFilter: ContentFilter, $retrievalStrategy: RetrievalStrategyInput, $rerankingStrategy: RerankingStrategyInput, $correlationId: String) {
  retrieveSources(prompt: $prompt, filter: $filter, augmentedFilter: $augmentedFilter, retrievalStrategy: $retrievalStrategy, rerankingStrategy: $rerankingStrategy, correlationId: $correlationId) {
    results {
      type
      content {
        id
      }
      text
      metadata
      relevance
      startTime
      endTime
      pageNumber
      frameNumber
    }
  }
}



================================================
FILE: documents/conversation/ReviseContent.graphql
================================================
mutation ReviseContent($prompt: String!, $content: EntityReferenceInput!, $id: ID, $specification: EntityReferenceInput, $correlationId: String) {
  reviseContent(prompt: $prompt, content: $content, id: $id, specification: $specification, correlationId: $correlationId) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
  }
}



================================================
FILE: documents/conversation/ReviseEncodedImage.graphql
================================================
mutation ReviseEncodedImage($prompt: String!, $mimeType: String!, $data: String!, $id: ID, $specification: EntityReferenceInput, $correlationId: String) {
  reviseEncodedImage(prompt: $prompt, mimeType: $mimeType, data: $data, id: $id, specification: $specification, correlationId: $correlationId) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
  }
}



================================================
FILE: documents/conversation/ReviseImage.graphql
================================================
mutation ReviseImage($prompt: String!, $uri: URL!, $id: ID, $specification: EntityReferenceInput, $correlationId: String) {
  reviseImage(prompt: $prompt, uri: $uri, id: $id, specification: $specification, correlationId: $correlationId) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
  }
}



================================================
FILE: documents/conversation/ReviseText.graphql
================================================
mutation ReviseText($prompt: String!, $text: String!, $id: ID, $specification: EntityReferenceInput, $correlationId: String) {
  reviseText(prompt: $prompt, text: $text, id: $id, specification: $specification, correlationId: $correlationId) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
  }
}



================================================
FILE: documents/conversation/SuggestConversation.graphql
================================================
mutation SuggestConversation($id: ID!, $count: Int, $prompt: String, $correlationId: String) {
  suggestConversation(id: $id, count: $count, prompt: $prompt, correlationId: $correlationId) {
    prompts
  }
}



================================================
FILE: documents/conversation/UpdateConversation.graphql
================================================
mutation UpdateConversation($conversation: ConversationUpdateInput!) {
  updateConversation(conversation: $conversation) {
    id
    name
    state
    type
  }
}



================================================
FILE: documents/event/CountEvents.graphql
================================================
query CountEvents($filter: EventFilter, $correlationId: String) {
  countEvents(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/event/CreateEvent.graphql
================================================
mutation CreateEvent($event: EventInput!) {
  createEvent(event: $event) {
    id
    name
  }
}



================================================
FILE: documents/event/DeleteAllEvents.graphql
================================================
mutation DeleteAllEvents($filter: EventFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllEvents(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/event/DeleteEvent.graphql
================================================
mutation DeleteEvent($id: ID!) {
  deleteEvent(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/event/DeleteEvents.graphql
================================================
mutation DeleteEvents($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteEvents(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/event/GetEvent.graphql
================================================
query GetEvent($id: ID!, $correlationId: String) {
  event(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
    startDate
    endDate
    availabilityStartDate
    availabilityEndDate
    price
    minPrice
    maxPrice
    priceCurrency
    isAccessibleForFree
    typicalAgeRange
  }
}



================================================
FILE: documents/event/QueryEvents.graphql
================================================
query QueryEvents($filter: EventFilter, $correlationId: String) {
  events(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
      startDate
      endDate
      availabilityStartDate
      availabilityEndDate
      price
      minPrice
      maxPrice
      priceCurrency
      isAccessibleForFree
      typicalAgeRange
    }
  }
}



================================================
FILE: documents/event/UpdateEvent.graphql
================================================
mutation UpdateEvent($event: EventUpdateInput!) {
  updateEvent(event: $event) {
    id
    name
  }
}



================================================
FILE: documents/feed/CountFeeds.graphql
================================================
query CountFeeds($filter: FeedFilter, $correlationId: String) {
  countFeeds(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/feed/CreateFeed.graphql
================================================
mutation CreateFeed($feed: FeedInput!, $correlationId: String) {
  createFeed(feed: $feed, correlationId: $correlationId) {
    id
    name
    state
    type
  }
}



================================================
FILE: documents/feed/DeleteAllFeeds.graphql
================================================
mutation DeleteAllFeeds($filter: FeedFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllFeeds(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/feed/DeleteFeed.graphql
================================================
mutation DeleteFeed($id: ID!) {
  deleteFeed(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/feed/DeleteFeeds.graphql
================================================
mutation DeleteFeeds($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteFeeds(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/feed/DisableFeed.graphql
================================================
mutation DisableFeed($id: ID!) {
  disableFeed(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/feed/EnableFeed.graphql
================================================
mutation EnableFeed($id: ID!) {
  enableFeed(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/feed/FeedExists.graphql
================================================
query FeedExists($filter: FeedFilter, $correlationId: String) {
  feedExists(filter: $filter, correlationId: $correlationId) {
    result
  }
}



================================================
FILE: documents/feed/GetFeed.graphql
================================================
query GetFeed($id: ID!, $correlationId: String) {
  feed(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    correlationId
    type
    site {
      siteType
      type
      isRecursive
      s3 {
        accessKey
        secretAccessKey
        bucketName
        prefix
        region
      }
      azureBlob {
        storageAccessKey
        accountName
        containerName
        prefix
      }
      azureFile {
        storageAccessKey
        accountName
        shareName
        prefix
      }
      google {
        credentials
        containerName
        prefix
      }
      sharePoint {
        authenticationType
        accountName
        libraryId
        folderId
        tenantId
        clientId
        clientSecret
        refreshToken
      }
      oneDrive {
        folderId
        files
        clientId
        clientSecret
        refreshToken
      }
      googleDrive {
        authenticationType
        folderId
        files
        refreshToken
        clientId
        clientSecret
        serviceAccountJson
      }
      dropbox {
        path
        appKey
        appSecret
        refreshToken
        redirectUri
      }
      box {
        folderId
        clientId
        clientSecret
        refreshToken
        redirectUri
      }
      github {
        uri
        repositoryOwner
        repositoryName
        refreshToken
        personalAccessToken
      }
      readLimit
    }
    email {
      type
      includeAttachments
      google {
        type
        includeSpam
        excludeSentItems
        includeDeletedItems
        inboxOnly
        refreshToken
        clientId
        clientSecret
      }
      microsoft {
        type
        includeSpam
        excludeSentItems
        includeDeletedItems
        inboxOnly
        refreshToken
        clientId
        clientSecret
      }
      readLimit
    }
    issue {
      type
      includeAttachments
      jira {
        uri
        project
        email
        token
        offset
      }
      linear {
        key
        project
      }
      github {
        uri
        repositoryOwner
        repositoryName
        refreshToken
        personalAccessToken
      }
      intercom {
        accessToken
      }
      zendesk {
        subdomain
        accessToken
      }
      trello {
        key
        token
        identifiers
        type
      }
      readLimit
    }
    rss {
      readLimit
      uri
    }
    web {
      readLimit
      uri
      includeFiles
      allowedPaths
      excludedPaths
    }
    search {
      readLimit
      type
      text
    }
    reddit {
      readLimit
      subredditName
    }
    notion {
      readLimit
      token
      identifiers
      type
    }
    intercom {
      readLimit
      accessToken
    }
    zendesk {
      readLimit
      subdomain
      accessToken
    }
    youtube {
      readLimit
      type
      videoName
      videoIdentifiers
      channelIdentifier
      playlistIdentifier
    }
    twitter {
      readLimit
      token
      type
      userName
      query
      includeAttachments
    }
    slack {
      readLimit
      type
      token
      channel
      includeAttachments
    }
    microsoftTeams {
      readLimit
      type
      clientId
      clientSecret
      refreshToken
      teamId
      channelId
    }
    discord {
      readLimit
      type
      token
      channel
      includeAttachments
    }
    error
    lastPostDate
    lastReadDate
    readCount
    workflow {
      id
      name
    }
    schedulePolicy {
      recurrenceType
      repeatInterval
    }
  }
}



================================================
FILE: documents/feed/GetSharePointConsentUri.graphql
================================================
query GetSharePointConsentUri($tenantId: ID!) {
  sharePointConsentUri(tenantId: $tenantId) {
    uri
  }
}



================================================
FILE: documents/feed/IsFeedDone.graphql
================================================
query IsFeedDone($id: ID!) {
  isFeedDone(id: $id) {
    result
  }
}



================================================
FILE: documents/feed/QueryFeeds.graphql
================================================
query QueryFeeds($filter: FeedFilter, $correlationId: String) {
  feeds(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      correlationId
      type
      site {
        siteType
        type
        isRecursive
        s3 {
          accessKey
          secretAccessKey
          bucketName
          prefix
          region
        }
        azureBlob {
          storageAccessKey
          accountName
          containerName
          prefix
        }
        azureFile {
          storageAccessKey
          accountName
          shareName
          prefix
        }
        google {
          credentials
          containerName
          prefix
        }
        sharePoint {
          authenticationType
          accountName
          libraryId
          folderId
          tenantId
          clientId
          clientSecret
          refreshToken
        }
        oneDrive {
          folderId
          files
          clientId
          clientSecret
          refreshToken
        }
        googleDrive {
          authenticationType
          folderId
          files
          refreshToken
          clientId
          clientSecret
          serviceAccountJson
        }
        dropbox {
          path
          appKey
          appSecret
          refreshToken
          redirectUri
        }
        box {
          folderId
          clientId
          clientSecret
          refreshToken
          redirectUri
        }
        github {
          uri
          repositoryOwner
          repositoryName
          refreshToken
          personalAccessToken
        }
        readLimit
      }
      email {
        type
        includeAttachments
        google {
          type
          includeSpam
          excludeSentItems
          includeDeletedItems
          inboxOnly
          refreshToken
          clientId
          clientSecret
        }
        microsoft {
          type
          includeSpam
          excludeSentItems
          includeDeletedItems
          inboxOnly
          refreshToken
          clientId
          clientSecret
        }
        readLimit
      }
      issue {
        type
        includeAttachments
        jira {
          uri
          project
          email
          token
          offset
        }
        linear {
          key
          project
        }
        github {
          uri
          repositoryOwner
          repositoryName
          refreshToken
          personalAccessToken
        }
        intercom {
          accessToken
        }
        zendesk {
          subdomain
          accessToken
        }
        trello {
          key
          token
          identifiers
          type
        }
        readLimit
      }
      rss {
        readLimit
        uri
      }
      web {
        readLimit
        uri
        includeFiles
        allowedPaths
        excludedPaths
      }
      search {
        readLimit
        type
        text
      }
      reddit {
        readLimit
        subredditName
      }
      notion {
        readLimit
        token
        identifiers
        type
      }
      intercom {
        readLimit
        accessToken
      }
      zendesk {
        readLimit
        subdomain
        accessToken
      }
      youtube {
        readLimit
        type
        videoName
        videoIdentifiers
        channelIdentifier
        playlistIdentifier
      }
      twitter {
        readLimit
        token
        type
        userName
        query
        includeAttachments
      }
      slack {
        readLimit
        type
        token
        channel
        includeAttachments
      }
      microsoftTeams {
        readLimit
        type
        clientId
        clientSecret
        refreshToken
        teamId
        channelId
      }
      discord {
        readLimit
        type
        token
        channel
        includeAttachments
      }
      error
      lastPostDate
      lastReadDate
      readCount
      workflow {
        id
        name
      }
      schedulePolicy {
        recurrenceType
        repeatInterval
      }
    }
  }
}



================================================
FILE: documents/feed/QueryLinearProjects.graphql
================================================
query QueryLinearProjects($properties: LinearProjectsInput!) {
  linearProjects(properties: $properties) {
    results
  }
}



================================================
FILE: documents/feed/QueryMicrosoftTeamsChannels.graphql
================================================
query QueryMicrosoftTeamsChannels($properties: MicrosoftTeamsChannelsInput!, $teamId: ID!) {
  microsoftTeamsChannels(properties: $properties, teamId: $teamId) {
    results {
      channelName
      channelId
    }
  }
}



================================================
FILE: documents/feed/QueryMicrosoftTeamsTeams.graphql
================================================
query QueryMicrosoftTeamsTeams($properties: MicrosoftTeamsTeamsInput!) {
  microsoftTeamsTeams(properties: $properties) {
    results {
      teamName
      teamId
    }
  }
}



================================================
FILE: documents/feed/QueryNotionDatabases.graphql
================================================
query QueryNotionDatabases($properties: NotionDatabasesInput!) {
  notionDatabases(properties: $properties) {
    results
  }
}



================================================
FILE: documents/feed/QueryNotionPages.graphql
================================================
query QueryNotionPages($properties: NotionPagesInput!, $identifier: String!) {
  notionPages(properties: $properties, identifier: $identifier) {
    results
  }
}



================================================
FILE: documents/feed/QueryOneDriveFolders.graphql
================================================
query QueryOneDriveFolders($properties: OneDriveFoldersInput!, $folderId: ID) {
  oneDriveFolders(properties: $properties, folderId: $folderId) {
    results {
      folderName
      folderId
    }
  }
}



================================================
FILE: documents/feed/QuerySharePointFolders.graphql
================================================
query QuerySharePointFolders($properties: SharePointFoldersInput!, $libraryId: ID!, $folderId: ID) {
  sharePointFolders(properties: $properties, libraryId: $libraryId, folderId: $folderId) {
    accountName
    results {
      folderName
      folderId
    }
  }
}



================================================
FILE: documents/feed/QuerySharePointLibraries.graphql
================================================
query QuerySharePointLibraries($properties: SharePointLibrariesInput!) {
  sharePointLibraries(properties: $properties) {
    accountName
    results {
      libraryName
      libraryId
      siteName
      siteId
    }
  }
}



================================================
FILE: documents/feed/QuerySlackChannels.graphql
================================================
query QuerySlackChannels($properties: SlackChannelsInput!) {
  slackChannels(properties: $properties) {
    results
  }
}



================================================
FILE: documents/feed/UpdateFeed.graphql
================================================
mutation UpdateFeed($feed: FeedUpdateInput!) {
  updateFeed(feed: $feed) {
    id
    name
    state
    type
  }
}



================================================
FILE: documents/label/CountLabels.graphql
================================================
query CountLabels($filter: LabelFilter, $correlationId: String) {
  countLabels(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/label/CreateLabel.graphql
================================================
mutation CreateLabel($label: LabelInput!) {
  createLabel(label: $label) {
    id
    name
  }
}



================================================
FILE: documents/label/DeleteAllLabels.graphql
================================================
mutation DeleteAllLabels($filter: LabelFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllLabels(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/label/DeleteLabel.graphql
================================================
mutation DeleteLabel($id: ID!) {
  deleteLabel(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/label/DeleteLabels.graphql
================================================
mutation DeleteLabels($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteLabels(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/label/GetLabel.graphql
================================================
query GetLabel($id: ID!, $correlationId: String) {
  label(id: $id, correlationId: $correlationId) {
    id
    name
    description
    creationDate
    relevance
  }
}



================================================
FILE: documents/label/QueryLabels.graphql
================================================
query QueryLabels($filter: LabelFilter, $correlationId: String) {
  labels(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      description
      creationDate
      relevance
    }
  }
}



================================================
FILE: documents/label/UpdateLabel.graphql
================================================
mutation UpdateLabel($label: LabelUpdateInput!) {
  updateLabel(label: $label) {
    id
    name
  }
}



================================================
FILE: documents/label/UpsertLabel.graphql
================================================
mutation UpsertLabel($label: LabelInput!) {
  upsertLabel(label: $label) {
    id
    name
  }
}



================================================
FILE: documents/medicalCondition/CountMedicalConditions.graphql
================================================
query CountMedicalConditions($filter: MedicalConditionFilter, $correlationId: String) {
  countMedicalConditions(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/medicalCondition/CreateMedicalCondition.graphql
================================================
mutation CreateMedicalCondition($medicalCondition: MedicalConditionInput!) {
  createMedicalCondition(medicalCondition: $medicalCondition) {
    id
    name
  }
}



================================================
FILE: documents/medicalCondition/DeleteAllMedicalConditions.graphql
================================================
mutation DeleteAllMedicalConditions($filter: MedicalConditionFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalConditions(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalCondition/DeleteMedicalCondition.graphql
================================================
mutation DeleteMedicalCondition($id: ID!) {
  deleteMedicalCondition(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalCondition/DeleteMedicalConditions.graphql
================================================
mutation DeleteMedicalConditions($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalConditions(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalCondition/GetMedicalCondition.graphql
================================================
query GetMedicalCondition($id: ID!, $correlationId: String) {
  medicalCondition(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/medicalCondition/QueryMedicalConditions.graphql
================================================
query QueryMedicalConditions($filter: MedicalConditionFilter, $correlationId: String) {
  medicalConditions(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/medicalCondition/UpdateMedicalCondition.graphql
================================================
mutation UpdateMedicalCondition($medicalCondition: MedicalConditionUpdateInput!) {
  updateMedicalCondition(medicalCondition: $medicalCondition) {
    id
    name
  }
}



================================================
FILE: documents/medicalContraindication/CountMedicalContraindications.graphql
================================================
query CountMedicalContraindications($filter: MedicalContraindicationFilter, $correlationId: String) {
  countMedicalContraindications(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/medicalContraindication/CreateMedicalContraindication.graphql
================================================
mutation CreateMedicalContraindication($medicalContraindication: MedicalContraindicationInput!) {
  createMedicalContraindication(medicalContraindication: $medicalContraindication) {
    id
    name
  }
}



================================================
FILE: documents/medicalContraindication/DeleteAllMedicalContraindications.graphql
================================================
mutation DeleteAllMedicalContraindications($filter: MedicalContraindicationFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalContraindications(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalContraindication/DeleteMedicalContraindication.graphql
================================================
mutation DeleteMedicalContraindication($id: ID!) {
  deleteMedicalContraindication(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalContraindication/DeleteMedicalContraindications.graphql
================================================
mutation DeleteMedicalContraindications($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalContraindications(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalContraindication/GetMedicalContraindication.graphql
================================================
query GetMedicalContraindication($id: ID!, $correlationId: String) {
  medicalContraindication(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/medicalContraindication/QueryMedicalContraindications.graphql
================================================
query QueryMedicalContraindications($filter: MedicalContraindicationFilter, $correlationId: String) {
  medicalContraindications(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/medicalContraindication/UpdateMedicalContraindication.graphql
================================================
mutation UpdateMedicalContraindication($medicalContraindication: MedicalContraindicationUpdateInput!) {
  updateMedicalContraindication(medicalContraindication: $medicalContraindication) {
    id
    name
  }
}



================================================
FILE: documents/medicalDevice/CountMedicalDevices.graphql
================================================
query CountMedicalDevices($filter: MedicalDeviceFilter, $correlationId: String) {
  countMedicalDevices(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/medicalDevice/CreateMedicalDevice.graphql
================================================
mutation CreateMedicalDevice($medicalDevice: MedicalDeviceInput!) {
  createMedicalDevice(medicalDevice: $medicalDevice) {
    id
    name
  }
}



================================================
FILE: documents/medicalDevice/DeleteAllMedicalDevices.graphql
================================================
mutation DeleteAllMedicalDevices($filter: MedicalDeviceFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalDevices(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalDevice/DeleteMedicalDevice.graphql
================================================
mutation DeleteMedicalDevice($id: ID!) {
  deleteMedicalDevice(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalDevice/DeleteMedicalDevices.graphql
================================================
mutation DeleteMedicalDevices($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalDevices(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalDevice/GetMedicalDevice.graphql
================================================
query GetMedicalDevice($id: ID!, $correlationId: String) {
  medicalDevice(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/medicalDevice/QueryMedicalDevices.graphql
================================================
query QueryMedicalDevices($filter: MedicalDeviceFilter, $correlationId: String) {
  medicalDevices(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/medicalDevice/UpdateMedicalDevice.graphql
================================================
mutation UpdateMedicalDevice($medicalDevice: MedicalDeviceUpdateInput!) {
  updateMedicalDevice(medicalDevice: $medicalDevice) {
    id
    name
  }
}



================================================
FILE: documents/medicalDrug/CountMedicalDrugs.graphql
================================================
query CountMedicalDrugs($filter: MedicalDrugFilter, $correlationId: String) {
  countMedicalDrugs(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/medicalDrug/CreateMedicalDrug.graphql
================================================
mutation CreateMedicalDrug($medicalDrug: MedicalDrugInput!) {
  createMedicalDrug(medicalDrug: $medicalDrug) {
    id
    name
  }
}



================================================
FILE: documents/medicalDrug/DeleteAllMedicalDrugs.graphql
================================================
mutation DeleteAllMedicalDrugs($filter: MedicalDrugFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalDrugs(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalDrug/DeleteMedicalDrug.graphql
================================================
mutation DeleteMedicalDrug($id: ID!) {
  deleteMedicalDrug(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalDrug/DeleteMedicalDrugs.graphql
================================================
mutation DeleteMedicalDrugs($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalDrugs(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalDrug/GetMedicalDrug.graphql
================================================
query GetMedicalDrug($id: ID!, $correlationId: String) {
  medicalDrug(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/medicalDrug/QueryMedicalDrugs.graphql
================================================
query QueryMedicalDrugs($filter: MedicalDrugFilter, $correlationId: String) {
  medicalDrugs(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/medicalDrug/UpdateMedicalDrug.graphql
================================================
mutation UpdateMedicalDrug($medicalDrug: MedicalDrugUpdateInput!) {
  updateMedicalDrug(medicalDrug: $medicalDrug) {
    id
    name
  }
}



================================================
FILE: documents/medicalDrugClass/CountMedicalDrugClasses.graphql
================================================
query CountMedicalDrugClasses($filter: MedicalDrugClassFilter, $correlationId: String) {
  countMedicalDrugClasses(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/medicalDrugClass/CreateMedicalDrugClass.graphql
================================================
mutation CreateMedicalDrugClass($medicalDrugClass: MedicalDrugClassInput!) {
  createMedicalDrugClass(medicalDrugClass: $medicalDrugClass) {
    id
    name
  }
}



================================================
FILE: documents/medicalDrugClass/DeleteAllMedicalDrugClasses.graphql
================================================
mutation DeleteAllMedicalDrugClasses($filter: MedicalDrugClassFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalDrugClasses(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalDrugClass/DeleteMedicalDrugClass.graphql
================================================
mutation DeleteMedicalDrugClass($id: ID!) {
  deleteMedicalDrugClass(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalDrugClass/DeleteMedicalDrugClasses.graphql
================================================
mutation DeleteMedicalDrugClasses($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalDrugClasses(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalDrugClass/GetMedicalDrugClass.graphql
================================================
query GetMedicalDrugClass($id: ID!, $correlationId: String) {
  medicalDrugClass(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/medicalDrugClass/QueryMedicalDrugClasses.graphql
================================================
query QueryMedicalDrugClasses($filter: MedicalDrugClassFilter, $correlationId: String) {
  medicalDrugClasses(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/medicalDrugClass/UpdateMedicalDrugClass.graphql
================================================
mutation UpdateMedicalDrugClass($medicalDrugClass: MedicalDrugClassUpdateInput!) {
  updateMedicalDrugClass(medicalDrugClass: $medicalDrugClass) {
    id
    name
  }
}



================================================
FILE: documents/medicalGuideline/CountMedicalGuidelines.graphql
================================================
query CountMedicalGuidelines($filter: MedicalGuidelineFilter, $correlationId: String) {
  countMedicalGuidelines(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/medicalGuideline/CreateMedicalGuideline.graphql
================================================
mutation CreateMedicalGuideline($medicalGuideline: MedicalGuidelineInput!) {
  createMedicalGuideline(medicalGuideline: $medicalGuideline) {
    id
    name
  }
}



================================================
FILE: documents/medicalGuideline/DeleteAllMedicalGuidelines.graphql
================================================
mutation DeleteAllMedicalGuidelines($filter: MedicalGuidelineFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalGuidelines(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalGuideline/DeleteMedicalGuideline.graphql
================================================
mutation DeleteMedicalGuideline($id: ID!) {
  deleteMedicalGuideline(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalGuideline/DeleteMedicalGuidelines.graphql
================================================
mutation DeleteMedicalGuidelines($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalGuidelines(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalGuideline/GetMedicalGuideline.graphql
================================================
query GetMedicalGuideline($id: ID!, $correlationId: String) {
  medicalGuideline(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/medicalGuideline/QueryMedicalGuidelines.graphql
================================================
query QueryMedicalGuidelines($filter: MedicalGuidelineFilter, $correlationId: String) {
  medicalGuidelines(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/medicalGuideline/UpdateMedicalGuideline.graphql
================================================
mutation UpdateMedicalGuideline($medicalGuideline: MedicalGuidelineUpdateInput!) {
  updateMedicalGuideline(medicalGuideline: $medicalGuideline) {
    id
    name
  }
}



================================================
FILE: documents/medicalIndication/CountMedicalIndications.graphql
================================================
query CountMedicalIndications($filter: MedicalIndicationFilter, $correlationId: String) {
  countMedicalIndications(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/medicalIndication/CreateMedicalIndication.graphql
================================================
mutation CreateMedicalIndication($medicalIndication: MedicalIndicationInput!) {
  createMedicalIndication(medicalIndication: $medicalIndication) {
    id
    name
  }
}



================================================
FILE: documents/medicalIndication/DeleteAllMedicalIndications.graphql
================================================
mutation DeleteAllMedicalIndications($filter: MedicalIndicationFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalIndications(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalIndication/DeleteMedicalIndication.graphql
================================================
mutation DeleteMedicalIndication($id: ID!) {
  deleteMedicalIndication(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalIndication/DeleteMedicalIndications.graphql
================================================
mutation DeleteMedicalIndications($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalIndications(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalIndication/GetMedicalIndication.graphql
================================================
query GetMedicalIndication($id: ID!, $correlationId: String) {
  medicalIndication(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/medicalIndication/QueryMedicalIndications.graphql
================================================
query QueryMedicalIndications($filter: MedicalIndicationFilter, $correlationId: String) {
  medicalIndications(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/medicalIndication/UpdateMedicalIndication.graphql
================================================
mutation UpdateMedicalIndication($medicalIndication: MedicalIndicationUpdateInput!) {
  updateMedicalIndication(medicalIndication: $medicalIndication) {
    id
    name
  }
}



================================================
FILE: documents/medicalProcedure/CountMedicalProcedures.graphql
================================================
query CountMedicalProcedures($filter: MedicalProcedureFilter, $correlationId: String) {
  countMedicalProcedures(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/medicalProcedure/CreateMedicalProcedure.graphql
================================================
mutation CreateMedicalProcedure($medicalProcedure: MedicalProcedureInput!) {
  createMedicalProcedure(medicalProcedure: $medicalProcedure) {
    id
    name
  }
}



================================================
FILE: documents/medicalProcedure/DeleteAllMedicalProcedures.graphql
================================================
mutation DeleteAllMedicalProcedures($filter: MedicalProcedureFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalProcedures(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalProcedure/DeleteMedicalProcedure.graphql
================================================
mutation DeleteMedicalProcedure($id: ID!) {
  deleteMedicalProcedure(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalProcedure/DeleteMedicalProcedures.graphql
================================================
mutation DeleteMedicalProcedures($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalProcedures(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalProcedure/GetMedicalProcedure.graphql
================================================
query GetMedicalProcedure($id: ID!, $correlationId: String) {
  medicalProcedure(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/medicalProcedure/QueryMedicalProcedures.graphql
================================================
query QueryMedicalProcedures($filter: MedicalProcedureFilter, $correlationId: String) {
  medicalProcedures(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/medicalProcedure/UpdateMedicalProcedure.graphql
================================================
mutation UpdateMedicalProcedure($medicalProcedure: MedicalProcedureUpdateInput!) {
  updateMedicalProcedure(medicalProcedure: $medicalProcedure) {
    id
    name
  }
}



================================================
FILE: documents/medicalStudy/CountMedicalStudies.graphql
================================================
query CountMedicalStudies($filter: MedicalStudyFilter) {
  countMedicalStudies(filter: $filter) {
    count
  }
}



================================================
FILE: documents/medicalStudy/CreateMedicalStudy.graphql
================================================
mutation CreateMedicalStudy($medicalStudy: MedicalStudyInput!) {
  createMedicalStudy(medicalStudy: $medicalStudy) {
    id
    name
  }
}



================================================
FILE: documents/medicalStudy/DeleteAllMedicalStudies.graphql
================================================
mutation DeleteAllMedicalStudies($filter: MedicalStudyFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalStudies(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalStudy/DeleteMedicalStudies.graphql
================================================
mutation DeleteMedicalStudies($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalStudies(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalStudy/DeleteMedicalStudy.graphql
================================================
mutation DeleteMedicalStudy($id: ID!) {
  deleteMedicalStudy(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalStudy/GetMedicalStudy.graphql
================================================
query GetMedicalStudy($id: ID!, $correlationId: String) {
  medicalStudy(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
  }
}



================================================
FILE: documents/medicalStudy/QueryMedicalStudies.graphql
================================================
query QueryMedicalStudies($filter: MedicalStudyFilter, $correlationId: String) {
  medicalStudies(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
    }
  }
}



================================================
FILE: documents/medicalStudy/UpdateMedicalStudy.graphql
================================================
mutation UpdateMedicalStudy($medicalStudy: MedicalStudyUpdateInput!) {
  updateMedicalStudy(medicalStudy: $medicalStudy) {
    id
    name
  }
}



================================================
FILE: documents/medicalTest/CountMedicalTests.graphql
================================================
query CountMedicalTests($filter: MedicalTestFilter, $correlationId: String) {
  countMedicalTests(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/medicalTest/CreateMedicalTest.graphql
================================================
mutation CreateMedicalTest($medicalTest: MedicalTestInput!) {
  createMedicalTest(medicalTest: $medicalTest) {
    id
    name
  }
}



================================================
FILE: documents/medicalTest/DeleteAllMedicalTests.graphql
================================================
mutation DeleteAllMedicalTests($filter: MedicalTestFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalTests(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalTest/DeleteMedicalTest.graphql
================================================
mutation DeleteMedicalTest($id: ID!) {
  deleteMedicalTest(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalTest/DeleteMedicalTests.graphql
================================================
mutation DeleteMedicalTests($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalTests(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalTest/GetMedicalTest.graphql
================================================
query GetMedicalTest($id: ID!, $correlationId: String) {
  medicalTest(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/medicalTest/QueryMedicalTests.graphql
================================================
query QueryMedicalTests($filter: MedicalTestFilter, $correlationId: String) {
  medicalTests(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/medicalTest/UpdateMedicalTest.graphql
================================================
mutation UpdateMedicalTest($medicalTest: MedicalTestUpdateInput!) {
  updateMedicalTest(medicalTest: $medicalTest) {
    id
    name
  }
}



================================================
FILE: documents/medicalTherapy/CountMedicalTherapies.graphql
================================================
query CountMedicalTherapies($filter: MedicalTherapyFilter, $correlationId: String) {
  countMedicalTherapies(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/medicalTherapy/CreateMedicalTherapy.graphql
================================================
mutation CreateMedicalTherapy($medicalTherapy: MedicalTherapyInput!) {
  createMedicalTherapy(medicalTherapy: $medicalTherapy) {
    id
    name
  }
}



================================================
FILE: documents/medicalTherapy/DeleteAllMedicalTherapies.graphql
================================================
mutation DeleteAllMedicalTherapies($filter: MedicalTherapyFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalTherapies(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/medicalTherapy/DeleteMedicalTherapies.graphql
================================================
mutation DeleteMedicalTherapies($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalTherapies(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/medicalTherapy/DeleteMedicalTherapy.graphql
================================================
mutation DeleteMedicalTherapy($id: ID!) {
  deleteMedicalTherapy(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/medicalTherapy/GetMedicalTherapy.graphql
================================================
query GetMedicalTherapy($id: ID!, $correlationId: String) {
  medicalTherapy(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/medicalTherapy/QueryMedicalTherapies.graphql
================================================
query QueryMedicalTherapies($filter: MedicalTherapyFilter, $correlationId: String) {
  medicalTherapies(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/medicalTherapy/UpdateMedicalTherapy.graphql
================================================
mutation UpdateMedicalTherapy($medicalTherapy: MedicalTherapyUpdateInput!) {
  updateMedicalTherapy(medicalTherapy: $medicalTherapy) {
    id
    name
  }
}



================================================
FILE: documents/notification/SendNotification.graphql
================================================
mutation SendNotification($connector: IntegrationConnectorInput!, $text: String!, $textType: TextTypes) {
  sendNotification(connector: $connector, text: $text, textType: $textType) {
    result
  }
}



================================================
FILE: documents/observation/CreateObservation.graphql
================================================
mutation CreateObservation($observation: ObservationInput!) {
  createObservation(observation: $observation) {
    id
    state
  }
}



================================================
FILE: documents/observation/DeleteObservation.graphql
================================================
mutation DeleteObservation($id: ID!) {
  deleteObservation(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/observation/UpdateObservation.graphql
================================================
mutation UpdateObservation($observation: ObservationUpdateInput!) {
  updateObservation(observation: $observation) {
    id
    state
  }
}



================================================
FILE: documents/organization/CountOrganizations.graphql
================================================
query CountOrganizations($filter: OrganizationFilter, $correlationId: String) {
  countOrganizations(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/organization/CreateOrganization.graphql
================================================
mutation CreateOrganization($organization: OrganizationInput!) {
  createOrganization(organization: $organization) {
    id
    name
  }
}



================================================
FILE: documents/organization/DeleteAllOrganizations.graphql
================================================
mutation DeleteAllOrganizations($filter: OrganizationFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllOrganizations(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/organization/DeleteOrganization.graphql
================================================
mutation DeleteOrganization($id: ID!) {
  deleteOrganization(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/organization/DeleteOrganizations.graphql
================================================
mutation DeleteOrganizations($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteOrganizations(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/organization/GetOrganization.graphql
================================================
query GetOrganization($id: ID!, $correlationId: String) {
  organization(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
    foundingDate
    industries
    revenue
    revenueCurrency
    investment
    investmentCurrency
  }
}



================================================
FILE: documents/organization/QueryOrganizations.graphql
================================================
query QueryOrganizations($filter: OrganizationFilter, $correlationId: String) {
  organizations(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
      foundingDate
      industries
      revenue
      revenueCurrency
      investment
      investmentCurrency
    }
  }
}



================================================
FILE: documents/organization/UpdateOrganization.graphql
================================================
mutation UpdateOrganization($organization: OrganizationUpdateInput!) {
  updateOrganization(organization: $organization) {
    id
    name
  }
}



================================================
FILE: documents/person/CountPersons.graphql
================================================
query CountPersons($filter: PersonFilter, $correlationId: String) {
  countPersons(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/person/CreatePerson.graphql
================================================
mutation CreatePerson($person: PersonInput!) {
  createPerson(person: $person) {
    id
    name
  }
}



================================================
FILE: documents/person/DeleteAllPersons.graphql
================================================
mutation DeleteAllPersons($filter: PersonFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllPersons(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/person/DeletePerson.graphql
================================================
mutation DeletePerson($id: ID!) {
  deletePerson(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/person/DeletePersons.graphql
================================================
mutation DeletePersons($ids: [ID!]!, $isSynchronous: Boolean) {
  deletePersons(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/person/GetPerson.graphql
================================================
query GetPerson($id: ID!, $correlationId: String) {
  person(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
    email
    givenName
    familyName
    phoneNumber
    birthDate
    title
    occupation
    education
  }
}



================================================
FILE: documents/person/QueryPersons.graphql
================================================
query QueryPersons($filter: PersonFilter, $correlationId: String) {
  persons(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
      email
      givenName
      familyName
      phoneNumber
      birthDate
      title
      occupation
      education
    }
  }
}



================================================
FILE: documents/person/UpdatePerson.graphql
================================================
mutation UpdatePerson($person: PersonUpdateInput!) {
  updatePerson(person: $person) {
    id
    name
  }
}



================================================
FILE: documents/place/CountPlaces.graphql
================================================
query CountPlaces($filter: PlaceFilter, $correlationId: String) {
  countPlaces(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/place/CreatePlace.graphql
================================================
mutation CreatePlace($place: PlaceInput!) {
  createPlace(place: $place) {
    id
    name
  }
}



================================================
FILE: documents/place/DeleteAllPlaces.graphql
================================================
mutation DeleteAllPlaces($filter: PlaceFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllPlaces(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/place/DeletePlace.graphql
================================================
mutation DeletePlace($id: ID!) {
  deletePlace(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/place/DeletePlaces.graphql
================================================
mutation DeletePlaces($ids: [ID!]!, $isSynchronous: Boolean) {
  deletePlaces(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/place/GetPlace.graphql
================================================
query GetPlace($id: ID!, $correlationId: String) {
  place(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
  }
}



================================================
FILE: documents/place/QueryPlaces.graphql
================================================
query QueryPlaces($filter: PlaceFilter, $correlationId: String) {
  places(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
    }
  }
}



================================================
FILE: documents/place/UpdatePlace.graphql
================================================
mutation UpdatePlace($place: PlaceUpdateInput!) {
  updatePlace(place: $place) {
    id
    name
  }
}



================================================
FILE: documents/product/CountProducts.graphql
================================================
query CountProducts($filter: ProductFilter, $correlationId: String) {
  countProducts(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/product/CreateProduct.graphql
================================================
mutation CreateProduct($product: ProductInput!) {
  createProduct(product: $product) {
    id
    name
  }
}



================================================
FILE: documents/product/DeleteAllProducts.graphql
================================================
mutation DeleteAllProducts($filter: ProductFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllProducts(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/product/DeleteProduct.graphql
================================================
mutation DeleteProduct($id: ID!) {
  deleteProduct(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/product/DeleteProducts.graphql
================================================
mutation DeleteProducts($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteProducts(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/product/GetProduct.graphql
================================================
query GetProduct($id: ID!, $correlationId: String) {
  product(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
    manufacturer
    model
    brand
    upc
    sku
    releaseDate
    productionDate
  }
}



================================================
FILE: documents/product/QueryProducts.graphql
================================================
query QueryProducts($filter: ProductFilter, $correlationId: String) {
  products(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
      manufacturer
      model
      brand
      upc
      sku
      releaseDate
      productionDate
    }
  }
}



================================================
FILE: documents/product/UpdateProduct.graphql
================================================
mutation UpdateProduct($product: ProductUpdateInput!) {
  updateProduct(product: $product) {
    id
    name
  }
}



================================================
FILE: documents/project/GetProject.graphql
================================================
query GetProject {
  project {
    id
    name
    creationDate
    modifiedDate
    state
    environmentType
    platform
    region
    credits
    lastCreditsDate
    workflow {
      id
      name
    }
    specification {
      id
      name
    }
    embeddings {
      textSpecification {
        id
      }
      imageSpecification {
        id
      }
    }
    quota {
      storage
      contents
      credits
      feeds
      posts
      conversations
    }
    callbackUri
  }
}



================================================
FILE: documents/project/LookupCredits.graphql
================================================
query LookupCredits($correlationId: String!) {
  lookupCredits(correlationId: $correlationId) {
    correlationId
    ownerId
    credits
    storageRatio
    computeRatio
    embeddingRatio
    completionRatio
    generationRatio
    ingestionRatio
    indexingRatio
    preparationRatio
    extractionRatio
    classificationRatio
    enrichmentRatio
    publishingRatio
    searchRatio
    conversationRatio
  }
}



================================================
FILE: documents/project/LookupUsage.graphql
================================================
query LookupUsage($correlationId: String!) {
  lookupUsage(correlationId: $correlationId) {
    id
    correlationId
    date
    credits
    name
    metric
    workflow
    entityType
    entityId
    projectId
    ownerId
    uri
    duration
    throughput
    contentType
    fileType
    modelService
    modelName
    processorName
    prompt
    promptTokens
    completion
    completionTokens
    tokens
    count
    operation
    operationType
    request
    variables
    response
  }
}



================================================
FILE: documents/project/QueryCredits.graphql
================================================
query QueryCredits($startDate: DateTime!, $duration: TimeSpan!) {
  credits(startDate: $startDate, duration: $duration) {
    correlationId
    ownerId
    credits
    storageRatio
    computeRatio
    embeddingRatio
    completionRatio
    generationRatio
    ingestionRatio
    indexingRatio
    preparationRatio
    extractionRatio
    classificationRatio
    enrichmentRatio
    publishingRatio
    searchRatio
    conversationRatio
  }
}



================================================
FILE: documents/project/QueryTokens.graphql
================================================
query QueryTokens($startDate: DateTime!, $duration: TimeSpan!) {
  tokens(startDate: $startDate, duration: $duration) {
    correlationId
    ownerId
    embeddingInputTokens
    embeddingModelServices
    completionInputTokens
    completionOutputTokens
    completionModelServices
    preparationInputTokens
    preparationOutputTokens
    preparationModelServices
    extractionInputTokens
    extractionOutputTokens
    extractionModelServices
    generationInputTokens
    generationOutputTokens
    generationModelServices
  }
}



================================================
FILE: documents/project/QueryUsage.graphql
================================================
query QueryUsage($startDate: DateTime!, $duration: TimeSpan!, $names: [String!], $excludedNames: [String!], $offset: Int, $limit: Int) {
  usage(startDate: $startDate, duration: $duration, names: $names, excludedNames: $excludedNames, offset: $offset, limit: $limit) {
    id
    correlationId
    date
    credits
    name
    metric
    workflow
    entityType
    entityId
    projectId
    ownerId
    uri
    duration
    throughput
    contentType
    fileType
    modelService
    modelName
    processorName
    prompt
    promptTokens
    completion
    completionTokens
    tokens
    count
    operation
    operationType
    request
    variables
    response
  }
}



================================================
FILE: documents/project/UpdateProject.graphql
================================================
mutation UpdateProject($project: ProjectUpdateInput!) {
  updateProject(project: $project) {
    id
    name
  }
}



================================================
FILE: documents/repo/CountRepos.graphql
================================================
query CountRepos($filter: RepoFilter, $correlationId: String) {
  countRepos(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/repo/CreateRepo.graphql
================================================
mutation CreateRepo($repo: RepoInput!) {
  createRepo(repo: $repo) {
    id
    name
  }
}



================================================
FILE: documents/repo/DeleteAllRepos.graphql
================================================
mutation DeleteAllRepos($filter: RepoFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllRepos(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/repo/DeleteRepo.graphql
================================================
mutation DeleteRepo($id: ID!) {
  deleteRepo(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/repo/DeleteRepos.graphql
================================================
mutation DeleteRepos($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteRepos(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/repo/GetRepo.graphql
================================================
query GetRepo($id: ID!, $correlationId: String) {
  repo(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}



================================================
FILE: documents/repo/QueryRepos.graphql
================================================
query QueryRepos($filter: RepoFilter, $correlationId: String) {
  repos(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}



================================================
FILE: documents/repo/UpdateRepo.graphql
================================================
mutation UpdateRepo($repo: RepoUpdateInput!) {
  updateRepo(repo: $repo) {
    id
    name
  }
}



================================================
FILE: documents/search/MapWeb.graphql
================================================
query MapWeb($uri: URL!, $allowedPaths: [String!], $excludedPaths: [String!], $correlationId: String) {
  mapWeb(uri: $uri, allowedPaths: $allowedPaths, excludedPaths: $excludedPaths, correlationId: $correlationId) {
    results
  }
}



================================================
FILE: documents/search/SearchWeb.graphql
================================================
query SearchWeb($text: String!, $service: SearchServiceTypes, $limit: Int, $correlationId: String) {
  searchWeb(text: $text, service: $service, limit: $limit, correlationId: $correlationId) {
    results {
      uri
      text
      title
      score
    }
  }
}



================================================
FILE: documents/software/CountSoftwares.graphql
================================================
query CountSoftwares($filter: SoftwareFilter, $correlationId: String) {
  countSoftwares(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/software/CreateSoftware.graphql
================================================
mutation CreateSoftware($software: SoftwareInput!) {
  createSoftware(software: $software) {
    id
    name
  }
}



================================================
FILE: documents/software/DeleteAllSoftwares.graphql
================================================
mutation DeleteAllSoftwares($filter: SoftwareFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllSoftwares(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/software/DeleteSoftware.graphql
================================================
mutation DeleteSoftware($id: ID!) {
  deleteSoftware(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/software/DeleteSoftwares.graphql
================================================
mutation DeleteSoftwares($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteSoftwares(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/software/GetSoftware.graphql
================================================
query GetSoftware($id: ID!, $correlationId: String) {
  software(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    releaseDate
    developer
  }
}



================================================
FILE: documents/software/QuerySoftwares.graphql
================================================
query QuerySoftwares($filter: SoftwareFilter, $correlationId: String) {
  softwares(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      releaseDate
      developer
    }
  }
}



================================================
FILE: documents/software/UpdateSoftware.graphql
================================================
mutation UpdateSoftware($software: SoftwareUpdateInput!) {
  updateSoftware(software: $software) {
    id
    name
  }
}



================================================
FILE: documents/specification/CountSpecifications.graphql
================================================
query CountSpecifications($filter: SpecificationFilter, $correlationId: String) {
  countSpecifications(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/specification/CreateSpecification.graphql
================================================
mutation CreateSpecification($specification: SpecificationInput!) {
  createSpecification(specification: $specification) {
    id
    name
    state
    type
    serviceType
  }
}



================================================
FILE: documents/specification/DeleteAllSpecifications.graphql
================================================
mutation DeleteAllSpecifications($filter: SpecificationFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllSpecifications(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/specification/DeleteSpecification.graphql
================================================
mutation DeleteSpecification($id: ID!) {
  deleteSpecification(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/specification/DeleteSpecifications.graphql
================================================
mutation DeleteSpecifications($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteSpecifications(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/specification/GetSpecification.graphql
================================================
query GetSpecification($id: ID!, $correlationId: String) {
  specification(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    type
    serviceType
    systemPrompt
    customGuidance
    customInstructions
    searchType
    numberSimilar
    strategy {
      type
      messageLimit
      embedCitations
      flattenCitations
      enableFacets
      messagesWeight
      contentsWeight
    }
    promptStrategy {
      type
    }
    retrievalStrategy {
      type
      contentLimit
      disableFallback
    }
    rerankingStrategy {
      serviceType
      threshold
    }
    graphStrategy {
      type
      generateGraph
      observableLimit
    }
    revisionStrategy {
      type
      customRevision
      count
    }
    azureAI {
      tokenLimit
      completionTokenLimit
      key
      endpoint
      temperature
      probability
      chunkTokenLimit
    }
    openAI {
      tokenLimit
      completionTokenLimit
      model
      key
      endpoint
      modelName
      temperature
      probability
      chunkTokenLimit
      detailLevel
      reasoningEffort
    }
    azureOpenAI {
      tokenLimit
      completionTokenLimit
      model
      key
      endpoint
      deploymentName
      temperature
      probability
      chunkTokenLimit
    }
    cohere {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      temperature
      probability
      chunkTokenLimit
    }
    anthropic {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      temperature
      probability
      enableThinking
      thinkingTokenLimit
    }
    google {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      temperature
      probability
      chunkTokenLimit
      enableThinking
      thinkingTokenLimit
    }
    replicate {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      temperature
      probability
    }
    mistral {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      endpoint
      temperature
      probability
      chunkTokenLimit
    }
    bedrock {
      tokenLimit
      completionTokenLimit
      model
      accessKey
      secretAccessKey
      modelName
      temperature
      probability
    }
    groq {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      endpoint
      temperature
      probability
    }
    cerebras {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      endpoint
      temperature
      probability
    }
    deepseek {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      temperature
      probability
    }
    jina {
      model
      key
      modelName
      chunkTokenLimit
    }
    voyage {
      model
      key
      modelName
      chunkTokenLimit
    }
  }
}



================================================
FILE: documents/specification/PromptSpecifications.graphql
================================================
mutation PromptSpecifications($prompt: String!, $ids: [ID!]!) {
  promptSpecifications(prompt: $prompt, ids: $ids) {
    specification {
      id
    }
    messages {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    error
  }
}



================================================
FILE: documents/specification/QueryModels.graphql
================================================
query QueryModels($filter: ModelFilter) {
  models(filter: $filter) {
    results {
      uri
      name
      type
      serviceType
      model
      modelType
      description
      availableOn
      features {
        keyFeatures
        strengths
        useCases
      }
      metadata {
        multilingual
        multimodal
        knowledgeCutoff
        promptCostPerMillion
        completionCostPerMillion
        embeddingsCostPerMillion
        rerankingCostPerMillion
        contextWindowTokens
        maxOutputTokens
      }
    }
  }
}



================================================
FILE: documents/specification/QuerySpecifications.graphql
================================================
query QuerySpecifications($filter: SpecificationFilter, $correlationId: String) {
  specifications(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      type
      serviceType
      systemPrompt
      customGuidance
      customInstructions
      searchType
      numberSimilar
      strategy {
        type
        messageLimit
        embedCitations
        flattenCitations
        enableFacets
        messagesWeight
        contentsWeight
      }
      promptStrategy {
        type
      }
      retrievalStrategy {
        type
        contentLimit
        disableFallback
      }
      rerankingStrategy {
        serviceType
        threshold
      }
      graphStrategy {
        type
        generateGraph
        observableLimit
      }
      revisionStrategy {
        type
        customRevision
        count
      }
      azureAI {
        tokenLimit
        completionTokenLimit
        key
        endpoint
        temperature
        probability
        chunkTokenLimit
      }
      openAI {
        tokenLimit
        completionTokenLimit
        model
        key
        endpoint
        modelName
        temperature
        probability
        chunkTokenLimit
        detailLevel
        reasoningEffort
      }
      azureOpenAI {
        tokenLimit
        completionTokenLimit
        model
        key
        endpoint
        deploymentName
        temperature
        probability
        chunkTokenLimit
      }
      cohere {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        temperature
        probability
        chunkTokenLimit
      }
      anthropic {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        temperature
        probability
        enableThinking
        thinkingTokenLimit
      }
      google {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        temperature
        probability
        chunkTokenLimit
        enableThinking
        thinkingTokenLimit
      }
      replicate {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        temperature
        probability
      }
      mistral {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        endpoint
        temperature
        probability
        chunkTokenLimit
      }
      bedrock {
        tokenLimit
        completionTokenLimit
        model
        accessKey
        secretAccessKey
        modelName
        temperature
        probability
      }
      groq {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        endpoint
        temperature
        probability
      }
      cerebras {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        endpoint
        temperature
        probability
      }
      deepseek {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        temperature
        probability
      }
      jina {
        model
        key
        modelName
        chunkTokenLimit
      }
      voyage {
        model
        key
        modelName
        chunkTokenLimit
      }
    }
  }
}



================================================
FILE: documents/specification/SpecificationExists.graphql
================================================
query SpecificationExists($filter: SpecificationFilter, $correlationId: String) {
  specificationExists(filter: $filter, correlationId: $correlationId) {
    result
  }
}



================================================
FILE: documents/specification/UpdateSpecification.graphql
================================================
mutation UpdateSpecification($specification: SpecificationUpdateInput!) {
  updateSpecification(specification: $specification) {
    id
    name
    state
    type
    serviceType
  }
}



================================================
FILE: documents/specification/UpsertSpecification.graphql
================================================
mutation UpsertSpecification($specification: SpecificationInput!) {
  upsertSpecification(specification: $specification) {
    id
    name
    state
    type
    serviceType
  }
}



================================================
FILE: documents/user/CountUsers.graphql
================================================
query CountUsers($filter: UserFilter, $correlationId: String) {
  countUsers(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/user/CreateUser.graphql
================================================
mutation CreateUser($user: UserInput!) {
  createUser(user: $user) {
    id
    name
    state
    type
    identifier
  }
}



================================================
FILE: documents/user/DeleteUser.graphql
================================================
mutation DeleteUser($id: ID!) {
  deleteUser(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/user/DisableUser.graphql
================================================
mutation DisableUser($id: ID!) {
  disableUser(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/user/EnableUser.graphql
================================================
mutation EnableUser($id: ID!) {
  enableUser(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/user/GetUser.graphql
================================================
query GetUser {
  user {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    type
    identifier
    connectors {
      id
      name
      state
      type
      authentication {
        type
        microsoft {
          tenantId
          clientId
          clientSecret
        }
        google {
          clientId
          clientSecret
        }
      }
      integration {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
    }
  }
}



================================================
FILE: documents/user/QueryUsers.graphql
================================================
query QueryUsers($filter: UserFilter, $correlationId: String) {
  users(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      type
      identifier
      connectors {
        id
        name
        state
        type
        authentication {
          type
          microsoft {
            tenantId
            clientId
            clientSecret
          }
          google {
            clientId
            clientSecret
          }
        }
        integration {
          type
          uri
          slack {
            token
            channel
          }
          email {
            from
            subject
            to
          }
          twitter {
            consumerKey
            consumerSecret
            accessTokenKey
            accessTokenSecret
          }
        }
      }
    }
  }
}



================================================
FILE: documents/user/UpdateUser.graphql
================================================
mutation UpdateUser($user: UserUpdateInput!) {
  updateUser(user: $user) {
    id
    name
    state
    type
    identifier
  }
}



================================================
FILE: documents/workflow/CountWorkflows.graphql
================================================
query CountWorkflows($filter: WorkflowFilter, $correlationId: String) {
  countWorkflows(filter: $filter, correlationId: $correlationId) {
    count
  }
}



================================================
FILE: documents/workflow/CreateWorkflow.graphql
================================================
mutation CreateWorkflow($workflow: WorkflowInput!) {
  createWorkflow(workflow: $workflow) {
    id
    name
    state
    ingestion {
      if {
        types
        fileTypes
        formats
        fileExtensions
        allowedPaths
        excludedPaths
      }
      collections {
        id
      }
      observations {
        type
        observable {
          id
          name
        }
      }
      enableEmailCollections
    }
    indexing {
      jobs {
        connector {
          type
          contentType
          fileType
        }
      }
    }
    preparation {
      enableUnblockedCapture
      disableSmartCapture
      summarizations {
        type
        specification {
          id
        }
        tokens
        items
        prompt
      }
      jobs {
        connector {
          type
          fileTypes
          azureDocument {
            version
            model
            endpoint
            key
          }
          deepgram {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          assemblyAI {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          page {
            enableScreenshot
          }
          document {
            includeImages
          }
          email {
            includeAttachments
          }
          modelDocument {
            specification {
              id
            }
          }
          mistral {
            key
          }
        }
      }
    }
    extraction {
      jobs {
        connector {
          type
          contentTypes
          fileTypes
          extractedTypes
          extractedCount
          azureText {
            confidenceThreshold
            enablePII
          }
          azureImage {
            confidenceThreshold
          }
          modelImage {
            specification {
              id
            }
          }
          modelText {
            specification {
              id
            }
          }
        }
      }
    }
    classification {
      jobs {
        connector {
          type
          contentType
          fileType
          model {
            specification {
              id
            }
            rules {
              then
              if
            }
          }
          regex {
            rules {
              then
              type
              path
              matches
            }
          }
        }
      }
    }
    enrichment {
      link {
        enableCrawling
        allowedDomains
        excludedDomains
        allowedPaths
        excludedPaths
        allowedLinks
        excludedLinks
        allowedFiles
        excludedFiles
        allowContentDomain
        maximumLinks
      }
      jobs {
        connector {
          type
          enrichedTypes
          fhir {
            endpoint
          }
          diffbot {
            key
          }
        }
      }
    }
    storage {
      policy {
        type
        allowDuplicates
      }
    }
    actions {
      connector {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
    }
  }
}



================================================
FILE: documents/workflow/DeleteAllWorkflows.graphql
================================================
mutation DeleteAllWorkflows($filter: WorkflowFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllWorkflows(filter: $filter, isSynchronous: $isSynchronous, correlationId: $correlationId) {
    id
    state
  }
}



================================================
FILE: documents/workflow/DeleteWorkflow.graphql
================================================
mutation DeleteWorkflow($id: ID!) {
  deleteWorkflow(id: $id) {
    id
    state
  }
}



================================================
FILE: documents/workflow/DeleteWorkflows.graphql
================================================
mutation DeleteWorkflows($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteWorkflows(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}



================================================
FILE: documents/workflow/GetWorkflow.graphql
================================================
query GetWorkflow($id: ID!, $correlationId: String) {
  workflow(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    ingestion {
      if {
        types
        fileTypes
        formats
        fileExtensions
        allowedPaths
        excludedPaths
      }
      collections {
        id
      }
      observations {
        type
        observable {
          id
          name
        }
      }
      enableEmailCollections
    }
    indexing {
      jobs {
        connector {
          type
          contentType
          fileType
        }
      }
    }
    preparation {
      enableUnblockedCapture
      disableSmartCapture
      summarizations {
        type
        specification {
          id
        }
        tokens
        items
        prompt
      }
      jobs {
        connector {
          type
          fileTypes
          azureDocument {
            version
            model
            endpoint
            key
          }
          deepgram {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          assemblyAI {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          page {
            enableScreenshot
          }
          document {
            includeImages
          }
          email {
            includeAttachments
          }
          modelDocument {
            specification {
              id
            }
          }
          mistral {
            key
          }
        }
      }
    }
    extraction {
      jobs {
        connector {
          type
          contentTypes
          fileTypes
          extractedTypes
          extractedCount
          azureText {
            confidenceThreshold
            enablePII
          }
          azureImage {
            confidenceThreshold
          }
          modelImage {
            specification {
              id
            }
          }
          modelText {
            specification {
              id
            }
          }
        }
      }
    }
    classification {
      jobs {
        connector {
          type
          contentType
          fileType
          model {
            specification {
              id
            }
            rules {
              then
              if
            }
          }
          regex {
            rules {
              then
              type
              path
              matches
            }
          }
        }
      }
    }
    enrichment {
      link {
        enableCrawling
        allowedDomains
        excludedDomains
        allowedPaths
        excludedPaths
        allowedLinks
        excludedLinks
        allowedFiles
        excludedFiles
        allowContentDomain
        maximumLinks
      }
      jobs {
        connector {
          type
          enrichedTypes
          fhir {
            endpoint
          }
          diffbot {
            key
          }
        }
      }
    }
    storage {
      policy {
        type
        allowDuplicates
      }
    }
    actions {
      connector {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
    }
  }
}



================================================
FILE: documents/workflow/QueryWorkflows.graphql
================================================
query QueryWorkflows($filter: WorkflowFilter, $correlationId: String) {
  workflows(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      ingestion {
        if {
          types
          fileTypes
          formats
          fileExtensions
          allowedPaths
          excludedPaths
        }
        collections {
          id
        }
        observations {
          type
          observable {
            id
            name
          }
        }
        enableEmailCollections
      }
      indexing {
        jobs {
          connector {
            type
            contentType
            fileType
          }
        }
      }
      preparation {
        enableUnblockedCapture
        disableSmartCapture
        summarizations {
          type
          specification {
            id
          }
          tokens
          items
          prompt
        }
        jobs {
          connector {
            type
            fileTypes
            azureDocument {
              version
              model
              endpoint
              key
            }
            deepgram {
              model
              key
              enableRedaction
              enableSpeakerDiarization
              detectLanguage
              language
            }
            assemblyAI {
              model
              key
              enableRedaction
              enableSpeakerDiarization
              detectLanguage
              language
            }
            page {
              enableScreenshot
            }
            document {
              includeImages
            }
            email {
              includeAttachments
            }
            modelDocument {
              specification {
                id
              }
            }
            mistral {
              key
            }
          }
        }
      }
      extraction {
        jobs {
          connector {
            type
            contentTypes
            fileTypes
            extractedTypes
            extractedCount
            azureText {
              confidenceThreshold
              enablePII
            }
            azureImage {
              confidenceThreshold
            }
            modelImage {
              specification {
                id
              }
            }
            modelText {
              specification {
                id
              }
            }
          }
        }
      }
      classification {
        jobs {
          connector {
            type
            contentType
            fileType
            model {
              specification {
                id
              }
              rules {
                then
                if
              }
            }
            regex {
              rules {
                then
                type
                path
                matches
              }
            }
          }
        }
      }
      enrichment {
        link {
          enableCrawling
          allowedDomains
          excludedDomains
          allowedPaths
          excludedPaths
          allowedLinks
          excludedLinks
          allowedFiles
          excludedFiles
          allowContentDomain
          maximumLinks
        }
        jobs {
          connector {
            type
            enrichedTypes
            fhir {
              endpoint
            }
            diffbot {
              key
            }
          }
        }
      }
      storage {
        policy {
          type
          allowDuplicates
        }
      }
      actions {
        connector {
          type
          uri
          slack {
            token
            channel
          }
          email {
            from
            subject
            to
          }
          twitter {
            consumerKey
            consumerSecret
            accessTokenKey
            accessTokenSecret
          }
        }
      }
    }
  }
}



================================================
FILE: documents/workflow/UpdateWorkflow.graphql
================================================
mutation UpdateWorkflow($workflow: WorkflowUpdateInput!) {
  updateWorkflow(workflow: $workflow) {
    id
    name
    state
    ingestion {
      if {
        types
        fileTypes
        formats
        fileExtensions
        allowedPaths
        excludedPaths
      }
      collections {
        id
      }
      observations {
        type
        observable {
          id
          name
        }
      }
      enableEmailCollections
    }
    indexing {
      jobs {
        connector {
          type
          contentType
          fileType
        }
      }
    }
    preparation {
      enableUnblockedCapture
      disableSmartCapture
      summarizations {
        type
        specification {
          id
        }
        tokens
        items
        prompt
      }
      jobs {
        connector {
          type
          fileTypes
          azureDocument {
            version
            model
            endpoint
            key
          }
          deepgram {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          assemblyAI {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          page {
            enableScreenshot
          }
          document {
            includeImages
          }
          email {
            includeAttachments
          }
          modelDocument {
            specification {
              id
            }
          }
          mistral {
            key
          }
        }
      }
    }
    extraction {
      jobs {
        connector {
          type
          contentTypes
          fileTypes
          extractedTypes
          extractedCount
          azureText {
            confidenceThreshold
            enablePII
          }
          azureImage {
            confidenceThreshold
          }
          modelImage {
            specification {
              id
            }
          }
          modelText {
            specification {
              id
            }
          }
        }
      }
    }
    classification {
      jobs {
        connector {
          type
          contentType
          fileType
          model {
            specification {
              id
            }
            rules {
              then
              if
            }
          }
          regex {
            rules {
              then
              type
              path
              matches
            }
          }
        }
      }
    }
    enrichment {
      link {
        enableCrawling
        allowedDomains
        excludedDomains
        allowedPaths
        excludedPaths
        allowedLinks
        excludedLinks
        allowedFiles
        excludedFiles
        allowContentDomain
        maximumLinks
      }
      jobs {
        connector {
          type
          enrichedTypes
          fhir {
            endpoint
          }
          diffbot {
            key
          }
        }
      }
    }
    storage {
      policy {
        type
        allowDuplicates
      }
    }
    actions {
      connector {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
    }
  }
}



================================================
FILE: documents/workflow/UpsertWorkflow.graphql
================================================
mutation UpsertWorkflow($workflow: WorkflowInput!) {
  upsertWorkflow(workflow: $workflow) {
    id
    name
    state
    ingestion {
      if {
        types
        fileTypes
        formats
        fileExtensions
        allowedPaths
        excludedPaths
      }
      collections {
        id
      }
      observations {
        type
        observable {
          id
          name
        }
      }
      enableEmailCollections
    }
    indexing {
      jobs {
        connector {
          type
          contentType
          fileType
        }
      }
    }
    preparation {
      enableUnblockedCapture
      disableSmartCapture
      summarizations {
        type
        specification {
          id
        }
        tokens
        items
        prompt
      }
      jobs {
        connector {
          type
          fileTypes
          azureDocument {
            version
            model
            endpoint
            key
          }
          deepgram {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          assemblyAI {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          page {
            enableScreenshot
          }
          document {
            includeImages
          }
          email {
            includeAttachments
          }
          modelDocument {
            specification {
              id
            }
          }
          mistral {
            key
          }
        }
      }
    }
    extraction {
      jobs {
        connector {
          type
          contentTypes
          fileTypes
          extractedTypes
          extractedCount
          azureText {
            confidenceThreshold
            enablePII
          }
          azureImage {
            confidenceThreshold
          }
          modelImage {
            specification {
              id
            }
          }
          modelText {
            specification {
              id
            }
          }
        }
      }
    }
    classification {
      jobs {
        connector {
          type
          contentType
          fileType
          model {
            specification {
              id
            }
            rules {
              then
              if
            }
          }
          regex {
            rules {
              then
              type
              path
              matches
            }
          }
        }
      }
    }
    enrichment {
      link {
        enableCrawling
        allowedDomains
        excludedDomains
        allowedPaths
        excludedPaths
        allowedLinks
        excludedLinks
        allowedFiles
        excludedFiles
        allowContentDomain
        maximumLinks
      }
      jobs {
        connector {
          type
          enrichedTypes
          fhir {
            endpoint
          }
          diffbot {
            key
          }
        }
      }
    }
    storage {
      policy {
        type
        allowDuplicates
      }
    }
    actions {
      connector {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
    }
  }
}



================================================
FILE: documents/workflow/WorkflowExists.graphql
================================================
query WorkflowExists($filter: WorkflowFilter, $correlationId: String) {
  workflowExists(filter: $filter, correlationId: $correlationId) {
    result
  }
}



================================================
FILE: graphlit/__init__.py
================================================
from .graphlit import Graphlit



================================================
FILE: graphlit/graphlit.py
================================================
import os
import jwt
import datetime
import httpx
from graphlit_api.client import Client

class Graphlit:
    def __init__(self, organization_id=None, environment_id=None, jwt_secret=None, owner_id=None, api_uri=None):
        self.organization_id = organization_id if organization_id is not None else os.getenv("GRAPHLIT_ORGANIZATION_ID")
        self.environment_id = environment_id if environment_id is not None else os.getenv("GRAPHLIT_ENVIRONMENT_ID")
        self.owner_id = owner_id if owner_id is not None else os.getenv("GRAPHLIT_OWNER_ID")
        self.secret_key = jwt_secret if jwt_secret is not None else os.getenv("GRAPHLIT_JWT_SECRET")
        self.api_uri = api_uri if api_uri is not None else "https://data-scus.graphlit.io/api/v1/graphql/"
        
        self.refresh_client()
        
    def refresh_client(self):
        self.client = None
        self._generate_token()
        
        headers = {"Authorization": f"Bearer {self.token}"}

        timeout = httpx.Timeout(connect=10.0, read=600.0, write=10.0, pool=60.0)
        
        self.client = Client(url=self.api_uri, headers=headers)
        self.client.http_client.timeout = timeout

    def _generate_token(self):
        expiration = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=1)
        
        payload = {
            "https://graphlit.io/jwt/claims": {
                "x-graphlit-organization-id": self.organization_id,
                "x-graphlit-environment-id": self.environment_id,
                "x-graphlit-role": "Owner",
            },
            "exp": expiration,
            "iss": "graphlit",
            "aud": "https://portal.graphlit.io",
        }

        if self.owner_id is not None:
            payload["https://graphlit.io/jwt/claims"]["x-graphlit-owner-id"] = self.owner_id
        
        self.token = jwt.encode(payload, self.secret_key, algorithm="HS256")



================================================
FILE: graphlit_api/__init__.py
================================================
# Generated by ariadne-codegen

from .add_contents_to_collections import (
    AddContentsToCollections,
    AddContentsToCollectionsAddContentsToCollections,
    AddContentsToCollectionsAddContentsToCollectionsContents,
)
from .ask_graphlit import (
    AskGraphlit,
    AskGraphlitAskGraphlit,
    AskGraphlitAskGraphlitConversation,
    AskGraphlitAskGraphlitMessage,
    AskGraphlitAskGraphlitMessageCitations,
    AskGraphlitAskGraphlitMessageCitationsContent,
    AskGraphlitAskGraphlitMessageCitationsContentAudio,
    AskGraphlitAskGraphlitMessageCitationsContentDocument,
    AskGraphlitAskGraphlitMessageCitationsContentImage,
    AskGraphlitAskGraphlitMessageCitationsContentVideo,
    AskGraphlitAskGraphlitMessageToolCalls,
)
from .async_base_client import AsyncBaseClient
from .base_model import BaseModel, Upload
from .clear_conversation import ClearConversation, ClearConversationClearConversation
from .client import Client
from .close_conversation import CloseConversation, CloseConversationCloseConversation
from .complete_conversation import (
    CompleteConversation,
    CompleteConversationCompleteConversation,
    CompleteConversationCompleteConversationConversation,
    CompleteConversationCompleteConversationDetails,
    CompleteConversationCompleteConversationDetailsMessages,
    CompleteConversationCompleteConversationDetailsMessagesCitations,
    CompleteConversationCompleteConversationDetailsMessagesCitationsContent,
    CompleteConversationCompleteConversationDetailsMessagesCitationsContentAudio,
    CompleteConversationCompleteConversationDetailsMessagesCitationsContentDocument,
    CompleteConversationCompleteConversationDetailsMessagesCitationsContentImage,
    CompleteConversationCompleteConversationDetailsMessagesCitationsContentVideo,
    CompleteConversationCompleteConversationDetailsMessagesToolCalls,
    CompleteConversationCompleteConversationFacets,
    CompleteConversationCompleteConversationFacetsObservable,
    CompleteConversationCompleteConversationFacetsObservableObservable,
    CompleteConversationCompleteConversationFacetsRange,
    CompleteConversationCompleteConversationGraph,
    CompleteConversationCompleteConversationGraphEdges,
    CompleteConversationCompleteConversationGraphNodes,
    CompleteConversationCompleteConversationMessage,
    CompleteConversationCompleteConversationMessageCitations,
    CompleteConversationCompleteConversationMessageCitationsContent,
    CompleteConversationCompleteConversationMessageCitationsContentAudio,
    CompleteConversationCompleteConversationMessageCitationsContentDocument,
    CompleteConversationCompleteConversationMessageCitationsContentImage,
    CompleteConversationCompleteConversationMessageCitationsContentVideo,
    CompleteConversationCompleteConversationMessageToolCalls,
)
from .continue_conversation import (
    ContinueConversation,
    ContinueConversationContinueConversation,
    ContinueConversationContinueConversationConversation,
    ContinueConversationContinueConversationDetails,
    ContinueConversationContinueConversationDetailsMessages,
    ContinueConversationContinueConversationDetailsMessagesCitations,
    ContinueConversationContinueConversationDetailsMessagesCitationsContent,
    ContinueConversationContinueConversationDetailsMessagesCitationsContentAudio,
    ContinueConversationContinueConversationDetailsMessagesCitationsContentDocument,
    ContinueConversationContinueConversationDetailsMessagesCitationsContentImage,
    ContinueConversationContinueConversationDetailsMessagesCitationsContentVideo,
    ContinueConversationContinueConversationDetailsMessagesToolCalls,
    ContinueConversationContinueConversationFacets,
    ContinueConversationContinueConversationFacetsObservable,
    ContinueConversationContinueConversationFacetsObservableObservable,
    ContinueConversationContinueConversationFacetsRange,
    ContinueConversationContinueConversationGraph,
    ContinueConversationContinueConversationGraphEdges,
    ContinueConversationContinueConversationGraphNodes,
    ContinueConversationContinueConversationMessage,
    ContinueConversationContinueConversationMessageCitations,
    ContinueConversationContinueConversationMessageCitationsContent,
    ContinueConversationContinueConversationMessageCitationsContentAudio,
    ContinueConversationContinueConversationMessageCitationsContentDocument,
    ContinueConversationContinueConversationMessageCitationsContentImage,
    ContinueConversationContinueConversationMessageCitationsContentVideo,
    ContinueConversationContinueConversationMessageToolCalls,
)
from .count_alerts import CountAlerts, CountAlertsCountAlerts
from .count_categories import CountCategories, CountCategoriesCountCategories
from .count_collections import CountCollections, CountCollectionsCountCollections
from .count_contents import CountContents, CountContentsCountContents
from .count_conversations import (
    CountConversations,
    CountConversationsCountConversations,
)
from .count_events import CountEvents, CountEventsCountEvents
from .count_feeds import CountFeeds, CountFeedsCountFeeds
from .count_labels import CountLabels, CountLabelsCountLabels
from .count_medical_conditions import (
    CountMedicalConditions,
    CountMedicalConditionsCountMedicalConditions,
)
from .count_medical_contraindications import (
    CountMedicalContraindications,
    CountMedicalContraindicationsCountMedicalContraindications,
)
from .count_medical_devices import (
    CountMedicalDevices,
    CountMedicalDevicesCountMedicalDevices,
)
from .count_medical_drug_classes import (
    CountMedicalDrugClasses,
    CountMedicalDrugClassesCountMedicalDrugClasses,
)
from .count_medical_drugs import CountMedicalDrugs, CountMedicalDrugsCountMedicalDrugs
from .count_medical_guidelines import (
    CountMedicalGuidelines,
    CountMedicalGuidelinesCountMedicalGuidelines,
)
from .count_medical_indications import (
    CountMedicalIndications,
    CountMedicalIndicationsCountMedicalIndications,
)
from .count_medical_procedures import (
    CountMedicalProcedures,
    CountMedicalProceduresCountMedicalProcedures,
)
from .count_medical_studies import (
    CountMedicalStudies,
    CountMedicalStudiesCountMedicalStudies,
)
from .count_medical_tests import CountMedicalTests, CountMedicalTestsCountMedicalTests
from .count_medical_therapies import (
    CountMedicalTherapies,
    CountMedicalTherapiesCountMedicalTherapies,
)
from .count_organizations import (
    CountOrganizations,
    CountOrganizationsCountOrganizations,
)
from .count_persons import CountPersons, CountPersonsCountPersons
from .count_places import CountPlaces, CountPlacesCountPlaces
from .count_products import CountProducts, CountProductsCountProducts
from .count_repos import CountRepos, CountReposCountRepos
from .count_softwares import CountSoftwares, CountSoftwaresCountSoftwares
from .count_specifications import (
    CountSpecifications,
    CountSpecificationsCountSpecifications,
)
from .count_users import CountUsers, CountUsersCountUsers
from .count_workflows import CountWorkflows, CountWorkflowsCountWorkflows
from .create_alert import CreateAlert, CreateAlertCreateAlert
from .create_category import CreateCategory, CreateCategoryCreateCategory
from .create_collection import CreateCollection, CreateCollectionCreateCollection
from .create_conversation import (
    CreateConversation,
    CreateConversationCreateConversation,
)
from .create_event import CreateEvent, CreateEventCreateEvent
from .create_feed import CreateFeed, CreateFeedCreateFeed
from .create_label import CreateLabel, CreateLabelCreateLabel
from .create_medical_condition import (
    CreateMedicalCondition,
    CreateMedicalConditionCreateMedicalCondition,
)
from .create_medical_contraindication import (
    CreateMedicalContraindication,
    CreateMedicalContraindicationCreateMedicalContraindication,
)
from .create_medical_device import (
    CreateMedicalDevice,
    CreateMedicalDeviceCreateMedicalDevice,
)
from .create_medical_drug import CreateMedicalDrug, CreateMedicalDrugCreateMedicalDrug
from .create_medical_drug_class import (
    CreateMedicalDrugClass,
    CreateMedicalDrugClassCreateMedicalDrugClass,
)
from .create_medical_guideline import (
    CreateMedicalGuideline,
    CreateMedicalGuidelineCreateMedicalGuideline,
)
from .create_medical_indication import (
    CreateMedicalIndication,
    CreateMedicalIndicationCreateMedicalIndication,
)
from .create_medical_procedure import (
    CreateMedicalProcedure,
    CreateMedicalProcedureCreateMedicalProcedure,
)
from .create_medical_study import (
    CreateMedicalStudy,
    CreateMedicalStudyCreateMedicalStudy,
)
from .create_medical_test import CreateMedicalTest, CreateMedicalTestCreateMedicalTest
from .create_medical_therapy import (
    CreateMedicalTherapy,
    CreateMedicalTherapyCreateMedicalTherapy,
)
from .create_observation import CreateObservation, CreateObservationCreateObservation
from .create_organization import (
    CreateOrganization,
    CreateOrganizationCreateOrganization,
)
from .create_person import CreatePerson, CreatePersonCreatePerson
from .create_place import CreatePlace, CreatePlaceCreatePlace
from .create_product import CreateProduct, CreateProductCreateProduct
from .create_repo import CreateRepo, CreateRepoCreateRepo
from .create_software import CreateSoftware, CreateSoftwareCreateSoftware
from .create_specification import (
    CreateSpecification,
    CreateSpecificationCreateSpecification,
)
from .create_user import CreateUser, CreateUserCreateUser
from .create_workflow import (
    CreateWorkflow,
    CreateWorkflowCreateWorkflow,
    CreateWorkflowCreateWorkflowActions,
    CreateWorkflowCreateWorkflowActionsConnector,
    CreateWorkflowCreateWorkflowActionsConnectorEmail,
    CreateWorkflowCreateWorkflowActionsConnectorSlack,
    CreateWorkflowCreateWorkflowActionsConnectorTwitter,
    CreateWorkflowCreateWorkflowClassification,
    CreateWorkflowCreateWorkflowClassificationJobs,
    CreateWorkflowCreateWorkflowClassificationJobsConnector,
    CreateWorkflowCreateWorkflowClassificationJobsConnectorModel,
    CreateWorkflowCreateWorkflowClassificationJobsConnectorModelRules,
    CreateWorkflowCreateWorkflowClassificationJobsConnectorModelSpecification,
    CreateWorkflowCreateWorkflowClassificationJobsConnectorRegex,
    CreateWorkflowCreateWorkflowClassificationJobsConnectorRegexRules,
    CreateWorkflowCreateWorkflowEnrichment,
    CreateWorkflowCreateWorkflowEnrichmentJobs,
    CreateWorkflowCreateWorkflowEnrichmentJobsConnector,
    CreateWorkflowCreateWorkflowEnrichmentJobsConnectorDiffbot,
    CreateWorkflowCreateWorkflowEnrichmentJobsConnectorFhir,
    CreateWorkflowCreateWorkflowEnrichmentLink,
    CreateWorkflowCreateWorkflowExtraction,
    CreateWorkflowCreateWorkflowExtractionJobs,
    CreateWorkflowCreateWorkflowExtractionJobsConnector,
    CreateWorkflowCreateWorkflowExtractionJobsConnectorAzureImage,
    CreateWorkflowCreateWorkflowExtractionJobsConnectorAzureText,
    CreateWorkflowCreateWorkflowExtractionJobsConnectorModelImage,
    CreateWorkflowCreateWorkflowExtractionJobsConnectorModelImageSpecification,
    CreateWorkflowCreateWorkflowExtractionJobsConnectorModelText,
    CreateWorkflowCreateWorkflowExtractionJobsConnectorModelTextSpecification,
    CreateWorkflowCreateWorkflowIndexing,
    CreateWorkflowCreateWorkflowIndexingJobs,
    CreateWorkflowCreateWorkflowIndexingJobsConnector,
    CreateWorkflowCreateWorkflowIngestion,
    CreateWorkflowCreateWorkflowIngestionCollections,
    CreateWorkflowCreateWorkflowIngestionIf,
    CreateWorkflowCreateWorkflowIngestionObservations,
    CreateWorkflowCreateWorkflowIngestionObservationsObservable,
    CreateWorkflowCreateWorkflowPreparation,
    CreateWorkflowCreateWorkflowPreparationJobs,
    CreateWorkflowCreateWorkflowPreparationJobsConnector,
    CreateWorkflowCreateWorkflowPreparationJobsConnectorAssemblyAi,
    CreateWorkflowCreateWorkflowPreparationJobsConnectorAzureDocument,
    CreateWorkflowCreateWorkflowPreparationJobsConnectorDeepgram,
    CreateWorkflowCreateWorkflowPreparationJobsConnectorDocument,
    CreateWorkflowCreateWorkflowPreparationJobsConnectorEmail,
    CreateWorkflowCreateWorkflowPreparationJobsConnectorMistral,
    CreateWorkflowCreateWorkflowPreparationJobsConnectorModelDocument,
    CreateWorkflowCreateWorkflowPreparationJobsConnectorModelDocumentSpecification,
    CreateWorkflowCreateWorkflowPreparationJobsConnectorPage,
    CreateWorkflowCreateWorkflowPreparationSummarizations,
    CreateWorkflowCreateWorkflowPreparationSummarizationsSpecification,
    CreateWorkflowCreateWorkflowStorage,
    CreateWorkflowCreateWorkflowStoragePolicy,
)
from .delete_alert import DeleteAlert, DeleteAlertDeleteAlert
from .delete_alerts import DeleteAlerts, DeleteAlertsDeleteAlerts
from .delete_all_alerts import DeleteAllAlerts, DeleteAllAlertsDeleteAllAlerts
from .delete_all_categories import (
    DeleteAllCategories,
    DeleteAllCategoriesDeleteAllCategories,
)
from .delete_all_collections import (
    DeleteAllCollections,
    DeleteAllCollectionsDeleteAllCollections,
)
from .delete_all_contents import DeleteAllContents, DeleteAllContentsDeleteAllContents
from .delete_all_conversations import (
    DeleteAllConversations,
    DeleteAllConversationsDeleteAllConversations,
)
from .delete_all_events import DeleteAllEvents, DeleteAllEventsDeleteAllEvents
from .delete_all_feeds import DeleteAllFeeds, DeleteAllFeedsDeleteAllFeeds
from .delete_all_labels import DeleteAllLabels, DeleteAllLabelsDeleteAllLabels
from .delete_all_medical_conditions import (
    DeleteAllMedicalConditions,
    DeleteAllMedicalConditionsDeleteAllMedicalConditions,
)
from .delete_all_medical_contraindications import (
    DeleteAllMedicalContraindications,
    DeleteAllMedicalContraindicationsDeleteAllMedicalContraindications,
)
from .delete_all_medical_devices import (
    DeleteAllMedicalDevices,
    DeleteAllMedicalDevicesDeleteAllMedicalDevices,
)
from .delete_all_medical_drug_classes import (
    DeleteAllMedicalDrugClasses,
    DeleteAllMedicalDrugClassesDeleteAllMedicalDrugClasses,
)
from .delete_all_medical_drugs import (
    DeleteAllMedicalDrugs,
    DeleteAllMedicalDrugsDeleteAllMedicalDrugs,
)
from .delete_all_medical_guidelines import (
    DeleteAllMedicalGuidelines,
    DeleteAllMedicalGuidelinesDeleteAllMedicalGuidelines,
)
from .delete_all_medical_indications import (
    DeleteAllMedicalIndications,
    DeleteAllMedicalIndicationsDeleteAllMedicalIndications,
)
from .delete_all_medical_procedures import (
    DeleteAllMedicalProcedures,
    DeleteAllMedicalProceduresDeleteAllMedicalProcedures,
)
from .delete_all_medical_studies import (
    DeleteAllMedicalStudies,
    DeleteAllMedicalStudiesDeleteAllMedicalStudies,
)
from .delete_all_medical_tests import (
    DeleteAllMedicalTests,
    DeleteAllMedicalTestsDeleteAllMedicalTests,
)
from .delete_all_medical_therapies import (
    DeleteAllMedicalTherapies,
    DeleteAllMedicalTherapiesDeleteAllMedicalTherapies,
)
from .delete_all_organizations import (
    DeleteAllOrganizations,
    DeleteAllOrganizationsDeleteAllOrganizations,
)
from .delete_all_persons import DeleteAllPersons, DeleteAllPersonsDeleteAllPersons
from .delete_all_places import DeleteAllPlaces, DeleteAllPlacesDeleteAllPlaces
from .delete_all_products import DeleteAllProducts, DeleteAllProductsDeleteAllProducts
from .delete_all_repos import DeleteAllRepos, DeleteAllReposDeleteAllRepos
from .delete_all_softwares import (
    DeleteAllSoftwares,
    DeleteAllSoftwaresDeleteAllSoftwares,
)
from .delete_all_specifications import (
    DeleteAllSpecifications,
    DeleteAllSpecificationsDeleteAllSpecifications,
)
from .delete_all_workflows import (
    DeleteAllWorkflows,
    DeleteAllWorkflowsDeleteAllWorkflows,
)
from .delete_categories import DeleteCategories, DeleteCategoriesDeleteCategories
from .delete_category import DeleteCategory, DeleteCategoryDeleteCategory
from .delete_collection import DeleteCollection, DeleteCollectionDeleteCollection
from .delete_collections import DeleteCollections, DeleteCollectionsDeleteCollections
from .delete_content import DeleteContent, DeleteContentDeleteContent
from .delete_contents import DeleteContents, DeleteContentsDeleteContents
from .delete_conversation import (
    DeleteConversation,
    DeleteConversationDeleteConversation,
)
from .delete_conversations import (
    DeleteConversations,
    DeleteConversationsDeleteConversations,
)
from .delete_event import DeleteEvent, DeleteEventDeleteEvent
from .delete_events import DeleteEvents, DeleteEventsDeleteEvents
from .delete_feed import DeleteFeed, DeleteFeedDeleteFeed
from .delete_feeds import DeleteFeeds, DeleteFeedsDeleteFeeds
from .delete_label import DeleteLabel, DeleteLabelDeleteLabel
from .delete_labels import DeleteLabels, DeleteLabelsDeleteLabels
from .delete_medical_condition import (
    DeleteMedicalCondition,
    DeleteMedicalConditionDeleteMedicalCondition,
)
from .delete_medical_conditions import (
    DeleteMedicalConditions,
    DeleteMedicalConditionsDeleteMedicalConditions,
)
from .delete_medical_contraindication import (
    DeleteMedicalContraindication,
    DeleteMedicalContraindicationDeleteMedicalContraindication,
)
from .delete_medical_contraindications import (
    DeleteMedicalContraindications,
    DeleteMedicalContraindicationsDeleteMedicalContraindications,
)
from .delete_medical_device import (
    DeleteMedicalDevice,
    DeleteMedicalDeviceDeleteMedicalDevice,
)
from .delete_medical_devices import (
    DeleteMedicalDevices,
    DeleteMedicalDevicesDeleteMedicalDevices,
)
from .delete_medical_drug import DeleteMedicalDrug, DeleteMedicalDrugDeleteMedicalDrug
from .delete_medical_drug_class import (
    DeleteMedicalDrugClass,
    DeleteMedicalDrugClassDeleteMedicalDrugClass,
)
from .delete_medical_drug_classes import (
    DeleteMedicalDrugClasses,
    DeleteMedicalDrugClassesDeleteMedicalDrugClasses,
)
from .delete_medical_drugs import (
    DeleteMedicalDrugs,
    DeleteMedicalDrugsDeleteMedicalDrugs,
)
from .delete_medical_guideline import (
    DeleteMedicalGuideline,
    DeleteMedicalGuidelineDeleteMedicalGuideline,
)
from .delete_medical_guidelines import (
    DeleteMedicalGuidelines,
    DeleteMedicalGuidelinesDeleteMedicalGuidelines,
)
from .delete_medical_indication import (
    DeleteMedicalIndication,
    DeleteMedicalIndicationDeleteMedicalIndication,
)
from .delete_medical_indications import (
    DeleteMedicalIndications,
    DeleteMedicalIndicationsDeleteMedicalIndications,
)
from .delete_medical_procedure import (
    DeleteMedicalProcedure,
    DeleteMedicalProcedureDeleteMedicalProcedure,
)
from .delete_medical_procedures import (
    DeleteMedicalProcedures,
    DeleteMedicalProceduresDeleteMedicalProcedures,
)
from .delete_medical_studies import (
    DeleteMedicalStudies,
    DeleteMedicalStudiesDeleteMedicalStudies,
)
from .delete_medical_study import (
    DeleteMedicalStudy,
    DeleteMedicalStudyDeleteMedicalStudy,
)
from .delete_medical_test import DeleteMedicalTest, DeleteMedicalTestDeleteMedicalTest
from .delete_medical_tests import (
    DeleteMedicalTests,
    DeleteMedicalTestsDeleteMedicalTests,
)
from .delete_medical_therapies import (
    DeleteMedicalTherapies,
    DeleteMedicalTherapiesDeleteMedicalTherapies,
)
from .delete_medical_therapy import (
    DeleteMedicalTherapy,
    DeleteMedicalTherapyDeleteMedicalTherapy,
)
from .delete_observation import DeleteObservation, DeleteObservationDeleteObservation
from .delete_organization import (
    DeleteOrganization,
    DeleteOrganizationDeleteOrganization,
)
from .delete_organizations import (
    DeleteOrganizations,
    DeleteOrganizationsDeleteOrganizations,
)
from .delete_person import DeletePerson, DeletePersonDeletePerson
from .delete_persons import DeletePersons, DeletePersonsDeletePersons
from .delete_place import DeletePlace, DeletePlaceDeletePlace
from .delete_places import DeletePlaces, DeletePlacesDeletePlaces
from .delete_product import DeleteProduct, DeleteProductDeleteProduct
from .delete_products import DeleteProducts, DeleteProductsDeleteProducts
from .delete_repo import DeleteRepo, DeleteRepoDeleteRepo
from .delete_repos import DeleteRepos, DeleteReposDeleteRepos
from .delete_software import DeleteSoftware, DeleteSoftwareDeleteSoftware
from .delete_softwares import DeleteSoftwares, DeleteSoftwaresDeleteSoftwares
from .delete_specification import (
    DeleteSpecification,
    DeleteSpecificationDeleteSpecification,
)
from .delete_specifications import (
    DeleteSpecifications,
    DeleteSpecificationsDeleteSpecifications,
)
from .delete_user import DeleteUser, DeleteUserDeleteUser
from .delete_workflow import DeleteWorkflow, DeleteWorkflowDeleteWorkflow
from .delete_workflows import DeleteWorkflows, DeleteWorkflowsDeleteWorkflows
from .describe_encoded_image import (
    DescribeEncodedImage,
    DescribeEncodedImageDescribeEncodedImage,
    DescribeEncodedImageDescribeEncodedImageCitations,
    DescribeEncodedImageDescribeEncodedImageCitationsContent,
    DescribeEncodedImageDescribeEncodedImageCitationsContentAudio,
    DescribeEncodedImageDescribeEncodedImageCitationsContentDocument,
    DescribeEncodedImageDescribeEncodedImageCitationsContentImage,
    DescribeEncodedImageDescribeEncodedImageCitationsContentVideo,
    DescribeEncodedImageDescribeEncodedImageToolCalls,
)
from .describe_image import (
    DescribeImage,
    DescribeImageDescribeImage,
    DescribeImageDescribeImageCitations,
    DescribeImageDescribeImageCitationsContent,
    DescribeImageDescribeImageCitationsContentAudio,
    DescribeImageDescribeImageCitationsContentDocument,
    DescribeImageDescribeImageCitationsContentImage,
    DescribeImageDescribeImageCitationsContentVideo,
    DescribeImageDescribeImageToolCalls,
)
from .disable_alert import DisableAlert, DisableAlertDisableAlert
from .disable_feed import DisableFeed, DisableFeedDisableFeed
from .disable_user import DisableUser, DisableUserDisableUser
from .enable_alert import EnableAlert, EnableAlertEnableAlert
from .enable_feed import EnableFeed, EnableFeedEnableFeed
from .enable_user import EnableUser, EnableUserEnableUser
from .enums import (
    AlertTypes,
    AnthropicModels,
    ApplyPolicy,
    AssemblyAIModels,
    AuthenticationServiceTypes,
    AzureDocumentIntelligenceModels,
    AzureDocumentIntelligenceVersions,
    AzureOpenAIModels,
    BedrockModels,
    BillableMetrics,
    CategoryFacetTypes,
    CerebrasModels,
    CohereModels,
    CollectionTypes,
    ConnectorTypes,
    ContentClassificationServiceTypes,
    ContentFacetTypes,
    ContentIndexingServiceTypes,
    ContentPublishingFormats,
    ContentPublishingServiceTypes,
    ContentSourceTypes,
    ContentTypes,
    ConversationRoleTypes,
    ConversationSearchTypes,
    ConversationStrategyTypes,
    ConversationTypes,
    DeepgramModels,
    DeepseekModels,
    DeviceTypes,
    ElevenLabsModels,
    EmailListingTypes,
    EntityEnrichmentServiceTypes,
    EntityExtractionServiceTypes,
    EntityState,
    EntityTypes,
    EnvironmentTypes,
    EventFacetTypes,
    FacetValueTypes,
    FeedConnectorTypes,
    FeedListingTypes,
    FeedServiceTypes,
    FeedTypes,
    FilePreparationServiceTypes,
    FileTypes,
    GoogleDriveAuthenticationTypes,
    GoogleModels,
    GraphStrategyTypes,
    GroqModels,
    H3ResolutionTypes,
    ImageProjectionTypes,
    IntegrationServiceTypes,
    JinaModels,
    LabelFacetTypes,
    LinkTypes,
    MailImportance,
    MailPriority,
    MailSensitivity,
    MedicalConditionFacetTypes,
    MedicalContraindicationFacetTypes,
    MedicalDeviceFacetTypes,
    MedicalDrugClassFacetTypes,
    MedicalDrugFacetTypes,
    MedicalGuidelineFacetTypes,
    MedicalIndicationFacetTypes,
    MedicalProcedureFacetTypes,
    MedicalStudyFacetTypes,
    MedicalTestFacetTypes,
    MedicalTherapyFacetTypes,
    MetadataTypes,
    MistralModels,
    ModelServiceTypes,
    ModelTypes,
    NotionTypes,
    ObservableTypes,
    OccurrenceTypes,
    OpenAIImageModels,
    OpenAIModels,
    OpenAIReasoningEffortLevels,
    OpenAIVisionDetailLevels,
    OperationTypes,
    OrderByTypes,
    OrderDirectionTypes,
    OrganizationFacetTypes,
    OrientationTypes,
    PersonFacetTypes,
    PlaceFacetTypes,
    PolicyTimeTypes,
    ProductFacetTypes,
    PromptStrategyTypes,
    RegexSourceTypes,
    RenditionTypes,
    ReplicateModels,
    RepoFacetTypes,
    RerankingModelServiceTypes,
    ResourceConnectorTypes,
    RetrievalStrategyTypes,
    RevisionStrategyTypes,
    SdkTypes,
    SearchQueryTypes,
    SearchServiceTypes,
    SearchTypes,
    SharePointAuthenticationTypes,
    SiteTypes,
    SoftwareFacetTypes,
    SpecificationTypes,
    StoragePolicyTypes,
    SummarizationTypes,
    TextRoles,
    TextTypes,
    TimedPolicyRecurrenceTypes,
    TimeIntervalTypes,
    TrelloTypes,
    TwitterListingTypes,
    UnitTypes,
    UserTypes,
    VoyageModels,
    YouTubeTypes,
)
from .exceptions import (
    GraphQLClientError,
    GraphQLClientGraphQLError,
    GraphQLClientGraphQLMultiError,
    GraphQLClientHttpError,
    GraphQLClientInvalidResponseError,
)
from .extract_contents import (
    ExtractContents,
    ExtractContentsExtractContents,
    ExtractContentsExtractContentsContent,
    ExtractContentsExtractContentsSpecification,
)
from .extract_text import (
    ExtractText,
    ExtractTextExtractText,
    ExtractTextExtractTextContent,
    ExtractTextExtractTextSpecification,
)
from .feed_exists import FeedExists, FeedExistsFeedExists
from .format_conversation import (
    FormatConversation,
    FormatConversationFormatConversation,
    FormatConversationFormatConversationConversation,
    FormatConversationFormatConversationDetails,
    FormatConversationFormatConversationDetailsMessages,
    FormatConversationFormatConversationDetailsMessagesCitations,
    FormatConversationFormatConversationDetailsMessagesCitationsContent,
    FormatConversationFormatConversationDetailsMessagesCitationsContentAudio,
    FormatConversationFormatConversationDetailsMessagesCitationsContentDocument,
    FormatConversationFormatConversationDetailsMessagesCitationsContentImage,
    FormatConversationFormatConversationDetailsMessagesCitationsContentVideo,
    FormatConversationFormatConversationDetailsMessagesToolCalls,
    FormatConversationFormatConversationFacets,
    FormatConversationFormatConversationFacetsObservable,
    FormatConversationFormatConversationFacetsObservableObservable,
    FormatConversationFormatConversationFacetsRange,
    FormatConversationFormatConversationGraph,
    FormatConversationFormatConversationGraphEdges,
    FormatConversationFormatConversationGraphNodes,
    FormatConversationFormatConversationMessage,
    FormatConversationFormatConversationMessageCitations,
    FormatConversationFormatConversationMessageCitationsContent,
    FormatConversationFormatConversationMessageCitationsContentAudio,
    FormatConversationFormatConversationMessageCitationsContentDocument,
    FormatConversationFormatConversationMessageCitationsContentImage,
    FormatConversationFormatConversationMessageCitationsContentVideo,
    FormatConversationFormatConversationMessageToolCalls,
)
from .get_alert import (
    GetAlert,
    GetAlertAlert,
    GetAlertAlertFilter,
    GetAlertAlertFilterAnd,
    GetAlertAlertFilterAndCollections,
    GetAlertAlertFilterAndFeeds,
    GetAlertAlertFilterAndObservations,
    GetAlertAlertFilterAndObservationsObservable,
    GetAlertAlertFilterAndUsers,
    GetAlertAlertFilterAndWorkflows,
    GetAlertAlertFilterCollections,
    GetAlertAlertFilterContents,
    GetAlertAlertFilterCreationDateRange,
    GetAlertAlertFilterDateRange,
    GetAlertAlertFilterFeeds,
    GetAlertAlertFilterObservations,
    GetAlertAlertFilterObservationsObservable,
    GetAlertAlertFilterOr,
    GetAlertAlertFilterOrCollections,
    GetAlertAlertFilterOrFeeds,
    GetAlertAlertFilterOrObservations,
    GetAlertAlertFilterOrObservationsObservable,
    GetAlertAlertFilterOrUsers,
    GetAlertAlertFilterOrWorkflows,
    GetAlertAlertFilterSimilarContents,
    GetAlertAlertFilterUsers,
    GetAlertAlertFilterWorkflows,
    GetAlertAlertIntegration,
    GetAlertAlertIntegrationEmail,
    GetAlertAlertIntegrationSlack,
    GetAlertAlertIntegrationTwitter,
    GetAlertAlertOwner,
    GetAlertAlertPublishing,
    GetAlertAlertPublishingElevenLabs,
    GetAlertAlertPublishingOpenAiImage,
    GetAlertAlertPublishingOpenAiImageSeed,
    GetAlertAlertPublishSpecification,
    GetAlertAlertSummarySpecification,
)
from .get_category import GetCategory, GetCategoryCategory
from .get_collection import (
    GetCollection,
    GetCollectionCollection,
    GetCollectionCollectionContents,
    GetCollectionCollectionOwner,
)
from .get_content import (
    GetContent,
    GetContentContent,
    GetContentContentAddress,
    GetContentContentAudio,
    GetContentContentChildren,
    GetContentContentCollections,
    GetContentContentDocument,
    GetContentContentEmail,
    GetContentContentEmailBcc,
    GetContentContentEmailCc,
    GetContentContentEmailFrom,
    GetContentContentEmailTo,
    GetContentContentFeed,
    GetContentContentFrames,
    GetContentContentImage,
    GetContentContentIssue,
    GetContentContentLanguage,
    GetContentContentLinks,
    GetContentContentLocation,
    GetContentContentObservations,
    GetContentContentObservationsObservable,
    GetContentContentObservationsOccurrences,
    GetContentContentObservationsOccurrencesBoundingBox,
    GetContentContentObservationsRelated,
    GetContentContentOwner,
    GetContentContentPackage,
    GetContentContentPages,
    GetContentContentPagesChunks,
    GetContentContentPagesImages,
    GetContentContentParent,
    GetContentContentSegments,
    GetContentContentVideo,
    GetContentContentWorkflow,
)
from .get_conversation import (
    GetConversation,
    GetConversationConversation,
    GetConversationConversationAugmentedFilter,
    GetConversationConversationAugmentedFilterAnd,
    GetConversationConversationAugmentedFilterAndCollections,
    GetConversationConversationAugmentedFilterAndFeeds,
    GetConversationConversationAugmentedFilterAndObservations,
    GetConversationConversationAugmentedFilterAndObservationsObservable,
    GetConversationConversationAugmentedFilterAndUsers,
    GetConversationConversationAugmentedFilterAndWorkflows,
    GetConversationConversationAugmentedFilterCollections,
    GetConversationConversationAugmentedFilterContents,
    GetConversationConversationAugmentedFilterCreationDateRange,
    GetConversationConversationAugmentedFilterDateRange,
    GetConversationConversationAugmentedFilterFeeds,
    GetConversationConversationAugmentedFilterObservations,
    GetConversationConversationAugmentedFilterObservationsObservable,
    GetConversationConversationAugmentedFilterOr,
    GetConversationConversationAugmentedFilterOrCollections,
    GetConversationConversationAugmentedFilterOrFeeds,
    GetConversationConversationAugmentedFilterOrObservations,
    GetConversationConversationAugmentedFilterOrObservationsObservable,
    GetConversationConversationAugmentedFilterOrUsers,
    GetConversationConversationAugmentedFilterOrWorkflows,
    GetConversationConversationAugmentedFilterSimilarContents,
    GetConversationConversationAugmentedFilterUsers,
    GetConversationConversationAugmentedFilterWorkflows,
    GetConversationConversationFallbacks,
    GetConversationConversationFilter,
    GetConversationConversationFilterAnd,
    GetConversationConversationFilterAndCollections,
    GetConversationConversationFilterAndFeeds,
    GetConversationConversationFilterAndObservations,
    GetConversationConversationFilterAndObservationsObservable,
    GetConversationConversationFilterAndUsers,
    GetConversationConversationFilterAndWorkflows,
    GetConversationConversationFilterCollections,
    GetConversationConversationFilterContents,
    GetConversationConversationFilterCreationDateRange,
    GetConversationConversationFilterDateRange,
    GetConversationConversationFilterFeeds,
    GetConversationConversationFilterObservations,
    GetConversationConversationFilterObservationsObservable,
    GetConversationConversationFilterOr,
    GetConversationConversationFilterOrCollections,
    GetConversationConversationFilterOrFeeds,
    GetConversationConversationFilterOrObservations,
    GetConversationConversationFilterOrObservationsObservable,
    GetConversationConversationFilterOrUsers,
    GetConversationConversationFilterOrWorkflows,
    GetConversationConversationFilterSimilarContents,
    GetConversationConversationFilterUsers,
    GetConversationConversationFilterWorkflows,
    GetConversationConversationMessages,
    GetConversationConversationMessagesCitations,
    GetConversationConversationMessagesCitationsContent,
    GetConversationConversationMessagesCitationsContentAudio,
    GetConversationConversationMessagesCitationsContentDocument,
    GetConversationConversationMessagesCitationsContentImage,
    GetConversationConversationMessagesCitationsContentVideo,
    GetConversationConversationMessagesToolCalls,
    GetConversationConversationOwner,
    GetConversationConversationSpecification,
)
from .get_event import GetEvent, GetEventEvent, GetEventEventAddress
from .get_feed import (
    GetFeed,
    GetFeedFeed,
    GetFeedFeedDiscord,
    GetFeedFeedEmail,
    GetFeedFeedEmailGoogle,
    GetFeedFeedEmailMicrosoft,
    GetFeedFeedIntercom,
    GetFeedFeedIssue,
    GetFeedFeedIssueGithub,
    GetFeedFeedIssueIntercom,
    GetFeedFeedIssueJira,
    GetFeedFeedIssueLinear,
    GetFeedFeedIssueTrello,
    GetFeedFeedIssueZendesk,
    GetFeedFeedMicrosoftTeams,
    GetFeedFeedNotion,
    GetFeedFeedOwner,
    GetFeedFeedReddit,
    GetFeedFeedRss,
    GetFeedFeedSchedulePolicy,
    GetFeedFeedSearch,
    GetFeedFeedSite,
    GetFeedFeedSiteAzureBlob,
    GetFeedFeedSiteAzureFile,
    GetFeedFeedSiteBox,
    GetFeedFeedSiteDropbox,
    GetFeedFeedSiteGithub,
    GetFeedFeedSiteGoogle,
    GetFeedFeedSiteGoogleDrive,
    GetFeedFeedSiteOneDrive,
    GetFeedFeedSiteS3,
    GetFeedFeedSiteSharePoint,
    GetFeedFeedSlack,
    GetFeedFeedTwitter,
    GetFeedFeedWeb,
    GetFeedFeedWorkflow,
    GetFeedFeedYoutube,
    GetFeedFeedZendesk,
)
from .get_label import GetLabel, GetLabelLabel
from .get_medical_condition import (
    GetMedicalCondition,
    GetMedicalConditionMedicalCondition,
)
from .get_medical_contraindication import (
    GetMedicalContraindication,
    GetMedicalContraindicationMedicalContraindication,
)
from .get_medical_device import GetMedicalDevice, GetMedicalDeviceMedicalDevice
from .get_medical_drug import GetMedicalDrug, GetMedicalDrugMedicalDrug
from .get_medical_drug_class import (
    GetMedicalDrugClass,
    GetMedicalDrugClassMedicalDrugClass,
)
from .get_medical_guideline import (
    GetMedicalGuideline,
    GetMedicalGuidelineMedicalGuideline,
)
from .get_medical_indication import (
    GetMedicalIndication,
    GetMedicalIndicationMedicalIndication,
)
from .get_medical_procedure import (
    GetMedicalProcedure,
    GetMedicalProcedureMedicalProcedure,
)
from .get_medical_study import (
    GetMedicalStudy,
    GetMedicalStudyMedicalStudy,
    GetMedicalStudyMedicalStudyAddress,
)
from .get_medical_test import GetMedicalTest, GetMedicalTestMedicalTest
from .get_medical_therapy import GetMedicalTherapy, GetMedicalTherapyMedicalTherapy
from .get_organization import (
    GetOrganization,
    GetOrganizationOrganization,
    GetOrganizationOrganizationAddress,
)
from .get_person import GetPerson, GetPersonPerson, GetPersonPersonAddress
from .get_place import GetPlace, GetPlacePlace, GetPlacePlaceAddress
from .get_product import GetProduct, GetProductProduct, GetProductProductAddress
from .get_project import (
    GetProject,
    GetProjectProject,
    GetProjectProjectEmbeddings,
    GetProjectProjectEmbeddingsImageSpecification,
    GetProjectProjectEmbeddingsTextSpecification,
    GetProjectProjectQuota,
    GetProjectProjectSpecification,
    GetProjectProjectWorkflow,
)
from .get_repo import GetRepo, GetRepoRepo
from .get_share_point_consent_uri import (
    GetSharePointConsentUri,
    GetSharePointConsentUriSharePointConsentUri,
)
from .get_software import GetSoftware, GetSoftwareSoftware
from .get_specification import (
    GetSpecification,
    GetSpecificationSpecification,
    GetSpecificationSpecificationAnthropic,
    GetSpecificationSpecificationAzureAi,
    GetSpecificationSpecificationAzureOpenAi,
    GetSpecificationSpecificationBedrock,
    GetSpecificationSpecificationCerebras,
    GetSpecificationSpecificationCohere,
    GetSpecificationSpecificationDeepseek,
    GetSpecificationSpecificationGoogle,
    GetSpecificationSpecificationGraphStrategy,
    GetSpecificationSpecificationGroq,
    GetSpecificationSpecificationJina,
    GetSpecificationSpecificationMistral,
    GetSpecificationSpecificationOpenAi,
    GetSpecificationSpecificationOwner,
    GetSpecificationSpecificationPromptStrategy,
    GetSpecificationSpecificationReplicate,
    GetSpecificationSpecificationRerankingStrategy,
    GetSpecificationSpecificationRetrievalStrategy,
    GetSpecificationSpecificationRevisionStrategy,
    GetSpecificationSpecificationStrategy,
    GetSpecificationSpecificationVoyage,
)
from .get_user import (
    GetUser,
    GetUserUser,
    GetUserUserConnectors,
    GetUserUserConnectorsAuthentication,
    GetUserUserConnectorsAuthenticationGoogle,
    GetUserUserConnectorsAuthenticationMicrosoft,
    GetUserUserConnectorsIntegration,
    GetUserUserConnectorsIntegrationEmail,
    GetUserUserConnectorsIntegrationSlack,
    GetUserUserConnectorsIntegrationTwitter,
    GetUserUserOwner,
)
from .get_workflow import (
    GetWorkflow,
    GetWorkflowWorkflow,
    GetWorkflowWorkflowActions,
    GetWorkflowWorkflowActionsConnector,
    GetWorkflowWorkflowActionsConnectorEmail,
    GetWorkflowWorkflowActionsConnectorSlack,
    GetWorkflowWorkflowActionsConnectorTwitter,
    GetWorkflowWorkflowClassification,
    GetWorkflowWorkflowClassificationJobs,
    GetWorkflowWorkflowClassificationJobsConnector,
    GetWorkflowWorkflowClassificationJobsConnectorModel,
    GetWorkflowWorkflowClassificationJobsConnectorModelRules,
    GetWorkflowWorkflowClassificationJobsConnectorModelSpecification,
    GetWorkflowWorkflowClassificationJobsConnectorRegex,
    GetWorkflowWorkflowClassificationJobsConnectorRegexRules,
    GetWorkflowWorkflowEnrichment,
    GetWorkflowWorkflowEnrichmentJobs,
    GetWorkflowWorkflowEnrichmentJobsConnector,
    GetWorkflowWorkflowEnrichmentJobsConnectorDiffbot,
    GetWorkflowWorkflowEnrichmentJobsConnectorFhir,
    GetWorkflowWorkflowEnrichmentLink,
    GetWorkflowWorkflowExtraction,
    GetWorkflowWorkflowExtractionJobs,
    GetWorkflowWorkflowExtractionJobsConnector,
    GetWorkflowWorkflowExtractionJobsConnectorAzureImage,
    GetWorkflowWorkflowExtractionJobsConnectorAzureText,
    GetWorkflowWorkflowExtractionJobsConnectorModelImage,
    GetWorkflowWorkflowExtractionJobsConnectorModelImageSpecification,
    GetWorkflowWorkflowExtractionJobsConnectorModelText,
    GetWorkflowWorkflowExtractionJobsConnectorModelTextSpecification,
    GetWorkflowWorkflowIndexing,
    GetWorkflowWorkflowIndexingJobs,
    GetWorkflowWorkflowIndexingJobsConnector,
    GetWorkflowWorkflowIngestion,
    GetWorkflowWorkflowIngestionCollections,
    GetWorkflowWorkflowIngestionIf,
    GetWorkflowWorkflowIngestionObservations,
    GetWorkflowWorkflowIngestionObservationsObservable,
    GetWorkflowWorkflowOwner,
    GetWorkflowWorkflowPreparation,
    GetWorkflowWorkflowPreparationJobs,
    GetWorkflowWorkflowPreparationJobsConnector,
    GetWorkflowWorkflowPreparationJobsConnectorAssemblyAi,
    GetWorkflowWorkflowPreparationJobsConnectorAzureDocument,
    GetWorkflowWorkflowPreparationJobsConnectorDeepgram,
    GetWorkflowWorkflowPreparationJobsConnectorDocument,
    GetWorkflowWorkflowPreparationJobsConnectorEmail,
    GetWorkflowWorkflowPreparationJobsConnectorMistral,
    GetWorkflowWorkflowPreparationJobsConnectorModelDocument,
    GetWorkflowWorkflowPreparationJobsConnectorModelDocumentSpecification,
    GetWorkflowWorkflowPreparationJobsConnectorPage,
    GetWorkflowWorkflowPreparationSummarizations,
    GetWorkflowWorkflowPreparationSummarizationsSpecification,
    GetWorkflowWorkflowStorage,
    GetWorkflowWorkflowStoragePolicy,
)
from .ingest_batch import (
    IngestBatch,
    IngestBatchIngestBatch,
    IngestBatchIngestBatchCollections,
    IngestBatchIngestBatchObservations,
    IngestBatchIngestBatchObservationsObservable,
    IngestBatchIngestBatchObservationsOccurrences,
    IngestBatchIngestBatchObservationsOccurrencesBoundingBox,
    IngestBatchIngestBatchObservationsRelated,
)
from .ingest_encoded_file import (
    IngestEncodedFile,
    IngestEncodedFileIngestEncodedFile,
    IngestEncodedFileIngestEncodedFileCollections,
    IngestEncodedFileIngestEncodedFileObservations,
    IngestEncodedFileIngestEncodedFileObservationsObservable,
    IngestEncodedFileIngestEncodedFileObservationsOccurrences,
    IngestEncodedFileIngestEncodedFileObservationsOccurrencesBoundingBox,
    IngestEncodedFileIngestEncodedFileObservationsRelated,
)
from .ingest_memory import (
    IngestMemory,
    IngestMemoryIngestMemory,
    IngestMemoryIngestMemoryCollections,
    IngestMemoryIngestMemoryObservations,
    IngestMemoryIngestMemoryObservationsObservable,
    IngestMemoryIngestMemoryObservationsOccurrences,
    IngestMemoryIngestMemoryObservationsOccurrencesBoundingBox,
    IngestMemoryIngestMemoryObservationsRelated,
)
from .ingest_text import (
    IngestText,
    IngestTextIngestText,
    IngestTextIngestTextCollections,
    IngestTextIngestTextObservations,
    IngestTextIngestTextObservationsObservable,
    IngestTextIngestTextObservationsOccurrences,
    IngestTextIngestTextObservationsOccurrencesBoundingBox,
    IngestTextIngestTextObservationsRelated,
)
from .ingest_text_batch import (
    IngestTextBatch,
    IngestTextBatchIngestTextBatch,
    IngestTextBatchIngestTextBatchCollections,
    IngestTextBatchIngestTextBatchObservations,
    IngestTextBatchIngestTextBatchObservationsObservable,
    IngestTextBatchIngestTextBatchObservationsOccurrences,
    IngestTextBatchIngestTextBatchObservationsOccurrencesBoundingBox,
    IngestTextBatchIngestTextBatchObservationsRelated,
)
from .ingest_uri import (
    IngestUri,
    IngestUriIngestUri,
    IngestUriIngestUriCollections,
    IngestUriIngestUriObservations,
    IngestUriIngestUriObservationsObservable,
    IngestUriIngestUriObservationsOccurrences,
    IngestUriIngestUriObservationsOccurrencesBoundingBox,
    IngestUriIngestUriObservationsRelated,
)
from .input_types import (
    AddressFilter,
    AddressInput,
    AlertFilter,
    AlertInput,
    AlertSchedulePolicyInput,
    AlertUpdateInput,
    AmazonFeedPropertiesInput,
    AmazonFeedPropertiesUpdateInput,
    AnthropicModelPropertiesInput,
    AnthropicModelPropertiesUpdateInput,
    AssemblyAIAudioPreparationPropertiesInput,
    AtlassianJiraFeedPropertiesInput,
    AtlassianJiraFeedPropertiesUpdateInput,
    AudioMetadataInput,
    AuthenticationConnectorInput,
    AzureAIModelPropertiesInput,
    AzureAIModelPropertiesUpdateInput,
    AzureBlobFeedPropertiesInput,
    AzureBlobFeedPropertiesUpdateInput,
    AzureDocumentPreparationPropertiesInput,
    AzureFileFeedPropertiesInput,
    AzureFileFeedPropertiesUpdateInput,
    AzureImageExtractionPropertiesInput,
    AzureOpenAIModelPropertiesInput,
    AzureOpenAIModelPropertiesUpdateInput,
    AzureTextExtractionPropertiesInput,
    BedrockModelPropertiesInput,
    BedrockModelPropertiesUpdateInput,
    BoundingBoxInput,
    BoxFeedPropertiesInput,
    BoxFeedPropertiesUpdateInput,
    CategoryFacetInput,
    CategoryFilter,
    CategoryInput,
    CategoryUpdateInput,
    CerebrasModelPropertiesInput,
    CerebrasModelPropertiesUpdateInput,
    ClassificationWorkflowJobInput,
    ClassificationWorkflowStageInput,
    CohereModelPropertiesInput,
    CohereModelPropertiesUpdateInput,
    CollectionFilter,
    CollectionInput,
    CollectionUpdateInput,
    ConnectorFilter,
    ConnectorInput,
    ConnectorUpdateInput,
    ContentClassificationConnectorInput,
    ContentCriteriaInput,
    ContentCriteriaLevelInput,
    ContentFacetInput,
    ContentFilter,
    ContentFilterLevel,
    ContentGraphInput,
    ContentIndexingConnectorInput,
    ContentInput,
    ContentPublishingConnectorInput,
    ContentPublishingConnectorUpdateInput,
    ContentUpdateInput,
    ConversationFilter,
    ConversationInput,
    ConversationMessageInput,
    ConversationStrategyInput,
    ConversationStrategyUpdateInput,
    ConversationToolResponseInput,
    ConversationUpdateInput,
    DateRangeFilter,
    DateRangeInput,
    DeepgramAudioPreparationPropertiesInput,
    DeepseekModelPropertiesInput,
    DeepseekModelPropertiesUpdateInput,
    DiffbotEnrichmentPropertiesInput,
    DiscordFeedPropertiesInput,
    DiscordFeedPropertiesUpdateInput,
    DocumentMetadataInput,
    DocumentPreparationPropertiesInput,
    DrawingMetadataInput,
    DropboxFeedPropertiesInput,
    DropboxFeedPropertiesUpdateInput,
    ElevenLabsPublishingPropertiesInput,
    EmailFeedPropertiesInput,
    EmailFeedPropertiesUpdateInput,
    EmailIntegrationPropertiesInput,
    EmailMetadataInput,
    EmailPreparationPropertiesInput,
    EmbeddingsStrategyInput,
    EnrichmentWorkflowJobInput,
    EnrichmentWorkflowStageInput,
    EntityEnrichmentConnectorInput,
    EntityExtractionConnectorInput,
    EntityReferenceFilter,
    EntityReferenceInput,
    EventFacetInput,
    EventFilter,
    EventInput,
    EventUpdateInput,
    ExtractionWorkflowJobInput,
    ExtractionWorkflowStageInput,
    FeedFilter,
    FeedInput,
    FeedSchedulePolicyInput,
    FeedUpdateInput,
    FHIREnrichmentPropertiesInput,
    FilePreparationConnectorInput,
    GeometryMetadataInput,
    GitHubFeedPropertiesInput,
    GitHubFeedPropertiesUpdateInput,
    GitHubIssuesFeedPropertiesInput,
    GitHubIssuesFeedPropertiesUpdateInput,
    GoogleAuthenticationPropertiesInput,
    GoogleDriveFeedPropertiesInput,
    GoogleDriveFeedPropertiesUpdateInput,
    GoogleEmailFeedPropertiesInput,
    GoogleEmailFeedPropertiesUpdateInput,
    GoogleFeedPropertiesInput,
    GoogleFeedPropertiesUpdateInput,
    GoogleModelPropertiesInput,
    GoogleModelPropertiesUpdateInput,
    GraphStrategyInput,
    GraphStrategyUpdateInput,
    GroqModelPropertiesInput,
    GroqModelPropertiesUpdateInput,
    H3Filter,
    H3IndexFilter,
    ImageMetadataInput,
    IndexingWorkflowJobInput,
    IndexingWorkflowStageInput,
    IngestionContentFilterInput,
    IngestionWorkflowStageInput,
    Int64RangeFilter,
    IntegrationConnectorInput,
    IntegrationConnectorUpdateInput,
    IntercomFeedPropertiesInput,
    IntercomFeedPropertiesUpdateInput,
    IntercomTicketsFeedPropertiesInput,
    IntercomTicketsFeedPropertiesUpdateInput,
    IssueFeedPropertiesInput,
    IssueFeedPropertiesUpdateInput,
    IssueMetadataInput,
    JinaModelPropertiesInput,
    JinaModelPropertiesUpdateInput,
    LabelFacetInput,
    LabelFilter,
    LabelInput,
    LabelUpdateInput,
    LanguageMetadataInput,
    LinearFeedPropertiesInput,
    LinearFeedPropertiesUpdateInput,
    LinearProjectsInput,
    LinkStrategyInput,
    MedicalConditionFacetInput,
    MedicalConditionFilter,
    MedicalConditionInput,
    MedicalConditionUpdateInput,
    MedicalContraindicationFacetInput,
    MedicalContraindicationFilter,
    MedicalContraindicationInput,
    MedicalContraindicationUpdateInput,
    MedicalDeviceFacetInput,
    MedicalDeviceFilter,
    MedicalDeviceInput,
    MedicalDeviceUpdateInput,
    MedicalDrugClassFacetInput,
    MedicalDrugClassFilter,
    MedicalDrugClassInput,
    MedicalDrugClassUpdateInput,
    MedicalDrugFacetInput,
    MedicalDrugFilter,
    MedicalDrugInput,
    MedicalDrugUpdateInput,
    MedicalGuidelineFacetInput,
    MedicalGuidelineFilter,
    MedicalGuidelineInput,
    MedicalGuidelineUpdateInput,
    MedicalIndicationFacetInput,
    MedicalIndicationFilter,
    MedicalIndicationInput,
    MedicalIndicationUpdateInput,
    MedicalProcedureFacetInput,
    MedicalProcedureFilter,
    MedicalProcedureInput,
    MedicalProcedureUpdateInput,
    MedicalStudyFacetInput,
    MedicalStudyFilter,
    MedicalStudyInput,
    MedicalStudyUpdateInput,
    MedicalTestFacetInput,
    MedicalTestFilter,
    MedicalTestInput,
    MedicalTestUpdateInput,
    MedicalTherapyFacetInput,
    MedicalTherapyFilter,
    MedicalTherapyInput,
    MedicalTherapyUpdateInput,
    MetadataFilter,
    MetadataInput,
    MetadataUpdateInput,
    MicrosoftAuthenticationPropertiesInput,
    MicrosoftEmailFeedPropertiesInput,
    MicrosoftEmailFeedPropertiesUpdateInput,
    MicrosoftTeamsChannelsInput,
    MicrosoftTeamsFeedPropertiesInput,
    MicrosoftTeamsFeedPropertiesUpdateInput,
    MicrosoftTeamsTeamsInput,
    MistralDocumentPreparationPropertiesInput,
    MistralModelPropertiesInput,
    MistralModelPropertiesUpdateInput,
    ModelContentClassificationPropertiesInput,
    ModelDocumentPreparationPropertiesInput,
    ModelFilter,
    ModelImageExtractionPropertiesInput,
    ModelTextExtractionPropertiesInput,
    NamedEntityReferenceInput,
    NotionDatabasesInput,
    NotionFeedPropertiesInput,
    NotionFeedPropertiesUpdateInput,
    NotionPagesInput,
    ObservationCriteriaInput,
    ObservationInput,
    ObservationOccurrenceInput,
    ObservationReferenceFilter,
    ObservationReferenceInput,
    ObservationUpdateInput,
    OneDriveFeedPropertiesInput,
    OneDriveFeedPropertiesUpdateInput,
    OneDriveFoldersInput,
    OpenAIImagePublishingPropertiesInput,
    OpenAIModelPropertiesInput,
    OpenAIModelPropertiesUpdateInput,
    OrganizationFacetInput,
    OrganizationFilter,
    OrganizationInput,
    OrganizationUpdateInput,
    PackageMetadataInput,
    PagePreparationPropertiesInput,
    PersonFacetInput,
    PersonFilter,
    PersonInput,
    PersonUpdateInput,
    PlaceFacetInput,
    PlaceFilter,
    PlaceInput,
    PlaceUpdateInput,
    PointCloudMetadataInput,
    PointFilter,
    PointInput,
    PreparationWorkflowJobInput,
    PreparationWorkflowStageInput,
    ProductFacetInput,
    ProductFilter,
    ProductInput,
    ProductUpdateInput,
    ProjectFilter,
    ProjectInput,
    ProjectQuotaInput,
    ProjectUpdateInput,
    PromptClassificationRuleInput,
    PromptStrategyInput,
    PromptStrategyUpdateInput,
    RedditFeedPropertiesInput,
    RedditFeedPropertiesUpdateInput,
    RegexClassificationRuleInput,
    RegexContentClassificationPropertiesInput,
    ReplicateModelPropertiesInput,
    ReplicateModelPropertiesUpdateInput,
    RepoFacetInput,
    RepoFilter,
    RepoInput,
    RepoUpdateInput,
    RerankingStrategyInput,
    RerankingStrategyUpdateInput,
    RetrievalStrategyInput,
    RetrievalStrategyUpdateInput,
    RevisionStrategyInput,
    RevisionStrategyUpdateInput,
    RSSFeedPropertiesInput,
    RSSFeedPropertiesUpdateInput,
    SearchFeedPropertiesInput,
    SearchFeedPropertiesUpdateInput,
    ShapeMetadataInput,
    SharePointFeedPropertiesInput,
    SharePointFeedPropertiesUpdateInput,
    SharePointFoldersInput,
    SharePointLibrariesInput,
    SiteFeedPropertiesInput,
    SiteFeedPropertiesUpdateInput,
    SlackChannelsInput,
    SlackFeedPropertiesInput,
    SlackFeedPropertiesUpdateInput,
    SlackIntegrationPropertiesInput,
    SoftwareFacetInput,
    SoftwareFilter,
    SoftwareInput,
    SoftwareUpdateInput,
    SpecificationFilter,
    SpecificationInput,
    SpecificationUpdateInput,
    StoragePolicyInput,
    StorageWorkflowStageInput,
    SummarizationStrategyInput,
    TextContentInput,
    ToolDefinitionInput,
    TrelloFeedPropertiesInput,
    TrelloFeedPropertiesUpdateInput,
    TwitterFeedPropertiesInput,
    TwitterFeedPropertiesUpdateInput,
    TwitterIntegrationPropertiesInput,
    UserFilter,
    UserInput,
    UserUpdateInput,
    VideoMetadataInput,
    VoyageModelPropertiesInput,
    VoyageModelPropertiesUpdateInput,
    WebFeedPropertiesInput,
    WebFeedPropertiesUpdateInput,
    WorkflowActionInput,
    WorkflowFilter,
    WorkflowInput,
    WorkflowUpdateInput,
    YouTubeFeedPropertiesInput,
    YouTubeFeedPropertiesUpdateInput,
    ZendeskFeedPropertiesInput,
    ZendeskFeedPropertiesUpdateInput,
    ZendeskTicketsFeedPropertiesInput,
    ZendeskTicketsFeedPropertiesUpdateInput,
)
from .is_content_done import IsContentDone, IsContentDoneIsContentDone
from .is_feed_done import IsFeedDone, IsFeedDoneIsFeedDone
from .lookup_credits import LookupCredits, LookupCreditsLookupCredits
from .lookup_usage import LookupUsage, LookupUsageLookupUsage
from .map_web import MapWeb, MapWebMapWeb
from .operations import (
    ADD_CONTENTS_TO_COLLECTIONS_GQL,
    ASK_GRAPHLIT_GQL,
    CLEAR_CONVERSATION_GQL,
    CLOSE_CONVERSATION_GQL,
    COMPLETE_CONVERSATION_GQL,
    CONTINUE_CONVERSATION_GQL,
    COUNT_ALERTS_GQL,
    COUNT_CATEGORIES_GQL,
    COUNT_COLLECTIONS_GQL,
    COUNT_CONTENTS_GQL,
    COUNT_CONVERSATIONS_GQL,
    COUNT_EVENTS_GQL,
    COUNT_FEEDS_GQL,
    COUNT_LABELS_GQL,
    COUNT_MEDICAL_CONDITIONS_GQL,
    COUNT_MEDICAL_CONTRAINDICATIONS_GQL,
    COUNT_MEDICAL_DEVICES_GQL,
    COUNT_MEDICAL_DRUG_CLASSES_GQL,
    COUNT_MEDICAL_DRUGS_GQL,
    COUNT_MEDICAL_GUIDELINES_GQL,
    COUNT_MEDICAL_INDICATIONS_GQL,
    COUNT_MEDICAL_PROCEDURES_GQL,
    COUNT_MEDICAL_STUDIES_GQL,
    COUNT_MEDICAL_TESTS_GQL,
    COUNT_MEDICAL_THERAPIES_GQL,
    COUNT_ORGANIZATIONS_GQL,
    COUNT_PERSONS_GQL,
    COUNT_PLACES_GQL,
    COUNT_PRODUCTS_GQL,
    COUNT_REPOS_GQL,
    COUNT_SOFTWARES_GQL,
    COUNT_SPECIFICATIONS_GQL,
    COUNT_USERS_GQL,
    COUNT_WORKFLOWS_GQL,
    CREATE_ALERT_GQL,
    CREATE_CATEGORY_GQL,
    CREATE_COLLECTION_GQL,
    CREATE_CONVERSATION_GQL,
    CREATE_EVENT_GQL,
    CREATE_FEED_GQL,
    CREATE_LABEL_GQL,
    CREATE_MEDICAL_CONDITION_GQL,
    CREATE_MEDICAL_CONTRAINDICATION_GQL,
    CREATE_MEDICAL_DEVICE_GQL,
    CREATE_MEDICAL_DRUG_CLASS_GQL,
    CREATE_MEDICAL_DRUG_GQL,
    CREATE_MEDICAL_GUIDELINE_GQL,
    CREATE_MEDICAL_INDICATION_GQL,
    CREATE_MEDICAL_PROCEDURE_GQL,
    CREATE_MEDICAL_STUDY_GQL,
    CREATE_MEDICAL_TEST_GQL,
    CREATE_MEDICAL_THERAPY_GQL,
    CREATE_OBSERVATION_GQL,
    CREATE_ORGANIZATION_GQL,
    CREATE_PERSON_GQL,
    CREATE_PLACE_GQL,
    CREATE_PRODUCT_GQL,
    CREATE_REPO_GQL,
    CREATE_SOFTWARE_GQL,
    CREATE_SPECIFICATION_GQL,
    CREATE_USER_GQL,
    CREATE_WORKFLOW_GQL,
    DELETE_ALERT_GQL,
    DELETE_ALERTS_GQL,
    DELETE_ALL_ALERTS_GQL,
    DELETE_ALL_CATEGORIES_GQL,
    DELETE_ALL_COLLECTIONS_GQL,
    DELETE_ALL_CONTENTS_GQL,
    DELETE_ALL_CONVERSATIONS_GQL,
    DELETE_ALL_EVENTS_GQL,
    DELETE_ALL_FEEDS_GQL,
    DELETE_ALL_LABELS_GQL,
    DELETE_ALL_MEDICAL_CONDITIONS_GQL,
    DELETE_ALL_MEDICAL_CONTRAINDICATIONS_GQL,
    DELETE_ALL_MEDICAL_DEVICES_GQL,
    DELETE_ALL_MEDICAL_DRUG_CLASSES_GQL,
    DELETE_ALL_MEDICAL_DRUGS_GQL,
    DELETE_ALL_MEDICAL_GUIDELINES_GQL,
    DELETE_ALL_MEDICAL_INDICATIONS_GQL,
    DELETE_ALL_MEDICAL_PROCEDURES_GQL,
    DELETE_ALL_MEDICAL_STUDIES_GQL,
    DELETE_ALL_MEDICAL_TESTS_GQL,
    DELETE_ALL_MEDICAL_THERAPIES_GQL,
    DELETE_ALL_ORGANIZATIONS_GQL,
    DELETE_ALL_PERSONS_GQL,
    DELETE_ALL_PLACES_GQL,
    DELETE_ALL_PRODUCTS_GQL,
    DELETE_ALL_REPOS_GQL,
    DELETE_ALL_SOFTWARES_GQL,
    DELETE_ALL_SPECIFICATIONS_GQL,
    DELETE_ALL_WORKFLOWS_GQL,
    DELETE_CATEGORIES_GQL,
    DELETE_CATEGORY_GQL,
    DELETE_COLLECTION_GQL,
    DELETE_COLLECTIONS_GQL,
    DELETE_CONTENT_GQL,
    DELETE_CONTENTS_GQL,
    DELETE_CONVERSATION_GQL,
    DELETE_CONVERSATIONS_GQL,
    DELETE_EVENT_GQL,
    DELETE_EVENTS_GQL,
    DELETE_FEED_GQL,
    DELETE_FEEDS_GQL,
    DELETE_LABEL_GQL,
    DELETE_LABELS_GQL,
    DELETE_MEDICAL_CONDITION_GQL,
    DELETE_MEDICAL_CONDITIONS_GQL,
    DELETE_MEDICAL_CONTRAINDICATION_GQL,
    DELETE_MEDICAL_CONTRAINDICATIONS_GQL,
    DELETE_MEDICAL_DEVICE_GQL,
    DELETE_MEDICAL_DEVICES_GQL,
    DELETE_MEDICAL_DRUG_CLASS_GQL,
    DELETE_MEDICAL_DRUG_CLASSES_GQL,
    DELETE_MEDICAL_DRUG_GQL,
    DELETE_MEDICAL_DRUGS_GQL,
    DELETE_MEDICAL_GUIDELINE_GQL,
    DELETE_MEDICAL_GUIDELINES_GQL,
    DELETE_MEDICAL_INDICATION_GQL,
    DELETE_MEDICAL_INDICATIONS_GQL,
    DELETE_MEDICAL_PROCEDURE_GQL,
    DELETE_MEDICAL_PROCEDURES_GQL,
    DELETE_MEDICAL_STUDIES_GQL,
    DELETE_MEDICAL_STUDY_GQL,
    DELETE_MEDICAL_TEST_GQL,
    DELETE_MEDICAL_TESTS_GQL,
    DELETE_MEDICAL_THERAPIES_GQL,
    DELETE_MEDICAL_THERAPY_GQL,
    DELETE_OBSERVATION_GQL,
    DELETE_ORGANIZATION_GQL,
    DELETE_ORGANIZATIONS_GQL,
    DELETE_PERSON_GQL,
    DELETE_PERSONS_GQL,
    DELETE_PLACE_GQL,
    DELETE_PLACES_GQL,
    DELETE_PRODUCT_GQL,
    DELETE_PRODUCTS_GQL,
    DELETE_REPO_GQL,
    DELETE_REPOS_GQL,
    DELETE_SOFTWARE_GQL,
    DELETE_SOFTWARES_GQL,
    DELETE_SPECIFICATION_GQL,
    DELETE_SPECIFICATIONS_GQL,
    DELETE_USER_GQL,
    DELETE_WORKFLOW_GQL,
    DELETE_WORKFLOWS_GQL,
    DESCRIBE_ENCODED_IMAGE_GQL,
    DESCRIBE_IMAGE_GQL,
    DISABLE_ALERT_GQL,
    DISABLE_FEED_GQL,
    DISABLE_USER_GQL,
    ENABLE_ALERT_GQL,
    ENABLE_FEED_GQL,
    ENABLE_USER_GQL,
    EXTRACT_CONTENTS_GQL,
    EXTRACT_TEXT_GQL,
    FEED_EXISTS_GQL,
    FORMAT_CONVERSATION_GQL,
    GET_ALERT_GQL,
    GET_CATEGORY_GQL,
    GET_COLLECTION_GQL,
    GET_CONTENT_GQL,
    GET_CONVERSATION_GQL,
    GET_EVENT_GQL,
    GET_FEED_GQL,
    GET_LABEL_GQL,
    GET_MEDICAL_CONDITION_GQL,
    GET_MEDICAL_CONTRAINDICATION_GQL,
    GET_MEDICAL_DEVICE_GQL,
    GET_MEDICAL_DRUG_CLASS_GQL,
    GET_MEDICAL_DRUG_GQL,
    GET_MEDICAL_GUIDELINE_GQL,
    GET_MEDICAL_INDICATION_GQL,
    GET_MEDICAL_PROCEDURE_GQL,
    GET_MEDICAL_STUDY_GQL,
    GET_MEDICAL_TEST_GQL,
    GET_MEDICAL_THERAPY_GQL,
    GET_ORGANIZATION_GQL,
    GET_PERSON_GQL,
    GET_PLACE_GQL,
    GET_PRODUCT_GQL,
    GET_PROJECT_GQL,
    GET_REPO_GQL,
    GET_SHARE_POINT_CONSENT_URI_GQL,
    GET_SOFTWARE_GQL,
    GET_SPECIFICATION_GQL,
    GET_USER_GQL,
    GET_WORKFLOW_GQL,
    INGEST_BATCH_GQL,
    INGEST_ENCODED_FILE_GQL,
    INGEST_MEMORY_GQL,
    INGEST_TEXT_BATCH_GQL,
    INGEST_TEXT_GQL,
    INGEST_URI_GQL,
    IS_CONTENT_DONE_GQL,
    IS_FEED_DONE_GQL,
    LOOKUP_CREDITS_GQL,
    LOOKUP_USAGE_GQL,
    MAP_WEB_GQL,
    PROMPT_CONVERSATION_GQL,
    PROMPT_GQL,
    PROMPT_SPECIFICATIONS_GQL,
    PUBLISH_CONTENTS_GQL,
    PUBLISH_CONVERSATION_GQL,
    PUBLISH_TEXT_GQL,
    QUERY_ALERTS_GQL,
    QUERY_CATEGORIES_GQL,
    QUERY_COLLECTIONS_GQL,
    QUERY_CONTENTS_FACETS_GQL,
    QUERY_CONTENTS_GQL,
    QUERY_CONTENTS_GRAPH_GQL,
    QUERY_CONVERSATIONS_GQL,
    QUERY_CREDITS_GQL,
    QUERY_EVENTS_GQL,
    QUERY_FEEDS_GQL,
    QUERY_LABELS_GQL,
    QUERY_LINEAR_PROJECTS_GQL,
    QUERY_MEDICAL_CONDITIONS_GQL,
    QUERY_MEDICAL_CONTRAINDICATIONS_GQL,
    QUERY_MEDICAL_DEVICES_GQL,
    QUERY_MEDICAL_DRUG_CLASSES_GQL,
    QUERY_MEDICAL_DRUGS_GQL,
    QUERY_MEDICAL_GUIDELINES_GQL,
    QUERY_MEDICAL_INDICATIONS_GQL,
    QUERY_MEDICAL_PROCEDURES_GQL,
    QUERY_MEDICAL_STUDIES_GQL,
    QUERY_MEDICAL_TESTS_GQL,
    QUERY_MEDICAL_THERAPIES_GQL,
    QUERY_MICROSOFT_TEAMS_CHANNELS_GQL,
    QUERY_MICROSOFT_TEAMS_TEAMS_GQL,
    QUERY_MODELS_GQL,
    QUERY_NOTION_DATABASES_GQL,
    QUERY_NOTION_PAGES_GQL,
    QUERY_ONE_DRIVE_FOLDERS_GQL,
    QUERY_ORGANIZATIONS_GQL,
    QUERY_PERSONS_GQL,
    QUERY_PLACES_GQL,
    QUERY_PRODUCTS_GQL,
    QUERY_REPOS_GQL,
    QUERY_SHARE_POINT_FOLDERS_GQL,
    QUERY_SHARE_POINT_LIBRARIES_GQL,
    QUERY_SLACK_CHANNELS_GQL,
    QUERY_SOFTWARES_GQL,
    QUERY_SPECIFICATIONS_GQL,
    QUERY_TOKENS_GQL,
    QUERY_USAGE_GQL,
    QUERY_USERS_GQL,
    QUERY_WORKFLOWS_GQL,
    REMOVE_CONTENTS_FROM_COLLECTION_GQL,
    RETRIEVE_SOURCES_GQL,
    REVISE_CONTENT_GQL,
    REVISE_ENCODED_IMAGE_GQL,
    REVISE_IMAGE_GQL,
    REVISE_TEXT_GQL,
    SCREENSHOT_PAGE_GQL,
    SEARCH_WEB_GQL,
    SEND_NOTIFICATION_GQL,
    SPECIFICATION_EXISTS_GQL,
    SUGGEST_CONVERSATION_GQL,
    SUMMARIZE_CONTENTS_GQL,
    SUMMARIZE_TEXT_GQL,
    UPDATE_ALERT_GQL,
    UPDATE_CATEGORY_GQL,
    UPDATE_COLLECTION_GQL,
    UPDATE_CONTENT_GQL,
    UPDATE_CONVERSATION_GQL,
    UPDATE_EVENT_GQL,
    UPDATE_FEED_GQL,
    UPDATE_LABEL_GQL,
    UPDATE_MEDICAL_CONDITION_GQL,
    UPDATE_MEDICAL_CONTRAINDICATION_GQL,
    UPDATE_MEDICAL_DEVICE_GQL,
    UPDATE_MEDICAL_DRUG_CLASS_GQL,
    UPDATE_MEDICAL_DRUG_GQL,
    UPDATE_MEDICAL_GUIDELINE_GQL,
    UPDATE_MEDICAL_INDICATION_GQL,
    UPDATE_MEDICAL_PROCEDURE_GQL,
    UPDATE_MEDICAL_STUDY_GQL,
    UPDATE_MEDICAL_TEST_GQL,
    UPDATE_MEDICAL_THERAPY_GQL,
    UPDATE_OBSERVATION_GQL,
    UPDATE_ORGANIZATION_GQL,
    UPDATE_PERSON_GQL,
    UPDATE_PLACE_GQL,
    UPDATE_PRODUCT_GQL,
    UPDATE_PROJECT_GQL,
    UPDATE_REPO_GQL,
    UPDATE_SOFTWARE_GQL,
    UPDATE_SPECIFICATION_GQL,
    UPDATE_USER_GQL,
    UPDATE_WORKFLOW_GQL,
    UPSERT_CATEGORY_GQL,
    UPSERT_LABEL_GQL,
    UPSERT_SPECIFICATION_GQL,
    UPSERT_WORKFLOW_GQL,
    WORKFLOW_EXISTS_GQL,
)
from .prompt import (
    Prompt,
    PromptPrompt,
    PromptPromptMessages,
    PromptPromptMessagesCitations,
    PromptPromptMessagesCitationsContent,
    PromptPromptMessagesCitationsContentAudio,
    PromptPromptMessagesCitationsContentDocument,
    PromptPromptMessagesCitationsContentImage,
    PromptPromptMessagesCitationsContentVideo,
    PromptPromptMessagesToolCalls,
    PromptPromptSpecification,
)
from .prompt_conversation import (
    PromptConversation,
    PromptConversationPromptConversation,
    PromptConversationPromptConversationConversation,
    PromptConversationPromptConversationDetails,
    PromptConversationPromptConversationDetailsMessages,
    PromptConversationPromptConversationDetailsMessagesCitations,
    PromptConversationPromptConversationDetailsMessagesCitationsContent,
    PromptConversationPromptConversationDetailsMessagesCitationsContentAudio,
    PromptConversationPromptConversationDetailsMessagesCitationsContentDocument,
    PromptConversationPromptConversationDetailsMessagesCitationsContentImage,
    PromptConversationPromptConversationDetailsMessagesCitationsContentVideo,
    PromptConversationPromptConversationDetailsMessagesToolCalls,
    PromptConversationPromptConversationFacets,
    PromptConversationPromptConversationFacetsObservable,
    PromptConversationPromptConversationFacetsObservableObservable,
    PromptConversationPromptConversationFacetsRange,
    PromptConversationPromptConversationGraph,
    PromptConversationPromptConversationGraphEdges,
    PromptConversationPromptConversationGraphNodes,
    PromptConversationPromptConversationMessage,
    PromptConversationPromptConversationMessageCitations,
    PromptConversationPromptConversationMessageCitationsContent,
    PromptConversationPromptConversationMessageCitationsContentAudio,
    PromptConversationPromptConversationMessageCitationsContentDocument,
    PromptConversationPromptConversationMessageCitationsContentImage,
    PromptConversationPromptConversationMessageCitationsContentVideo,
    PromptConversationPromptConversationMessageToolCalls,
)
from .prompt_specifications import (
    PromptSpecifications,
    PromptSpecificationsPromptSpecifications,
    PromptSpecificationsPromptSpecificationsMessages,
    PromptSpecificationsPromptSpecificationsMessagesCitations,
    PromptSpecificationsPromptSpecificationsMessagesCitationsContent,
    PromptSpecificationsPromptSpecificationsMessagesCitationsContentAudio,
    PromptSpecificationsPromptSpecificationsMessagesCitationsContentDocument,
    PromptSpecificationsPromptSpecificationsMessagesCitationsContentImage,
    PromptSpecificationsPromptSpecificationsMessagesCitationsContentVideo,
    PromptSpecificationsPromptSpecificationsMessagesToolCalls,
    PromptSpecificationsPromptSpecificationsSpecification,
)
from .publish_contents import (
    PublishContents,
    PublishContentsPublishContents,
    PublishContentsPublishContentsContents,
    PublishContentsPublishContentsContentsAudio,
    PublishContentsPublishContentsContentsDocument,
    PublishContentsPublishContentsContentsImage,
    PublishContentsPublishContentsContentsVideo,
    PublishContentsPublishContentsDetails,
    PublishContentsPublishContentsDetailsContents,
)
from .publish_conversation import (
    PublishConversation,
    PublishConversationPublishConversation,
    PublishConversationPublishConversationContents,
    PublishConversationPublishConversationContentsAudio,
    PublishConversationPublishConversationContentsDocument,
    PublishConversationPublishConversationContentsImage,
    PublishConversationPublishConversationContentsVideo,
    PublishConversationPublishConversationDetails,
    PublishConversationPublishConversationDetailsContents,
)
from .publish_text import (
    PublishText,
    PublishTextPublishText,
    PublishTextPublishTextContents,
    PublishTextPublishTextContentsAudio,
    PublishTextPublishTextContentsDocument,
    PublishTextPublishTextContentsImage,
    PublishTextPublishTextContentsVideo,
    PublishTextPublishTextDetails,
    PublishTextPublishTextDetailsContents,
)
from .query_alerts import (
    QueryAlerts,
    QueryAlertsAlerts,
    QueryAlertsAlertsResults,
    QueryAlertsAlertsResultsFilter,
    QueryAlertsAlertsResultsFilterAnd,
    QueryAlertsAlertsResultsFilterAndCollections,
    QueryAlertsAlertsResultsFilterAndFeeds,
    QueryAlertsAlertsResultsFilterAndObservations,
    QueryAlertsAlertsResultsFilterAndObservationsObservable,
    QueryAlertsAlertsResultsFilterAndUsers,
    QueryAlertsAlertsResultsFilterAndWorkflows,
    QueryAlertsAlertsResultsFilterCollections,
    QueryAlertsAlertsResultsFilterContents,
    QueryAlertsAlertsResultsFilterCreationDateRange,
    QueryAlertsAlertsResultsFilterDateRange,
    QueryAlertsAlertsResultsFilterFeeds,
    QueryAlertsAlertsResultsFilterObservations,
    QueryAlertsAlertsResultsFilterObservationsObservable,
    QueryAlertsAlertsResultsFilterOr,
    QueryAlertsAlertsResultsFilterOrCollections,
    QueryAlertsAlertsResultsFilterOrFeeds,
    QueryAlertsAlertsResultsFilterOrObservations,
    QueryAlertsAlertsResultsFilterOrObservationsObservable,
    QueryAlertsAlertsResultsFilterOrUsers,
    QueryAlertsAlertsResultsFilterOrWorkflows,
    QueryAlertsAlertsResultsFilterSimilarContents,
    QueryAlertsAlertsResultsFilterUsers,
    QueryAlertsAlertsResultsFilterWorkflows,
    QueryAlertsAlertsResultsIntegration,
    QueryAlertsAlertsResultsIntegrationEmail,
    QueryAlertsAlertsResultsIntegrationSlack,
    QueryAlertsAlertsResultsIntegrationTwitter,
    QueryAlertsAlertsResultsOwner,
    QueryAlertsAlertsResultsPublishing,
    QueryAlertsAlertsResultsPublishingElevenLabs,
    QueryAlertsAlertsResultsPublishingOpenAiImage,
    QueryAlertsAlertsResultsPublishingOpenAiImageSeed,
    QueryAlertsAlertsResultsPublishSpecification,
    QueryAlertsAlertsResultsSummarySpecification,
)
from .query_categories import (
    QueryCategories,
    QueryCategoriesCategories,
    QueryCategoriesCategoriesResults,
)
from .query_collections import (
    QueryCollections,
    QueryCollectionsCollections,
    QueryCollectionsCollectionsResults,
    QueryCollectionsCollectionsResultsContents,
    QueryCollectionsCollectionsResultsOwner,
)
from .query_contents import (
    QueryContents,
    QueryContentsContents,
    QueryContentsContentsResults,
    QueryContentsContentsResultsAddress,
    QueryContentsContentsResultsAudio,
    QueryContentsContentsResultsCollections,
    QueryContentsContentsResultsDocument,
    QueryContentsContentsResultsEmail,
    QueryContentsContentsResultsEmailBcc,
    QueryContentsContentsResultsEmailCc,
    QueryContentsContentsResultsEmailFrom,
    QueryContentsContentsResultsEmailTo,
    QueryContentsContentsResultsFeed,
    QueryContentsContentsResultsFrames,
    QueryContentsContentsResultsImage,
    QueryContentsContentsResultsIssue,
    QueryContentsContentsResultsLanguage,
    QueryContentsContentsResultsLinks,
    QueryContentsContentsResultsLocation,
    QueryContentsContentsResultsObservations,
    QueryContentsContentsResultsObservationsObservable,
    QueryContentsContentsResultsObservationsOccurrences,
    QueryContentsContentsResultsObservationsOccurrencesBoundingBox,
    QueryContentsContentsResultsObservationsRelated,
    QueryContentsContentsResultsOwner,
    QueryContentsContentsResultsPackage,
    QueryContentsContentsResultsPages,
    QueryContentsContentsResultsPagesChunks,
    QueryContentsContentsResultsPagesImages,
    QueryContentsContentsResultsSegments,
    QueryContentsContentsResultsVideo,
    QueryContentsContentsResultsWorkflow,
)
from .query_contents_facets import (
    QueryContentsFacets,
    QueryContentsFacetsContents,
    QueryContentsFacetsContentsFacets,
    QueryContentsFacetsContentsFacetsObservable,
    QueryContentsFacetsContentsFacetsObservableObservable,
    QueryContentsFacetsContentsFacetsRange,
)
from .query_contents_graph import (
    QueryContentsGraph,
    QueryContentsGraphContents,
    QueryContentsGraphContentsGraph,
    QueryContentsGraphContentsGraphEdges,
    QueryContentsGraphContentsGraphNodes,
)
from .query_conversations import (
    QueryConversations,
    QueryConversationsConversations,
    QueryConversationsConversationsResults,
    QueryConversationsConversationsResultsAugmentedFilter,
    QueryConversationsConversationsResultsAugmentedFilterAnd,
    QueryConversationsConversationsResultsAugmentedFilterAndCollections,
    QueryConversationsConversationsResultsAugmentedFilterAndFeeds,
    QueryConversationsConversationsResultsAugmentedFilterAndObservations,
    QueryConversationsConversationsResultsAugmentedFilterAndObservationsObservable,
    QueryConversationsConversationsResultsAugmentedFilterAndUsers,
    QueryConversationsConversationsResultsAugmentedFilterAndWorkflows,
    QueryConversationsConversationsResultsAugmentedFilterCollections,
    QueryConversationsConversationsResultsAugmentedFilterContents,
    QueryConversationsConversationsResultsAugmentedFilterCreationDateRange,
    QueryConversationsConversationsResultsAugmentedFilterDateRange,
    QueryConversationsConversationsResultsAugmentedFilterFeeds,
    QueryConversationsConversationsResultsAugmentedFilterObservations,
    QueryConversationsConversationsResultsAugmentedFilterObservationsObservable,
    QueryConversationsConversationsResultsAugmentedFilterOr,
    QueryConversationsConversationsResultsAugmentedFilterOrCollections,
    QueryConversationsConversationsResultsAugmentedFilterOrFeeds,
    QueryConversationsConversationsResultsAugmentedFilterOrObservations,
    QueryConversationsConversationsResultsAugmentedFilterOrObservationsObservable,
    QueryConversationsConversationsResultsAugmentedFilterOrUsers,
    QueryConversationsConversationsResultsAugmentedFilterOrWorkflows,
    QueryConversationsConversationsResultsAugmentedFilterSimilarContents,
    QueryConversationsConversationsResultsAugmentedFilterUsers,
    QueryConversationsConversationsResultsAugmentedFilterWorkflows,
    QueryConversationsConversationsResultsFallbacks,
    QueryConversationsConversationsResultsFilter,
    QueryConversationsConversationsResultsFilterAnd,
    QueryConversationsConversationsResultsFilterAndCollections,
    QueryConversationsConversationsResultsFilterAndFeeds,
    QueryConversationsConversationsResultsFilterAndObservations,
    QueryConversationsConversationsResultsFilterAndObservationsObservable,
    QueryConversationsConversationsResultsFilterAndUsers,
    QueryConversationsConversationsResultsFilterAndWorkflows,
    QueryConversationsConversationsResultsFilterCollections,
    QueryConversationsConversationsResultsFilterContents,
    QueryConversationsConversationsResultsFilterCreationDateRange,
    QueryConversationsConversationsResultsFilterDateRange,
    QueryConversationsConversationsResultsFilterFeeds,
    QueryConversationsConversationsResultsFilterObservations,
    QueryConversationsConversationsResultsFilterObservationsObservable,
    QueryConversationsConversationsResultsFilterOr,
    QueryConversationsConversationsResultsFilterOrCollections,
    QueryConversationsConversationsResultsFilterOrFeeds,
    QueryConversationsConversationsResultsFilterOrObservations,
    QueryConversationsConversationsResultsFilterOrObservationsObservable,
    QueryConversationsConversationsResultsFilterOrUsers,
    QueryConversationsConversationsResultsFilterOrWorkflows,
    QueryConversationsConversationsResultsFilterSimilarContents,
    QueryConversationsConversationsResultsFilterUsers,
    QueryConversationsConversationsResultsFilterWorkflows,
    QueryConversationsConversationsResultsMessages,
    QueryConversationsConversationsResultsMessagesCitations,
    QueryConversationsConversationsResultsMessagesCitationsContent,
    QueryConversationsConversationsResultsMessagesCitationsContentAudio,
    QueryConversationsConversationsResultsMessagesCitationsContentDocument,
    QueryConversationsConversationsResultsMessagesCitationsContentImage,
    QueryConversationsConversationsResultsMessagesCitationsContentVideo,
    QueryConversationsConversationsResultsMessagesToolCalls,
    QueryConversationsConversationsResultsOwner,
    QueryConversationsConversationsResultsSpecification,
)
from .query_credits import QueryCredits, QueryCreditsCredits
from .query_events import (
    QueryEvents,
    QueryEventsEvents,
    QueryEventsEventsResults,
    QueryEventsEventsResultsAddress,
)
from .query_feeds import (
    QueryFeeds,
    QueryFeedsFeeds,
    QueryFeedsFeedsResults,
    QueryFeedsFeedsResultsDiscord,
    QueryFeedsFeedsResultsEmail,
    QueryFeedsFeedsResultsEmailGoogle,
    QueryFeedsFeedsResultsEmailMicrosoft,
    QueryFeedsFeedsResultsIntercom,
    QueryFeedsFeedsResultsIssue,
    QueryFeedsFeedsResultsIssueGithub,
    QueryFeedsFeedsResultsIssueIntercom,
    QueryFeedsFeedsResultsIssueJira,
    QueryFeedsFeedsResultsIssueLinear,
    QueryFeedsFeedsResultsIssueTrello,
    QueryFeedsFeedsResultsIssueZendesk,
    QueryFeedsFeedsResultsMicrosoftTeams,
    QueryFeedsFeedsResultsNotion,
    QueryFeedsFeedsResultsOwner,
    QueryFeedsFeedsResultsReddit,
    QueryFeedsFeedsResultsRss,
    QueryFeedsFeedsResultsSchedulePolicy,
    QueryFeedsFeedsResultsSearch,
    QueryFeedsFeedsResultsSite,
    QueryFeedsFeedsResultsSiteAzureBlob,
    QueryFeedsFeedsResultsSiteAzureFile,
    QueryFeedsFeedsResultsSiteBox,
    QueryFeedsFeedsResultsSiteDropbox,
    QueryFeedsFeedsResultsSiteGithub,
    QueryFeedsFeedsResultsSiteGoogle,
    QueryFeedsFeedsResultsSiteGoogleDrive,
    QueryFeedsFeedsResultsSiteOneDrive,
    QueryFeedsFeedsResultsSiteS3,
    QueryFeedsFeedsResultsSiteSharePoint,
    QueryFeedsFeedsResultsSlack,
    QueryFeedsFeedsResultsTwitter,
    QueryFeedsFeedsResultsWeb,
    QueryFeedsFeedsResultsWorkflow,
    QueryFeedsFeedsResultsYoutube,
    QueryFeedsFeedsResultsZendesk,
)
from .query_labels import QueryLabels, QueryLabelsLabels, QueryLabelsLabelsResults
from .query_linear_projects import (
    QueryLinearProjects,
    QueryLinearProjectsLinearProjects,
)
from .query_medical_conditions import (
    QueryMedicalConditions,
    QueryMedicalConditionsMedicalConditions,
    QueryMedicalConditionsMedicalConditionsResults,
)
from .query_medical_contraindications import (
    QueryMedicalContraindications,
    QueryMedicalContraindicationsMedicalContraindications,
    QueryMedicalContraindicationsMedicalContraindicationsResults,
)
from .query_medical_devices import (
    QueryMedicalDevices,
    QueryMedicalDevicesMedicalDevices,
    QueryMedicalDevicesMedicalDevicesResults,
)
from .query_medical_drug_classes import (
    QueryMedicalDrugClasses,
    QueryMedicalDrugClassesMedicalDrugClasses,
    QueryMedicalDrugClassesMedicalDrugClassesResults,
)
from .query_medical_drugs import (
    QueryMedicalDrugs,
    QueryMedicalDrugsMedicalDrugs,
    QueryMedicalDrugsMedicalDrugsResults,
)
from .query_medical_guidelines import (
    QueryMedicalGuidelines,
    QueryMedicalGuidelinesMedicalGuidelines,
    QueryMedicalGuidelinesMedicalGuidelinesResults,
)
from .query_medical_indications import (
    QueryMedicalIndications,
    QueryMedicalIndicationsMedicalIndications,
    QueryMedicalIndicationsMedicalIndicationsResults,
)
from .query_medical_procedures import (
    QueryMedicalProcedures,
    QueryMedicalProceduresMedicalProcedures,
    QueryMedicalProceduresMedicalProceduresResults,
)
from .query_medical_studies import (
    QueryMedicalStudies,
    QueryMedicalStudiesMedicalStudies,
    QueryMedicalStudiesMedicalStudiesResults,
    QueryMedicalStudiesMedicalStudiesResultsAddress,
)
from .query_medical_tests import (
    QueryMedicalTests,
    QueryMedicalTestsMedicalTests,
    QueryMedicalTestsMedicalTestsResults,
)
from .query_medical_therapies import (
    QueryMedicalTherapies,
    QueryMedicalTherapiesMedicalTherapies,
    QueryMedicalTherapiesMedicalTherapiesResults,
)
from .query_microsoft_teams_channels import (
    QueryMicrosoftTeamsChannels,
    QueryMicrosoftTeamsChannelsMicrosoftTeamsChannels,
    QueryMicrosoftTeamsChannelsMicrosoftTeamsChannelsResults,
)
from .query_microsoft_teams_teams import (
    QueryMicrosoftTeamsTeams,
    QueryMicrosoftTeamsTeamsMicrosoftTeamsTeams,
    QueryMicrosoftTeamsTeamsMicrosoftTeamsTeamsResults,
)
from .query_models import (
    QueryModels,
    QueryModelsModels,
    QueryModelsModelsResults,
    QueryModelsModelsResultsFeatures,
    QueryModelsModelsResultsMetadata,
)
from .query_notion_databases import (
    QueryNotionDatabases,
    QueryNotionDatabasesNotionDatabases,
)
from .query_notion_pages import QueryNotionPages, QueryNotionPagesNotionPages
from .query_one_drive_folders import (
    QueryOneDriveFolders,
    QueryOneDriveFoldersOneDriveFolders,
    QueryOneDriveFoldersOneDriveFoldersResults,
)
from .query_organizations import (
    QueryOrganizations,
    QueryOrganizationsOrganizations,
    QueryOrganizationsOrganizationsResults,
    QueryOrganizationsOrganizationsResultsAddress,
)
from .query_persons import (
    QueryPersons,
    QueryPersonsPersons,
    QueryPersonsPersonsResults,
    QueryPersonsPersonsResultsAddress,
)
from .query_places import (
    QueryPlaces,
    QueryPlacesPlaces,
    QueryPlacesPlacesResults,
    QueryPlacesPlacesResultsAddress,
)
from .query_products import (
    QueryProducts,
    QueryProductsProducts,
    QueryProductsProductsResults,
    QueryProductsProductsResultsAddress,
)
from .query_repos import QueryRepos, QueryReposRepos, QueryReposReposResults
from .query_share_point_folders import (
    QuerySharePointFolders,
    QuerySharePointFoldersSharePointFolders,
    QuerySharePointFoldersSharePointFoldersResults,
)
from .query_share_point_libraries import (
    QuerySharePointLibraries,
    QuerySharePointLibrariesSharePointLibraries,
    QuerySharePointLibrariesSharePointLibrariesResults,
)
from .query_slack_channels import QuerySlackChannels, QuerySlackChannelsSlackChannels
from .query_softwares import (
    QuerySoftwares,
    QuerySoftwaresSoftwares,
    QuerySoftwaresSoftwaresResults,
)
from .query_specifications import (
    QuerySpecifications,
    QuerySpecificationsSpecifications,
    QuerySpecificationsSpecificationsResults,
    QuerySpecificationsSpecificationsResultsAnthropic,
    QuerySpecificationsSpecificationsResultsAzureAi,
    QuerySpecificationsSpecificationsResultsAzureOpenAi,
    QuerySpecificationsSpecificationsResultsBedrock,
    QuerySpecificationsSpecificationsResultsCerebras,
    QuerySpecificationsSpecificationsResultsCohere,
    QuerySpecificationsSpecificationsResultsDeepseek,
    QuerySpecificationsSpecificationsResultsGoogle,
    QuerySpecificationsSpecificationsResultsGraphStrategy,
    QuerySpecificationsSpecificationsResultsGroq,
    QuerySpecificationsSpecificationsResultsJina,
    QuerySpecificationsSpecificationsResultsMistral,
    QuerySpecificationsSpecificationsResultsOpenAi,
    QuerySpecificationsSpecificationsResultsOwner,
    QuerySpecificationsSpecificationsResultsPromptStrategy,
    QuerySpecificationsSpecificationsResultsReplicate,
    QuerySpecificationsSpecificationsResultsRerankingStrategy,
    QuerySpecificationsSpecificationsResultsRetrievalStrategy,
    QuerySpecificationsSpecificationsResultsRevisionStrategy,
    QuerySpecificationsSpecificationsResultsStrategy,
    QuerySpecificationsSpecificationsResultsVoyage,
)
from .query_tokens import QueryTokens, QueryTokensTokens
from .query_usage import QueryUsage, QueryUsageUsage
from .query_users import (
    QueryUsers,
    QueryUsersUsers,
    QueryUsersUsersResults,
    QueryUsersUsersResultsConnectors,
    QueryUsersUsersResultsConnectorsAuthentication,
    QueryUsersUsersResultsConnectorsAuthenticationGoogle,
    QueryUsersUsersResultsConnectorsAuthenticationMicrosoft,
    QueryUsersUsersResultsConnectorsIntegration,
    QueryUsersUsersResultsConnectorsIntegrationEmail,
    QueryUsersUsersResultsConnectorsIntegrationSlack,
    QueryUsersUsersResultsConnectorsIntegrationTwitter,
    QueryUsersUsersResultsOwner,
)
from .query_workflows import (
    QueryWorkflows,
    QueryWorkflowsWorkflows,
    QueryWorkflowsWorkflowsResults,
    QueryWorkflowsWorkflowsResultsActions,
    QueryWorkflowsWorkflowsResultsActionsConnector,
    QueryWorkflowsWorkflowsResultsActionsConnectorEmail,
    QueryWorkflowsWorkflowsResultsActionsConnectorSlack,
    QueryWorkflowsWorkflowsResultsActionsConnectorTwitter,
    QueryWorkflowsWorkflowsResultsClassification,
    QueryWorkflowsWorkflowsResultsClassificationJobs,
    QueryWorkflowsWorkflowsResultsClassificationJobsConnector,
    QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModel,
    QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModelRules,
    QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModelSpecification,
    QueryWorkflowsWorkflowsResultsClassificationJobsConnectorRegex,
    QueryWorkflowsWorkflowsResultsClassificationJobsConnectorRegexRules,
    QueryWorkflowsWorkflowsResultsEnrichment,
    QueryWorkflowsWorkflowsResultsEnrichmentJobs,
    QueryWorkflowsWorkflowsResultsEnrichmentJobsConnector,
    QueryWorkflowsWorkflowsResultsEnrichmentJobsConnectorDiffbot,
    QueryWorkflowsWorkflowsResultsEnrichmentJobsConnectorFhir,
    QueryWorkflowsWorkflowsResultsEnrichmentLink,
    QueryWorkflowsWorkflowsResultsExtraction,
    QueryWorkflowsWorkflowsResultsExtractionJobs,
    QueryWorkflowsWorkflowsResultsExtractionJobsConnector,
    QueryWorkflowsWorkflowsResultsExtractionJobsConnectorAzureImage,
    QueryWorkflowsWorkflowsResultsExtractionJobsConnectorAzureText,
    QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelImage,
    QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelImageSpecification,
    QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelText,
    QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelTextSpecification,
    QueryWorkflowsWorkflowsResultsIndexing,
    QueryWorkflowsWorkflowsResultsIndexingJobs,
    QueryWorkflowsWorkflowsResultsIndexingJobsConnector,
    QueryWorkflowsWorkflowsResultsIngestion,
    QueryWorkflowsWorkflowsResultsIngestionCollections,
    QueryWorkflowsWorkflowsResultsIngestionIf,
    QueryWorkflowsWorkflowsResultsIngestionObservations,
    QueryWorkflowsWorkflowsResultsIngestionObservationsObservable,
    QueryWorkflowsWorkflowsResultsOwner,
    QueryWorkflowsWorkflowsResultsPreparation,
    QueryWorkflowsWorkflowsResultsPreparationJobs,
    QueryWorkflowsWorkflowsResultsPreparationJobsConnector,
    QueryWorkflowsWorkflowsResultsPreparationJobsConnectorAssemblyAi,
    QueryWorkflowsWorkflowsResultsPreparationJobsConnectorAzureDocument,
    QueryWorkflowsWorkflowsResultsPreparationJobsConnectorDeepgram,
    QueryWorkflowsWorkflowsResultsPreparationJobsConnectorDocument,
    QueryWorkflowsWorkflowsResultsPreparationJobsConnectorEmail,
    QueryWorkflowsWorkflowsResultsPreparationJobsConnectorMistral,
    QueryWorkflowsWorkflowsResultsPreparationJobsConnectorModelDocument,
    QueryWorkflowsWorkflowsResultsPreparationJobsConnectorModelDocumentSpecification,
    QueryWorkflowsWorkflowsResultsPreparationJobsConnectorPage,
    QueryWorkflowsWorkflowsResultsPreparationSummarizations,
    QueryWorkflowsWorkflowsResultsPreparationSummarizationsSpecification,
    QueryWorkflowsWorkflowsResultsStorage,
    QueryWorkflowsWorkflowsResultsStoragePolicy,
)
from .remove_contents_from_collection import (
    RemoveContentsFromCollection,
    RemoveContentsFromCollectionRemoveContentsFromCollection,
    RemoveContentsFromCollectionRemoveContentsFromCollectionContents,
)
from .retrieve_sources import (
    RetrieveSources,
    RetrieveSourcesRetrieveSources,
    RetrieveSourcesRetrieveSourcesResults,
    RetrieveSourcesRetrieveSourcesResultsContent,
)
from .revise_content import (
    ReviseContent,
    ReviseContentReviseContent,
    ReviseContentReviseContentConversation,
    ReviseContentReviseContentMessage,
    ReviseContentReviseContentMessageCitations,
    ReviseContentReviseContentMessageCitationsContent,
    ReviseContentReviseContentMessageCitationsContentAudio,
    ReviseContentReviseContentMessageCitationsContentDocument,
    ReviseContentReviseContentMessageCitationsContentImage,
    ReviseContentReviseContentMessageCitationsContentVideo,
    ReviseContentReviseContentMessageToolCalls,
)
from .revise_encoded_image import (
    ReviseEncodedImage,
    ReviseEncodedImageReviseEncodedImage,
    ReviseEncodedImageReviseEncodedImageConversation,
    ReviseEncodedImageReviseEncodedImageMessage,
    ReviseEncodedImageReviseEncodedImageMessageCitations,
    ReviseEncodedImageReviseEncodedImageMessageCitationsContent,
    ReviseEncodedImageReviseEncodedImageMessageCitationsContentAudio,
    ReviseEncodedImageReviseEncodedImageMessageCitationsContentDocument,
    ReviseEncodedImageReviseEncodedImageMessageCitationsContentImage,
    ReviseEncodedImageReviseEncodedImageMessageCitationsContentVideo,
    ReviseEncodedImageReviseEncodedImageMessageToolCalls,
)
from .revise_image import (
    ReviseImage,
    ReviseImageReviseImage,
    ReviseImageReviseImageConversation,
    ReviseImageReviseImageMessage,
    ReviseImageReviseImageMessageCitations,
    ReviseImageReviseImageMessageCitationsContent,
    ReviseImageReviseImageMessageCitationsContentAudio,
    ReviseImageReviseImageMessageCitationsContentDocument,
    ReviseImageReviseImageMessageCitationsContentImage,
    ReviseImageReviseImageMessageCitationsContentVideo,
    ReviseImageReviseImageMessageToolCalls,
)
from .revise_text import (
    ReviseText,
    ReviseTextReviseText,
    ReviseTextReviseTextConversation,
    ReviseTextReviseTextMessage,
    ReviseTextReviseTextMessageCitations,
    ReviseTextReviseTextMessageCitationsContent,
    ReviseTextReviseTextMessageCitationsContentAudio,
    ReviseTextReviseTextMessageCitationsContentDocument,
    ReviseTextReviseTextMessageCitationsContentImage,
    ReviseTextReviseTextMessageCitationsContentVideo,
    ReviseTextReviseTextMessageToolCalls,
)
from .screenshot_page import (
    ScreenshotPage,
    ScreenshotPageScreenshotPage,
    ScreenshotPageScreenshotPageCollections,
    ScreenshotPageScreenshotPageObservations,
    ScreenshotPageScreenshotPageObservationsObservable,
    ScreenshotPageScreenshotPageObservationsOccurrences,
    ScreenshotPageScreenshotPageObservationsOccurrencesBoundingBox,
    ScreenshotPageScreenshotPageObservationsRelated,
)
from .search_web import SearchWeb, SearchWebSearchWeb, SearchWebSearchWebResults
from .send_notification import SendNotification, SendNotificationSendNotification
from .specification_exists import (
    SpecificationExists,
    SpecificationExistsSpecificationExists,
)
from .suggest_conversation import (
    SuggestConversation,
    SuggestConversationSuggestConversation,
)
from .summarize_contents import (
    SummarizeContents,
    SummarizeContentsSummarizeContents,
    SummarizeContentsSummarizeContentsContent,
    SummarizeContentsSummarizeContentsItems,
    SummarizeContentsSummarizeContentsSpecification,
)
from .summarize_text import (
    SummarizeText,
    SummarizeTextSummarizeText,
    SummarizeTextSummarizeTextContent,
    SummarizeTextSummarizeTextItems,
    SummarizeTextSummarizeTextSpecification,
)
from .update_alert import UpdateAlert, UpdateAlertUpdateAlert
from .update_category import UpdateCategory, UpdateCategoryUpdateCategory
from .update_collection import UpdateCollection, UpdateCollectionUpdateCollection
from .update_content import (
    UpdateContent,
    UpdateContentUpdateContent,
    UpdateContentUpdateContentCollections,
    UpdateContentUpdateContentObservations,
    UpdateContentUpdateContentObservationsObservable,
    UpdateContentUpdateContentObservationsOccurrences,
    UpdateContentUpdateContentObservationsOccurrencesBoundingBox,
    UpdateContentUpdateContentObservationsRelated,
)
from .update_conversation import (
    UpdateConversation,
    UpdateConversationUpdateConversation,
)
from .update_event import UpdateEvent, UpdateEventUpdateEvent
from .update_feed import UpdateFeed, UpdateFeedUpdateFeed
from .update_label import UpdateLabel, UpdateLabelUpdateLabel
from .update_medical_condition import (
    UpdateMedicalCondition,
    UpdateMedicalConditionUpdateMedicalCondition,
)
from .update_medical_contraindication import (
    UpdateMedicalContraindication,
    UpdateMedicalContraindicationUpdateMedicalContraindication,
)
from .update_medical_device import (
    UpdateMedicalDevice,
    UpdateMedicalDeviceUpdateMedicalDevice,
)
from .update_medical_drug import UpdateMedicalDrug, UpdateMedicalDrugUpdateMedicalDrug
from .update_medical_drug_class import (
    UpdateMedicalDrugClass,
    UpdateMedicalDrugClassUpdateMedicalDrugClass,
)
from .update_medical_guideline import (
    UpdateMedicalGuideline,
    UpdateMedicalGuidelineUpdateMedicalGuideline,
)
from .update_medical_indication import (
    UpdateMedicalIndication,
    UpdateMedicalIndicationUpdateMedicalIndication,
)
from .update_medical_procedure import (
    UpdateMedicalProcedure,
    UpdateMedicalProcedureUpdateMedicalProcedure,
)
from .update_medical_study import (
    UpdateMedicalStudy,
    UpdateMedicalStudyUpdateMedicalStudy,
)
from .update_medical_test import UpdateMedicalTest, UpdateMedicalTestUpdateMedicalTest
from .update_medical_therapy import (
    UpdateMedicalTherapy,
    UpdateMedicalTherapyUpdateMedicalTherapy,
)
from .update_observation import UpdateObservation, UpdateObservationUpdateObservation
from .update_organization import (
    UpdateOrganization,
    UpdateOrganizationUpdateOrganization,
)
from .update_person import UpdatePerson, UpdatePersonUpdatePerson
from .update_place import UpdatePlace, UpdatePlaceUpdatePlace
from .update_product import UpdateProduct, UpdateProductUpdateProduct
from .update_project import UpdateProject, UpdateProjectUpdateProject
from .update_repo import UpdateRepo, UpdateRepoUpdateRepo
from .update_software import UpdateSoftware, UpdateSoftwareUpdateSoftware
from .update_specification import (
    UpdateSpecification,
    UpdateSpecificationUpdateSpecification,
)
from .update_user import UpdateUser, UpdateUserUpdateUser
from .update_workflow import (
    UpdateWorkflow,
    UpdateWorkflowUpdateWorkflow,
    UpdateWorkflowUpdateWorkflowActions,
    UpdateWorkflowUpdateWorkflowActionsConnector,
    UpdateWorkflowUpdateWorkflowActionsConnectorEmail,
    UpdateWorkflowUpdateWorkflowActionsConnectorSlack,
    UpdateWorkflowUpdateWorkflowActionsConnectorTwitter,
    UpdateWorkflowUpdateWorkflowClassification,
    UpdateWorkflowUpdateWorkflowClassificationJobs,
    UpdateWorkflowUpdateWorkflowClassificationJobsConnector,
    UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModel,
    UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModelRules,
    UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModelSpecification,
    UpdateWorkflowUpdateWorkflowClassificationJobsConnectorRegex,
    UpdateWorkflowUpdateWorkflowClassificationJobsConnectorRegexRules,
    UpdateWorkflowUpdateWorkflowEnrichment,
    UpdateWorkflowUpdateWorkflowEnrichmentJobs,
    UpdateWorkflowUpdateWorkflowEnrichmentJobsConnector,
    UpdateWorkflowUpdateWorkflowEnrichmentJobsConnectorDiffbot,
    UpdateWorkflowUpdateWorkflowEnrichmentJobsConnectorFhir,
    UpdateWorkflowUpdateWorkflowEnrichmentLink,
    UpdateWorkflowUpdateWorkflowExtraction,
    UpdateWorkflowUpdateWorkflowExtractionJobs,
    UpdateWorkflowUpdateWorkflowExtractionJobsConnector,
    UpdateWorkflowUpdateWorkflowExtractionJobsConnectorAzureImage,
    UpdateWorkflowUpdateWorkflowExtractionJobsConnectorAzureText,
    UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelImage,
    UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelImageSpecification,
    UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelText,
    UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelTextSpecification,
    UpdateWorkflowUpdateWorkflowIndexing,
    UpdateWorkflowUpdateWorkflowIndexingJobs,
    UpdateWorkflowUpdateWorkflowIndexingJobsConnector,
    UpdateWorkflowUpdateWorkflowIngestion,
    UpdateWorkflowUpdateWorkflowIngestionCollections,
    UpdateWorkflowUpdateWorkflowIngestionIf,
    UpdateWorkflowUpdateWorkflowIngestionObservations,
    UpdateWorkflowUpdateWorkflowIngestionObservationsObservable,
    UpdateWorkflowUpdateWorkflowPreparation,
    UpdateWorkflowUpdateWorkflowPreparationJobs,
    UpdateWorkflowUpdateWorkflowPreparationJobsConnector,
    UpdateWorkflowUpdateWorkflowPreparationJobsConnectorAssemblyAi,
    UpdateWorkflowUpdateWorkflowPreparationJobsConnectorAzureDocument,
    UpdateWorkflowUpdateWorkflowPreparationJobsConnectorDeepgram,
    UpdateWorkflowUpdateWorkflowPreparationJobsConnectorDocument,
    UpdateWorkflowUpdateWorkflowPreparationJobsConnectorEmail,
    UpdateWorkflowUpdateWorkflowPreparationJobsConnectorMistral,
    UpdateWorkflowUpdateWorkflowPreparationJobsConnectorModelDocument,
    UpdateWorkflowUpdateWorkflowPreparationJobsConnectorModelDocumentSpecification,
    UpdateWorkflowUpdateWorkflowPreparationJobsConnectorPage,
    UpdateWorkflowUpdateWorkflowPreparationSummarizations,
    UpdateWorkflowUpdateWorkflowPreparationSummarizationsSpecification,
    UpdateWorkflowUpdateWorkflowStorage,
    UpdateWorkflowUpdateWorkflowStoragePolicy,
)
from .upsert_category import UpsertCategory, UpsertCategoryUpsertCategory
from .upsert_label import UpsertLabel, UpsertLabelUpsertLabel
from .upsert_specification import (
    UpsertSpecification,
    UpsertSpecificationUpsertSpecification,
)
from .upsert_workflow import (
    UpsertWorkflow,
    UpsertWorkflowUpsertWorkflow,
    UpsertWorkflowUpsertWorkflowActions,
    UpsertWorkflowUpsertWorkflowActionsConnector,
    UpsertWorkflowUpsertWorkflowActionsConnectorEmail,
    UpsertWorkflowUpsertWorkflowActionsConnectorSlack,
    UpsertWorkflowUpsertWorkflowActionsConnectorTwitter,
    UpsertWorkflowUpsertWorkflowClassification,
    UpsertWorkflowUpsertWorkflowClassificationJobs,
    UpsertWorkflowUpsertWorkflowClassificationJobsConnector,
    UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModel,
    UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModelRules,
    UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModelSpecification,
    UpsertWorkflowUpsertWorkflowClassificationJobsConnectorRegex,
    UpsertWorkflowUpsertWorkflowClassificationJobsConnectorRegexRules,
    UpsertWorkflowUpsertWorkflowEnrichment,
    UpsertWorkflowUpsertWorkflowEnrichmentJobs,
    UpsertWorkflowUpsertWorkflowEnrichmentJobsConnector,
    UpsertWorkflowUpsertWorkflowEnrichmentJobsConnectorDiffbot,
    UpsertWorkflowUpsertWorkflowEnrichmentJobsConnectorFhir,
    UpsertWorkflowUpsertWorkflowEnrichmentLink,
    UpsertWorkflowUpsertWorkflowExtraction,
    UpsertWorkflowUpsertWorkflowExtractionJobs,
    UpsertWorkflowUpsertWorkflowExtractionJobsConnector,
    UpsertWorkflowUpsertWorkflowExtractionJobsConnectorAzureImage,
    UpsertWorkflowUpsertWorkflowExtractionJobsConnectorAzureText,
    UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelImage,
    UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelImageSpecification,
    UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelText,
    UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelTextSpecification,
    UpsertWorkflowUpsertWorkflowIndexing,
    UpsertWorkflowUpsertWorkflowIndexingJobs,
    UpsertWorkflowUpsertWorkflowIndexingJobsConnector,
    UpsertWorkflowUpsertWorkflowIngestion,
    UpsertWorkflowUpsertWorkflowIngestionCollections,
    UpsertWorkflowUpsertWorkflowIngestionIf,
    UpsertWorkflowUpsertWorkflowIngestionObservations,
    UpsertWorkflowUpsertWorkflowIngestionObservationsObservable,
    UpsertWorkflowUpsertWorkflowPreparation,
    UpsertWorkflowUpsertWorkflowPreparationJobs,
    UpsertWorkflowUpsertWorkflowPreparationJobsConnector,
    UpsertWorkflowUpsertWorkflowPreparationJobsConnectorAssemblyAi,
    UpsertWorkflowUpsertWorkflowPreparationJobsConnectorAzureDocument,
    UpsertWorkflowUpsertWorkflowPreparationJobsConnectorDeepgram,
    UpsertWorkflowUpsertWorkflowPreparationJobsConnectorDocument,
    UpsertWorkflowUpsertWorkflowPreparationJobsConnectorEmail,
    UpsertWorkflowUpsertWorkflowPreparationJobsConnectorMistral,
    UpsertWorkflowUpsertWorkflowPreparationJobsConnectorModelDocument,
    UpsertWorkflowUpsertWorkflowPreparationJobsConnectorModelDocumentSpecification,
    UpsertWorkflowUpsertWorkflowPreparationJobsConnectorPage,
    UpsertWorkflowUpsertWorkflowPreparationSummarizations,
    UpsertWorkflowUpsertWorkflowPreparationSummarizationsSpecification,
    UpsertWorkflowUpsertWorkflowStorage,
    UpsertWorkflowUpsertWorkflowStoragePolicy,
)
from .workflow_exists import WorkflowExists, WorkflowExistsWorkflowExists

__all__ = [
    "ADD_CONTENTS_TO_COLLECTIONS_GQL",
    "ASK_GRAPHLIT_GQL",
    "AddContentsToCollections",
    "AddContentsToCollectionsAddContentsToCollections",
    "AddContentsToCollectionsAddContentsToCollectionsContents",
    "AddressFilter",
    "AddressInput",
    "AlertFilter",
    "AlertInput",
    "AlertSchedulePolicyInput",
    "AlertTypes",
    "AlertUpdateInput",
    "AmazonFeedPropertiesInput",
    "AmazonFeedPropertiesUpdateInput",
    "AnthropicModelPropertiesInput",
    "AnthropicModelPropertiesUpdateInput",
    "AnthropicModels",
    "ApplyPolicy",
    "AskGraphlit",
    "AskGraphlitAskGraphlit",
    "AskGraphlitAskGraphlitConversation",
    "AskGraphlitAskGraphlitMessage",
    "AskGraphlitAskGraphlitMessageCitations",
    "AskGraphlitAskGraphlitMessageCitationsContent",
    "AskGraphlitAskGraphlitMessageCitationsContentAudio",
    "AskGraphlitAskGraphlitMessageCitationsContentDocument",
    "AskGraphlitAskGraphlitMessageCitationsContentImage",
    "AskGraphlitAskGraphlitMessageCitationsContentVideo",
    "AskGraphlitAskGraphlitMessageToolCalls",
    "AssemblyAIAudioPreparationPropertiesInput",
    "AssemblyAIModels",
    "AsyncBaseClient",
    "AtlassianJiraFeedPropertiesInput",
    "AtlassianJiraFeedPropertiesUpdateInput",
    "AudioMetadataInput",
    "AuthenticationConnectorInput",
    "AuthenticationServiceTypes",
    "AzureAIModelPropertiesInput",
    "AzureAIModelPropertiesUpdateInput",
    "AzureBlobFeedPropertiesInput",
    "AzureBlobFeedPropertiesUpdateInput",
    "AzureDocumentIntelligenceModels",
    "AzureDocumentIntelligenceVersions",
    "AzureDocumentPreparationPropertiesInput",
    "AzureFileFeedPropertiesInput",
    "AzureFileFeedPropertiesUpdateInput",
    "AzureImageExtractionPropertiesInput",
    "AzureOpenAIModelPropertiesInput",
    "AzureOpenAIModelPropertiesUpdateInput",
    "AzureOpenAIModels",
    "AzureTextExtractionPropertiesInput",
    "BaseModel",
    "BedrockModelPropertiesInput",
    "BedrockModelPropertiesUpdateInput",
    "BedrockModels",
    "BillableMetrics",
    "BoundingBoxInput",
    "BoxFeedPropertiesInput",
    "BoxFeedPropertiesUpdateInput",
    "CLEAR_CONVERSATION_GQL",
    "CLOSE_CONVERSATION_GQL",
    "COMPLETE_CONVERSATION_GQL",
    "CONTINUE_CONVERSATION_GQL",
    "COUNT_ALERTS_GQL",
    "COUNT_CATEGORIES_GQL",
    "COUNT_COLLECTIONS_GQL",
    "COUNT_CONTENTS_GQL",
    "COUNT_CONVERSATIONS_GQL",
    "COUNT_EVENTS_GQL",
    "COUNT_FEEDS_GQL",
    "COUNT_LABELS_GQL",
    "COUNT_MEDICAL_CONDITIONS_GQL",
    "COUNT_MEDICAL_CONTRAINDICATIONS_GQL",
    "COUNT_MEDICAL_DEVICES_GQL",
    "COUNT_MEDICAL_DRUGS_GQL",
    "COUNT_MEDICAL_DRUG_CLASSES_GQL",
    "COUNT_MEDICAL_GUIDELINES_GQL",
    "COUNT_MEDICAL_INDICATIONS_GQL",
    "COUNT_MEDICAL_PROCEDURES_GQL",
    "COUNT_MEDICAL_STUDIES_GQL",
    "COUNT_MEDICAL_TESTS_GQL",
    "COUNT_MEDICAL_THERAPIES_GQL",
    "COUNT_ORGANIZATIONS_GQL",
    "COUNT_PERSONS_GQL",
    "COUNT_PLACES_GQL",
    "COUNT_PRODUCTS_GQL",
    "COUNT_REPOS_GQL",
    "COUNT_SOFTWARES_GQL",
    "COUNT_SPECIFICATIONS_GQL",
    "COUNT_USERS_GQL",
    "COUNT_WORKFLOWS_GQL",
    "CREATE_ALERT_GQL",
    "CREATE_CATEGORY_GQL",
    "CREATE_COLLECTION_GQL",
    "CREATE_CONVERSATION_GQL",
    "CREATE_EVENT_GQL",
    "CREATE_FEED_GQL",
    "CREATE_LABEL_GQL",
    "CREATE_MEDICAL_CONDITION_GQL",
    "CREATE_MEDICAL_CONTRAINDICATION_GQL",
    "CREATE_MEDICAL_DEVICE_GQL",
    "CREATE_MEDICAL_DRUG_CLASS_GQL",
    "CREATE_MEDICAL_DRUG_GQL",
    "CREATE_MEDICAL_GUIDELINE_GQL",
    "CREATE_MEDICAL_INDICATION_GQL",
    "CREATE_MEDICAL_PROCEDURE_GQL",
    "CREATE_MEDICAL_STUDY_GQL",
    "CREATE_MEDICAL_TEST_GQL",
    "CREATE_MEDICAL_THERAPY_GQL",
    "CREATE_OBSERVATION_GQL",
    "CREATE_ORGANIZATION_GQL",
    "CREATE_PERSON_GQL",
    "CREATE_PLACE_GQL",
    "CREATE_PRODUCT_GQL",
    "CREATE_REPO_GQL",
    "CREATE_SOFTWARE_GQL",
    "CREATE_SPECIFICATION_GQL",
    "CREATE_USER_GQL",
    "CREATE_WORKFLOW_GQL",
    "CategoryFacetInput",
    "CategoryFacetTypes",
    "CategoryFilter",
    "CategoryInput",
    "CategoryUpdateInput",
    "CerebrasModelPropertiesInput",
    "CerebrasModelPropertiesUpdateInput",
    "CerebrasModels",
    "ClassificationWorkflowJobInput",
    "ClassificationWorkflowStageInput",
    "ClearConversation",
    "ClearConversationClearConversation",
    "Client",
    "CloseConversation",
    "CloseConversationCloseConversation",
    "CohereModelPropertiesInput",
    "CohereModelPropertiesUpdateInput",
    "CohereModels",
    "CollectionFilter",
    "CollectionInput",
    "CollectionTypes",
    "CollectionUpdateInput",
    "CompleteConversation",
    "CompleteConversationCompleteConversation",
    "CompleteConversationCompleteConversationConversation",
    "CompleteConversationCompleteConversationDetails",
    "CompleteConversationCompleteConversationDetailsMessages",
    "CompleteConversationCompleteConversationDetailsMessagesCitations",
    "CompleteConversationCompleteConversationDetailsMessagesCitationsContent",
    "CompleteConversationCompleteConversationDetailsMessagesCitationsContentAudio",
    "CompleteConversationCompleteConversationDetailsMessagesCitationsContentDocument",
    "CompleteConversationCompleteConversationDetailsMessagesCitationsContentImage",
    "CompleteConversationCompleteConversationDetailsMessagesCitationsContentVideo",
    "CompleteConversationCompleteConversationDetailsMessagesToolCalls",
    "CompleteConversationCompleteConversationFacets",
    "CompleteConversationCompleteConversationFacetsObservable",
    "CompleteConversationCompleteConversationFacetsObservableObservable",
    "CompleteConversationCompleteConversationFacetsRange",
    "CompleteConversationCompleteConversationGraph",
    "CompleteConversationCompleteConversationGraphEdges",
    "CompleteConversationCompleteConversationGraphNodes",
    "CompleteConversationCompleteConversationMessage",
    "CompleteConversationCompleteConversationMessageCitations",
    "CompleteConversationCompleteConversationMessageCitationsContent",
    "CompleteConversationCompleteConversationMessageCitationsContentAudio",
    "CompleteConversationCompleteConversationMessageCitationsContentDocument",
    "CompleteConversationCompleteConversationMessageCitationsContentImage",
    "CompleteConversationCompleteConversationMessageCitationsContentVideo",
    "CompleteConversationCompleteConversationMessageToolCalls",
    "ConnectorFilter",
    "ConnectorInput",
    "ConnectorTypes",
    "ConnectorUpdateInput",
    "ContentClassificationConnectorInput",
    "ContentClassificationServiceTypes",
    "ContentCriteriaInput",
    "ContentCriteriaLevelInput",
    "ContentFacetInput",
    "ContentFacetTypes",
    "ContentFilter",
    "ContentFilterLevel",
    "ContentGraphInput",
    "ContentIndexingConnectorInput",
    "ContentIndexingServiceTypes",
    "ContentInput",
    "ContentPublishingConnectorInput",
    "ContentPublishingConnectorUpdateInput",
    "ContentPublishingFormats",
    "ContentPublishingServiceTypes",
    "ContentSourceTypes",
    "ContentTypes",
    "ContentUpdateInput",
    "ContinueConversation",
    "ContinueConversationContinueConversation",
    "ContinueConversationContinueConversationConversation",
    "ContinueConversationContinueConversationDetails",
    "ContinueConversationContinueConversationDetailsMessages",
    "ContinueConversationContinueConversationDetailsMessagesCitations",
    "ContinueConversationContinueConversationDetailsMessagesCitationsContent",
    "ContinueConversationContinueConversationDetailsMessagesCitationsContentAudio",
    "ContinueConversationContinueConversationDetailsMessagesCitationsContentDocument",
    "ContinueConversationContinueConversationDetailsMessagesCitationsContentImage",
    "ContinueConversationContinueConversationDetailsMessagesCitationsContentVideo",
    "ContinueConversationContinueConversationDetailsMessagesToolCalls",
    "ContinueConversationContinueConversationFacets",
    "ContinueConversationContinueConversationFacetsObservable",
    "ContinueConversationContinueConversationFacetsObservableObservable",
    "ContinueConversationContinueConversationFacetsRange",
    "ContinueConversationContinueConversationGraph",
    "ContinueConversationContinueConversationGraphEdges",
    "ContinueConversationContinueConversationGraphNodes",
    "ContinueConversationContinueConversationMessage",
    "ContinueConversationContinueConversationMessageCitations",
    "ContinueConversationContinueConversationMessageCitationsContent",
    "ContinueConversationContinueConversationMessageCitationsContentAudio",
    "ContinueConversationContinueConversationMessageCitationsContentDocument",
    "ContinueConversationContinueConversationMessageCitationsContentImage",
    "ContinueConversationContinueConversationMessageCitationsContentVideo",
    "ContinueConversationContinueConversationMessageToolCalls",
    "ConversationFilter",
    "ConversationInput",
    "ConversationMessageInput",
    "ConversationRoleTypes",
    "ConversationSearchTypes",
    "ConversationStrategyInput",
    "ConversationStrategyTypes",
    "ConversationStrategyUpdateInput",
    "ConversationToolResponseInput",
    "ConversationTypes",
    "ConversationUpdateInput",
    "CountAlerts",
    "CountAlertsCountAlerts",
    "CountCategories",
    "CountCategoriesCountCategories",
    "CountCollections",
    "CountCollectionsCountCollections",
    "CountContents",
    "CountContentsCountContents",
    "CountConversations",
    "CountConversationsCountConversations",
    "CountEvents",
    "CountEventsCountEvents",
    "CountFeeds",
    "CountFeedsCountFeeds",
    "CountLabels",
    "CountLabelsCountLabels",
    "CountMedicalConditions",
    "CountMedicalConditionsCountMedicalConditions",
    "CountMedicalContraindications",
    "CountMedicalContraindicationsCountMedicalContraindications",
    "CountMedicalDevices",
    "CountMedicalDevicesCountMedicalDevices",
    "CountMedicalDrugClasses",
    "CountMedicalDrugClassesCountMedicalDrugClasses",
    "CountMedicalDrugs",
    "CountMedicalDrugsCountMedicalDrugs",
    "CountMedicalGuidelines",
    "CountMedicalGuidelinesCountMedicalGuidelines",
    "CountMedicalIndications",
    "CountMedicalIndicationsCountMedicalIndications",
    "CountMedicalProcedures",
    "CountMedicalProceduresCountMedicalProcedures",
    "CountMedicalStudies",
    "CountMedicalStudiesCountMedicalStudies",
    "CountMedicalTests",
    "CountMedicalTestsCountMedicalTests",
    "CountMedicalTherapies",
    "CountMedicalTherapiesCountMedicalTherapies",
    "CountOrganizations",
    "CountOrganizationsCountOrganizations",
    "CountPersons",
    "CountPersonsCountPersons",
    "CountPlaces",
    "CountPlacesCountPlaces",
    "CountProducts",
    "CountProductsCountProducts",
    "CountRepos",
    "CountReposCountRepos",
    "CountSoftwares",
    "CountSoftwaresCountSoftwares",
    "CountSpecifications",
    "CountSpecificationsCountSpecifications",
    "CountUsers",
    "CountUsersCountUsers",
    "CountWorkflows",
    "CountWorkflowsCountWorkflows",
    "CreateAlert",
    "CreateAlertCreateAlert",
    "CreateCategory",
    "CreateCategoryCreateCategory",
    "CreateCollection",
    "CreateCollectionCreateCollection",
    "CreateConversation",
    "CreateConversationCreateConversation",
    "CreateEvent",
    "CreateEventCreateEvent",
    "CreateFeed",
    "CreateFeedCreateFeed",
    "CreateLabel",
    "CreateLabelCreateLabel",
    "CreateMedicalCondition",
    "CreateMedicalConditionCreateMedicalCondition",
    "CreateMedicalContraindication",
    "CreateMedicalContraindicationCreateMedicalContraindication",
    "CreateMedicalDevice",
    "CreateMedicalDeviceCreateMedicalDevice",
    "CreateMedicalDrug",
    "CreateMedicalDrugClass",
    "CreateMedicalDrugClassCreateMedicalDrugClass",
    "CreateMedicalDrugCreateMedicalDrug",
    "CreateMedicalGuideline",
    "CreateMedicalGuidelineCreateMedicalGuideline",
    "CreateMedicalIndication",
    "CreateMedicalIndicationCreateMedicalIndication",
    "CreateMedicalProcedure",
    "CreateMedicalProcedureCreateMedicalProcedure",
    "CreateMedicalStudy",
    "CreateMedicalStudyCreateMedicalStudy",
    "CreateMedicalTest",
    "CreateMedicalTestCreateMedicalTest",
    "CreateMedicalTherapy",
    "CreateMedicalTherapyCreateMedicalTherapy",
    "CreateObservation",
    "CreateObservationCreateObservation",
    "CreateOrganization",
    "CreateOrganizationCreateOrganization",
    "CreatePerson",
    "CreatePersonCreatePerson",
    "CreatePlace",
    "CreatePlaceCreatePlace",
    "CreateProduct",
    "CreateProductCreateProduct",
    "CreateRepo",
    "CreateRepoCreateRepo",
    "CreateSoftware",
    "CreateSoftwareCreateSoftware",
    "CreateSpecification",
    "CreateSpecificationCreateSpecification",
    "CreateUser",
    "CreateUserCreateUser",
    "CreateWorkflow",
    "CreateWorkflowCreateWorkflow",
    "CreateWorkflowCreateWorkflowActions",
    "CreateWorkflowCreateWorkflowActionsConnector",
    "CreateWorkflowCreateWorkflowActionsConnectorEmail",
    "CreateWorkflowCreateWorkflowActionsConnectorSlack",
    "CreateWorkflowCreateWorkflowActionsConnectorTwitter",
    "CreateWorkflowCreateWorkflowClassification",
    "CreateWorkflowCreateWorkflowClassificationJobs",
    "CreateWorkflowCreateWorkflowClassificationJobsConnector",
    "CreateWorkflowCreateWorkflowClassificationJobsConnectorModel",
    "CreateWorkflowCreateWorkflowClassificationJobsConnectorModelRules",
    "CreateWorkflowCreateWorkflowClassificationJobsConnectorModelSpecification",
    "CreateWorkflowCreateWorkflowClassificationJobsConnectorRegex",
    "CreateWorkflowCreateWorkflowClassificationJobsConnectorRegexRules",
    "CreateWorkflowCreateWorkflowEnrichment",
    "CreateWorkflowCreateWorkflowEnrichmentJobs",
    "CreateWorkflowCreateWorkflowEnrichmentJobsConnector",
    "CreateWorkflowCreateWorkflowEnrichmentJobsConnectorDiffbot",
    "CreateWorkflowCreateWorkflowEnrichmentJobsConnectorFhir",
    "CreateWorkflowCreateWorkflowEnrichmentLink",
    "CreateWorkflowCreateWorkflowExtraction",
    "CreateWorkflowCreateWorkflowExtractionJobs",
    "CreateWorkflowCreateWorkflowExtractionJobsConnector",
    "CreateWorkflowCreateWorkflowExtractionJobsConnectorAzureImage",
    "CreateWorkflowCreateWorkflowExtractionJobsConnectorAzureText",
    "CreateWorkflowCreateWorkflowExtractionJobsConnectorModelImage",
    "CreateWorkflowCreateWorkflowExtractionJobsConnectorModelImageSpecification",
    "CreateWorkflowCreateWorkflowExtractionJobsConnectorModelText",
    "CreateWorkflowCreateWorkflowExtractionJobsConnectorModelTextSpecification",
    "CreateWorkflowCreateWorkflowIndexing",
    "CreateWorkflowCreateWorkflowIndexingJobs",
    "CreateWorkflowCreateWorkflowIndexingJobsConnector",
    "CreateWorkflowCreateWorkflowIngestion",
    "CreateWorkflowCreateWorkflowIngestionCollections",
    "CreateWorkflowCreateWorkflowIngestionIf",
    "CreateWorkflowCreateWorkflowIngestionObservations",
    "CreateWorkflowCreateWorkflowIngestionObservationsObservable",
    "CreateWorkflowCreateWorkflowPreparation",
    "CreateWorkflowCreateWorkflowPreparationJobs",
    "CreateWorkflowCreateWorkflowPreparationJobsConnector",
    "CreateWorkflowCreateWorkflowPreparationJobsConnectorAssemblyAi",
    "CreateWorkflowCreateWorkflowPreparationJobsConnectorAzureDocument",
    "CreateWorkflowCreateWorkflowPreparationJobsConnectorDeepgram",
    "CreateWorkflowCreateWorkflowPreparationJobsConnectorDocument",
    "CreateWorkflowCreateWorkflowPreparationJobsConnectorEmail",
    "CreateWorkflowCreateWorkflowPreparationJobsConnectorMistral",
    "CreateWorkflowCreateWorkflowPreparationJobsConnectorModelDocument",
    "CreateWorkflowCreateWorkflowPreparationJobsConnectorModelDocumentSpecification",
    "CreateWorkflowCreateWorkflowPreparationJobsConnectorPage",
    "CreateWorkflowCreateWorkflowPreparationSummarizations",
    "CreateWorkflowCreateWorkflowPreparationSummarizationsSpecification",
    "CreateWorkflowCreateWorkflowStorage",
    "CreateWorkflowCreateWorkflowStoragePolicy",
    "DELETE_ALERTS_GQL",
    "DELETE_ALERT_GQL",
    "DELETE_ALL_ALERTS_GQL",
    "DELETE_ALL_CATEGORIES_GQL",
    "DELETE_ALL_COLLECTIONS_GQL",
    "DELETE_ALL_CONTENTS_GQL",
    "DELETE_ALL_CONVERSATIONS_GQL",
    "DELETE_ALL_EVENTS_GQL",
    "DELETE_ALL_FEEDS_GQL",
    "DELETE_ALL_LABELS_GQL",
    "DELETE_ALL_MEDICAL_CONDITIONS_GQL",
    "DELETE_ALL_MEDICAL_CONTRAINDICATIONS_GQL",
    "DELETE_ALL_MEDICAL_DEVICES_GQL",
    "DELETE_ALL_MEDICAL_DRUGS_GQL",
    "DELETE_ALL_MEDICAL_DRUG_CLASSES_GQL",
    "DELETE_ALL_MEDICAL_GUIDELINES_GQL",
    "DELETE_ALL_MEDICAL_INDICATIONS_GQL",
    "DELETE_ALL_MEDICAL_PROCEDURES_GQL",
    "DELETE_ALL_MEDICAL_STUDIES_GQL",
    "DELETE_ALL_MEDICAL_TESTS_GQL",
    "DELETE_ALL_MEDICAL_THERAPIES_GQL",
    "DELETE_ALL_ORGANIZATIONS_GQL",
    "DELETE_ALL_PERSONS_GQL",
    "DELETE_ALL_PLACES_GQL",
    "DELETE_ALL_PRODUCTS_GQL",
    "DELETE_ALL_REPOS_GQL",
    "DELETE_ALL_SOFTWARES_GQL",
    "DELETE_ALL_SPECIFICATIONS_GQL",
    "DELETE_ALL_WORKFLOWS_GQL",
    "DELETE_CATEGORIES_GQL",
    "DELETE_CATEGORY_GQL",
    "DELETE_COLLECTIONS_GQL",
    "DELETE_COLLECTION_GQL",
    "DELETE_CONTENTS_GQL",
    "DELETE_CONTENT_GQL",
    "DELETE_CONVERSATIONS_GQL",
    "DELETE_CONVERSATION_GQL",
    "DELETE_EVENTS_GQL",
    "DELETE_EVENT_GQL",
    "DELETE_FEEDS_GQL",
    "DELETE_FEED_GQL",
    "DELETE_LABELS_GQL",
    "DELETE_LABEL_GQL",
    "DELETE_MEDICAL_CONDITIONS_GQL",
    "DELETE_MEDICAL_CONDITION_GQL",
    "DELETE_MEDICAL_CONTRAINDICATIONS_GQL",
    "DELETE_MEDICAL_CONTRAINDICATION_GQL",
    "DELETE_MEDICAL_DEVICES_GQL",
    "DELETE_MEDICAL_DEVICE_GQL",
    "DELETE_MEDICAL_DRUGS_GQL",
    "DELETE_MEDICAL_DRUG_CLASSES_GQL",
    "DELETE_MEDICAL_DRUG_CLASS_GQL",
    "DELETE_MEDICAL_DRUG_GQL",
    "DELETE_MEDICAL_GUIDELINES_GQL",
    "DELETE_MEDICAL_GUIDELINE_GQL",
    "DELETE_MEDICAL_INDICATIONS_GQL",
    "DELETE_MEDICAL_INDICATION_GQL",
    "DELETE_MEDICAL_PROCEDURES_GQL",
    "DELETE_MEDICAL_PROCEDURE_GQL",
    "DELETE_MEDICAL_STUDIES_GQL",
    "DELETE_MEDICAL_STUDY_GQL",
    "DELETE_MEDICAL_TESTS_GQL",
    "DELETE_MEDICAL_TEST_GQL",
    "DELETE_MEDICAL_THERAPIES_GQL",
    "DELETE_MEDICAL_THERAPY_GQL",
    "DELETE_OBSERVATION_GQL",
    "DELETE_ORGANIZATIONS_GQL",
    "DELETE_ORGANIZATION_GQL",
    "DELETE_PERSONS_GQL",
    "DELETE_PERSON_GQL",
    "DELETE_PLACES_GQL",
    "DELETE_PLACE_GQL",
    "DELETE_PRODUCTS_GQL",
    "DELETE_PRODUCT_GQL",
    "DELETE_REPOS_GQL",
    "DELETE_REPO_GQL",
    "DELETE_SOFTWARES_GQL",
    "DELETE_SOFTWARE_GQL",
    "DELETE_SPECIFICATIONS_GQL",
    "DELETE_SPECIFICATION_GQL",
    "DELETE_USER_GQL",
    "DELETE_WORKFLOWS_GQL",
    "DELETE_WORKFLOW_GQL",
    "DESCRIBE_ENCODED_IMAGE_GQL",
    "DESCRIBE_IMAGE_GQL",
    "DISABLE_ALERT_GQL",
    "DISABLE_FEED_GQL",
    "DISABLE_USER_GQL",
    "DateRangeFilter",
    "DateRangeInput",
    "DeepgramAudioPreparationPropertiesInput",
    "DeepgramModels",
    "DeepseekModelPropertiesInput",
    "DeepseekModelPropertiesUpdateInput",
    "DeepseekModels",
    "DeleteAlert",
    "DeleteAlertDeleteAlert",
    "DeleteAlerts",
    "DeleteAlertsDeleteAlerts",
    "DeleteAllAlerts",
    "DeleteAllAlertsDeleteAllAlerts",
    "DeleteAllCategories",
    "DeleteAllCategoriesDeleteAllCategories",
    "DeleteAllCollections",
    "DeleteAllCollectionsDeleteAllCollections",
    "DeleteAllContents",
    "DeleteAllContentsDeleteAllContents",
    "DeleteAllConversations",
    "DeleteAllConversationsDeleteAllConversations",
    "DeleteAllEvents",
    "DeleteAllEventsDeleteAllEvents",
    "DeleteAllFeeds",
    "DeleteAllFeedsDeleteAllFeeds",
    "DeleteAllLabels",
    "DeleteAllLabelsDeleteAllLabels",
    "DeleteAllMedicalConditions",
    "DeleteAllMedicalConditionsDeleteAllMedicalConditions",
    "DeleteAllMedicalContraindications",
    "DeleteAllMedicalContraindicationsDeleteAllMedicalContraindications",
    "DeleteAllMedicalDevices",
    "DeleteAllMedicalDevicesDeleteAllMedicalDevices",
    "DeleteAllMedicalDrugClasses",
    "DeleteAllMedicalDrugClassesDeleteAllMedicalDrugClasses",
    "DeleteAllMedicalDrugs",
    "DeleteAllMedicalDrugsDeleteAllMedicalDrugs",
    "DeleteAllMedicalGuidelines",
    "DeleteAllMedicalGuidelinesDeleteAllMedicalGuidelines",
    "DeleteAllMedicalIndications",
    "DeleteAllMedicalIndicationsDeleteAllMedicalIndications",
    "DeleteAllMedicalProcedures",
    "DeleteAllMedicalProceduresDeleteAllMedicalProcedures",
    "DeleteAllMedicalStudies",
    "DeleteAllMedicalStudiesDeleteAllMedicalStudies",
    "DeleteAllMedicalTests",
    "DeleteAllMedicalTestsDeleteAllMedicalTests",
    "DeleteAllMedicalTherapies",
    "DeleteAllMedicalTherapiesDeleteAllMedicalTherapies",
    "DeleteAllOrganizations",
    "DeleteAllOrganizationsDeleteAllOrganizations",
    "DeleteAllPersons",
    "DeleteAllPersonsDeleteAllPersons",
    "DeleteAllPlaces",
    "DeleteAllPlacesDeleteAllPlaces",
    "DeleteAllProducts",
    "DeleteAllProductsDeleteAllProducts",
    "DeleteAllRepos",
    "DeleteAllReposDeleteAllRepos",
    "DeleteAllSoftwares",
    "DeleteAllSoftwaresDeleteAllSoftwares",
    "DeleteAllSpecifications",
    "DeleteAllSpecificationsDeleteAllSpecifications",
    "DeleteAllWorkflows",
    "DeleteAllWorkflowsDeleteAllWorkflows",
    "DeleteCategories",
    "DeleteCategoriesDeleteCategories",
    "DeleteCategory",
    "DeleteCategoryDeleteCategory",
    "DeleteCollection",
    "DeleteCollectionDeleteCollection",
    "DeleteCollections",
    "DeleteCollectionsDeleteCollections",
    "DeleteContent",
    "DeleteContentDeleteContent",
    "DeleteContents",
    "DeleteContentsDeleteContents",
    "DeleteConversation",
    "DeleteConversationDeleteConversation",
    "DeleteConversations",
    "DeleteConversationsDeleteConversations",
    "DeleteEvent",
    "DeleteEventDeleteEvent",
    "DeleteEvents",
    "DeleteEventsDeleteEvents",
    "DeleteFeed",
    "DeleteFeedDeleteFeed",
    "DeleteFeeds",
    "DeleteFeedsDeleteFeeds",
    "DeleteLabel",
    "DeleteLabelDeleteLabel",
    "DeleteLabels",
    "DeleteLabelsDeleteLabels",
    "DeleteMedicalCondition",
    "DeleteMedicalConditionDeleteMedicalCondition",
    "DeleteMedicalConditions",
    "DeleteMedicalConditionsDeleteMedicalConditions",
    "DeleteMedicalContraindication",
    "DeleteMedicalContraindicationDeleteMedicalContraindication",
    "DeleteMedicalContraindications",
    "DeleteMedicalContraindicationsDeleteMedicalContraindications",
    "DeleteMedicalDevice",
    "DeleteMedicalDeviceDeleteMedicalDevice",
    "DeleteMedicalDevices",
    "DeleteMedicalDevicesDeleteMedicalDevices",
    "DeleteMedicalDrug",
    "DeleteMedicalDrugClass",
    "DeleteMedicalDrugClassDeleteMedicalDrugClass",
    "DeleteMedicalDrugClasses",
    "DeleteMedicalDrugClassesDeleteMedicalDrugClasses",
    "DeleteMedicalDrugDeleteMedicalDrug",
    "DeleteMedicalDrugs",
    "DeleteMedicalDrugsDeleteMedicalDrugs",
    "DeleteMedicalGuideline",
    "DeleteMedicalGuidelineDeleteMedicalGuideline",
    "DeleteMedicalGuidelines",
    "DeleteMedicalGuidelinesDeleteMedicalGuidelines",
    "DeleteMedicalIndication",
    "DeleteMedicalIndicationDeleteMedicalIndication",
    "DeleteMedicalIndications",
    "DeleteMedicalIndicationsDeleteMedicalIndications",
    "DeleteMedicalProcedure",
    "DeleteMedicalProcedureDeleteMedicalProcedure",
    "DeleteMedicalProcedures",
    "DeleteMedicalProceduresDeleteMedicalProcedures",
    "DeleteMedicalStudies",
    "DeleteMedicalStudiesDeleteMedicalStudies",
    "DeleteMedicalStudy",
    "DeleteMedicalStudyDeleteMedicalStudy",
    "DeleteMedicalTest",
    "DeleteMedicalTestDeleteMedicalTest",
    "DeleteMedicalTests",
    "DeleteMedicalTestsDeleteMedicalTests",
    "DeleteMedicalTherapies",
    "DeleteMedicalTherapiesDeleteMedicalTherapies",
    "DeleteMedicalTherapy",
    "DeleteMedicalTherapyDeleteMedicalTherapy",
    "DeleteObservation",
    "DeleteObservationDeleteObservation",
    "DeleteOrganization",
    "DeleteOrganizationDeleteOrganization",
    "DeleteOrganizations",
    "DeleteOrganizationsDeleteOrganizations",
    "DeletePerson",
    "DeletePersonDeletePerson",
    "DeletePersons",
    "DeletePersonsDeletePersons",
    "DeletePlace",
    "DeletePlaceDeletePlace",
    "DeletePlaces",
    "DeletePlacesDeletePlaces",
    "DeleteProduct",
    "DeleteProductDeleteProduct",
    "DeleteProducts",
    "DeleteProductsDeleteProducts",
    "DeleteRepo",
    "DeleteRepoDeleteRepo",
    "DeleteRepos",
    "DeleteReposDeleteRepos",
    "DeleteSoftware",
    "DeleteSoftwareDeleteSoftware",
    "DeleteSoftwares",
    "DeleteSoftwaresDeleteSoftwares",
    "DeleteSpecification",
    "DeleteSpecificationDeleteSpecification",
    "DeleteSpecifications",
    "DeleteSpecificationsDeleteSpecifications",
    "DeleteUser",
    "DeleteUserDeleteUser",
    "DeleteWorkflow",
    "DeleteWorkflowDeleteWorkflow",
    "DeleteWorkflows",
    "DeleteWorkflowsDeleteWorkflows",
    "DescribeEncodedImage",
    "DescribeEncodedImageDescribeEncodedImage",
    "DescribeEncodedImageDescribeEncodedImageCitations",
    "DescribeEncodedImageDescribeEncodedImageCitationsContent",
    "DescribeEncodedImageDescribeEncodedImageCitationsContentAudio",
    "DescribeEncodedImageDescribeEncodedImageCitationsContentDocument",
    "DescribeEncodedImageDescribeEncodedImageCitationsContentImage",
    "DescribeEncodedImageDescribeEncodedImageCitationsContentVideo",
    "DescribeEncodedImageDescribeEncodedImageToolCalls",
    "DescribeImage",
    "DescribeImageDescribeImage",
    "DescribeImageDescribeImageCitations",
    "DescribeImageDescribeImageCitationsContent",
    "DescribeImageDescribeImageCitationsContentAudio",
    "DescribeImageDescribeImageCitationsContentDocument",
    "DescribeImageDescribeImageCitationsContentImage",
    "DescribeImageDescribeImageCitationsContentVideo",
    "DescribeImageDescribeImageToolCalls",
    "DeviceTypes",
    "DiffbotEnrichmentPropertiesInput",
    "DisableAlert",
    "DisableAlertDisableAlert",
    "DisableFeed",
    "DisableFeedDisableFeed",
    "DisableUser",
    "DisableUserDisableUser",
    "DiscordFeedPropertiesInput",
    "DiscordFeedPropertiesUpdateInput",
    "DocumentMetadataInput",
    "DocumentPreparationPropertiesInput",
    "DrawingMetadataInput",
    "DropboxFeedPropertiesInput",
    "DropboxFeedPropertiesUpdateInput",
    "ENABLE_ALERT_GQL",
    "ENABLE_FEED_GQL",
    "ENABLE_USER_GQL",
    "EXTRACT_CONTENTS_GQL",
    "EXTRACT_TEXT_GQL",
    "ElevenLabsModels",
    "ElevenLabsPublishingPropertiesInput",
    "EmailFeedPropertiesInput",
    "EmailFeedPropertiesUpdateInput",
    "EmailIntegrationPropertiesInput",
    "EmailListingTypes",
    "EmailMetadataInput",
    "EmailPreparationPropertiesInput",
    "EmbeddingsStrategyInput",
    "EnableAlert",
    "EnableAlertEnableAlert",
    "EnableFeed",
    "EnableFeedEnableFeed",
    "EnableUser",
    "EnableUserEnableUser",
    "EnrichmentWorkflowJobInput",
    "EnrichmentWorkflowStageInput",
    "EntityEnrichmentConnectorInput",
    "EntityEnrichmentServiceTypes",
    "EntityExtractionConnectorInput",
    "EntityExtractionServiceTypes",
    "EntityReferenceFilter",
    "EntityReferenceInput",
    "EntityState",
    "EntityTypes",
    "EnvironmentTypes",
    "EventFacetInput",
    "EventFacetTypes",
    "EventFilter",
    "EventInput",
    "EventUpdateInput",
    "ExtractContents",
    "ExtractContentsExtractContents",
    "ExtractContentsExtractContentsContent",
    "ExtractContentsExtractContentsSpecification",
    "ExtractText",
    "ExtractTextExtractText",
    "ExtractTextExtractTextContent",
    "ExtractTextExtractTextSpecification",
    "ExtractionWorkflowJobInput",
    "ExtractionWorkflowStageInput",
    "FEED_EXISTS_GQL",
    "FHIREnrichmentPropertiesInput",
    "FORMAT_CONVERSATION_GQL",
    "FacetValueTypes",
    "FeedConnectorTypes",
    "FeedExists",
    "FeedExistsFeedExists",
    "FeedFilter",
    "FeedInput",
    "FeedListingTypes",
    "FeedSchedulePolicyInput",
    "FeedServiceTypes",
    "FeedTypes",
    "FeedUpdateInput",
    "FilePreparationConnectorInput",
    "FilePreparationServiceTypes",
    "FileTypes",
    "FormatConversation",
    "FormatConversationFormatConversation",
    "FormatConversationFormatConversationConversation",
    "FormatConversationFormatConversationDetails",
    "FormatConversationFormatConversationDetailsMessages",
    "FormatConversationFormatConversationDetailsMessagesCitations",
    "FormatConversationFormatConversationDetailsMessagesCitationsContent",
    "FormatConversationFormatConversationDetailsMessagesCitationsContentAudio",
    "FormatConversationFormatConversationDetailsMessagesCitationsContentDocument",
    "FormatConversationFormatConversationDetailsMessagesCitationsContentImage",
    "FormatConversationFormatConversationDetailsMessagesCitationsContentVideo",
    "FormatConversationFormatConversationDetailsMessagesToolCalls",
    "FormatConversationFormatConversationFacets",
    "FormatConversationFormatConversationFacetsObservable",
    "FormatConversationFormatConversationFacetsObservableObservable",
    "FormatConversationFormatConversationFacetsRange",
    "FormatConversationFormatConversationGraph",
    "FormatConversationFormatConversationGraphEdges",
    "FormatConversationFormatConversationGraphNodes",
    "FormatConversationFormatConversationMessage",
    "FormatConversationFormatConversationMessageCitations",
    "FormatConversationFormatConversationMessageCitationsContent",
    "FormatConversationFormatConversationMessageCitationsContentAudio",
    "FormatConversationFormatConversationMessageCitationsContentDocument",
    "FormatConversationFormatConversationMessageCitationsContentImage",
    "FormatConversationFormatConversationMessageCitationsContentVideo",
    "FormatConversationFormatConversationMessageToolCalls",
    "GET_ALERT_GQL",
    "GET_CATEGORY_GQL",
    "GET_COLLECTION_GQL",
    "GET_CONTENT_GQL",
    "GET_CONVERSATION_GQL",
    "GET_EVENT_GQL",
    "GET_FEED_GQL",
    "GET_LABEL_GQL",
    "GET_MEDICAL_CONDITION_GQL",
    "GET_MEDICAL_CONTRAINDICATION_GQL",
    "GET_MEDICAL_DEVICE_GQL",
    "GET_MEDICAL_DRUG_CLASS_GQL",
    "GET_MEDICAL_DRUG_GQL",
    "GET_MEDICAL_GUIDELINE_GQL",
    "GET_MEDICAL_INDICATION_GQL",
    "GET_MEDICAL_PROCEDURE_GQL",
    "GET_MEDICAL_STUDY_GQL",
    "GET_MEDICAL_TEST_GQL",
    "GET_MEDICAL_THERAPY_GQL",
    "GET_ORGANIZATION_GQL",
    "GET_PERSON_GQL",
    "GET_PLACE_GQL",
    "GET_PRODUCT_GQL",
    "GET_PROJECT_GQL",
    "GET_REPO_GQL",
    "GET_SHARE_POINT_CONSENT_URI_GQL",
    "GET_SOFTWARE_GQL",
    "GET_SPECIFICATION_GQL",
    "GET_USER_GQL",
    "GET_WORKFLOW_GQL",
    "GeometryMetadataInput",
    "GetAlert",
    "GetAlertAlert",
    "GetAlertAlertFilter",
    "GetAlertAlertFilterAnd",
    "GetAlertAlertFilterAndCollections",
    "GetAlertAlertFilterAndFeeds",
    "GetAlertAlertFilterAndObservations",
    "GetAlertAlertFilterAndObservationsObservable",
    "GetAlertAlertFilterAndUsers",
    "GetAlertAlertFilterAndWorkflows",
    "GetAlertAlertFilterCollections",
    "GetAlertAlertFilterContents",
    "GetAlertAlertFilterCreationDateRange",
    "GetAlertAlertFilterDateRange",
    "GetAlertAlertFilterFeeds",
    "GetAlertAlertFilterObservations",
    "GetAlertAlertFilterObservationsObservable",
    "GetAlertAlertFilterOr",
    "GetAlertAlertFilterOrCollections",
    "GetAlertAlertFilterOrFeeds",
    "GetAlertAlertFilterOrObservations",
    "GetAlertAlertFilterOrObservationsObservable",
    "GetAlertAlertFilterOrUsers",
    "GetAlertAlertFilterOrWorkflows",
    "GetAlertAlertFilterSimilarContents",
    "GetAlertAlertFilterUsers",
    "GetAlertAlertFilterWorkflows",
    "GetAlertAlertIntegration",
    "GetAlertAlertIntegrationEmail",
    "GetAlertAlertIntegrationSlack",
    "GetAlertAlertIntegrationTwitter",
    "GetAlertAlertOwner",
    "GetAlertAlertPublishSpecification",
    "GetAlertAlertPublishing",
    "GetAlertAlertPublishingElevenLabs",
    "GetAlertAlertPublishingOpenAiImage",
    "GetAlertAlertPublishingOpenAiImageSeed",
    "GetAlertAlertSummarySpecification",
    "GetCategory",
    "GetCategoryCategory",
    "GetCollection",
    "GetCollectionCollection",
    "GetCollectionCollectionContents",
    "GetCollectionCollectionOwner",
    "GetContent",
    "GetContentContent",
    "GetContentContentAddress",
    "GetContentContentAudio",
    "GetContentContentChildren",
    "GetContentContentCollections",
    "GetContentContentDocument",
    "GetContentContentEmail",
    "GetContentContentEmailBcc",
    "GetContentContentEmailCc",
    "GetContentContentEmailFrom",
    "GetContentContentEmailTo",
    "GetContentContentFeed",
    "GetContentContentFrames",
    "GetContentContentImage",
    "GetContentContentIssue",
    "GetContentContentLanguage",
    "GetContentContentLinks",
    "GetContentContentLocation",
    "GetContentContentObservations",
    "GetContentContentObservationsObservable",
    "GetContentContentObservationsOccurrences",
    "GetContentContentObservationsOccurrencesBoundingBox",
    "GetContentContentObservationsRelated",
    "GetContentContentOwner",
    "GetContentContentPackage",
    "GetContentContentPages",
    "GetContentContentPagesChunks",
    "GetContentContentPagesImages",
    "GetContentContentParent",
    "GetContentContentSegments",
    "GetContentContentVideo",
    "GetContentContentWorkflow",
    "GetConversation",
    "GetConversationConversation",
    "GetConversationConversationAugmentedFilter",
    "GetConversationConversationAugmentedFilterAnd",
    "GetConversationConversationAugmentedFilterAndCollections",
    "GetConversationConversationAugmentedFilterAndFeeds",
    "GetConversationConversationAugmentedFilterAndObservations",
    "GetConversationConversationAugmentedFilterAndObservationsObservable",
    "GetConversationConversationAugmentedFilterAndUsers",
    "GetConversationConversationAugmentedFilterAndWorkflows",
    "GetConversationConversationAugmentedFilterCollections",
    "GetConversationConversationAugmentedFilterContents",
    "GetConversationConversationAugmentedFilterCreationDateRange",
    "GetConversationConversationAugmentedFilterDateRange",
    "GetConversationConversationAugmentedFilterFeeds",
    "GetConversationConversationAugmentedFilterObservations",
    "GetConversationConversationAugmentedFilterObservationsObservable",
    "GetConversationConversationAugmentedFilterOr",
    "GetConversationConversationAugmentedFilterOrCollections",
    "GetConversationConversationAugmentedFilterOrFeeds",
    "GetConversationConversationAugmentedFilterOrObservations",
    "GetConversationConversationAugmentedFilterOrObservationsObservable",
    "GetConversationConversationAugmentedFilterOrUsers",
    "GetConversationConversationAugmentedFilterOrWorkflows",
    "GetConversationConversationAugmentedFilterSimilarContents",
    "GetConversationConversationAugmentedFilterUsers",
    "GetConversationConversationAugmentedFilterWorkflows",
    "GetConversationConversationFallbacks",
    "GetConversationConversationFilter",
    "GetConversationConversationFilterAnd",
    "GetConversationConversationFilterAndCollections",
    "GetConversationConversationFilterAndFeeds",
    "GetConversationConversationFilterAndObservations",
    "GetConversationConversationFilterAndObservationsObservable",
    "GetConversationConversationFilterAndUsers",
    "GetConversationConversationFilterAndWorkflows",
    "GetConversationConversationFilterCollections",
    "GetConversationConversationFilterContents",
    "GetConversationConversationFilterCreationDateRange",
    "GetConversationConversationFilterDateRange",
    "GetConversationConversationFilterFeeds",
    "GetConversationConversationFilterObservations",
    "GetConversationConversationFilterObservationsObservable",
    "GetConversationConversationFilterOr",
    "GetConversationConversationFilterOrCollections",
    "GetConversationConversationFilterOrFeeds",
    "GetConversationConversationFilterOrObservations",
    "GetConversationConversationFilterOrObservationsObservable",
    "GetConversationConversationFilterOrUsers",
    "GetConversationConversationFilterOrWorkflows",
    "GetConversationConversationFilterSimilarContents",
    "GetConversationConversationFilterUsers",
    "GetConversationConversationFilterWorkflows",
    "GetConversationConversationMessages",
    "GetConversationConversationMessagesCitations",
    "GetConversationConversationMessagesCitationsContent",
    "GetConversationConversationMessagesCitationsContentAudio",
    "GetConversationConversationMessagesCitationsContentDocument",
    "GetConversationConversationMessagesCitationsContentImage",
    "GetConversationConversationMessagesCitationsContentVideo",
    "GetConversationConversationMessagesToolCalls",
    "GetConversationConversationOwner",
    "GetConversationConversationSpecification",
    "GetEvent",
    "GetEventEvent",
    "GetEventEventAddress",
    "GetFeed",
    "GetFeedFeed",
    "GetFeedFeedDiscord",
    "GetFeedFeedEmail",
    "GetFeedFeedEmailGoogle",
    "GetFeedFeedEmailMicrosoft",
    "GetFeedFeedIntercom",
    "GetFeedFeedIssue",
    "GetFeedFeedIssueGithub",
    "GetFeedFeedIssueIntercom",
    "GetFeedFeedIssueJira",
    "GetFeedFeedIssueLinear",
    "GetFeedFeedIssueTrello",
    "GetFeedFeedIssueZendesk",
    "GetFeedFeedMicrosoftTeams",
    "GetFeedFeedNotion",
    "GetFeedFeedOwner",
    "GetFeedFeedReddit",
    "GetFeedFeedRss",
    "GetFeedFeedSchedulePolicy",
    "GetFeedFeedSearch",
    "GetFeedFeedSite",
    "GetFeedFeedSiteAzureBlob",
    "GetFeedFeedSiteAzureFile",
    "GetFeedFeedSiteBox",
    "GetFeedFeedSiteDropbox",
    "GetFeedFeedSiteGithub",
    "GetFeedFeedSiteGoogle",
    "GetFeedFeedSiteGoogleDrive",
    "GetFeedFeedSiteOneDrive",
    "GetFeedFeedSiteS3",
    "GetFeedFeedSiteSharePoint",
    "GetFeedFeedSlack",
    "GetFeedFeedTwitter",
    "GetFeedFeedWeb",
    "GetFeedFeedWorkflow",
    "GetFeedFeedYoutube",
    "GetFeedFeedZendesk",
    "GetLabel",
    "GetLabelLabel",
    "GetMedicalCondition",
    "GetMedicalConditionMedicalCondition",
    "GetMedicalContraindication",
    "GetMedicalContraindicationMedicalContraindication",
    "GetMedicalDevice",
    "GetMedicalDeviceMedicalDevice",
    "GetMedicalDrug",
    "GetMedicalDrugClass",
    "GetMedicalDrugClassMedicalDrugClass",
    "GetMedicalDrugMedicalDrug",
    "GetMedicalGuideline",
    "GetMedicalGuidelineMedicalGuideline",
    "GetMedicalIndication",
    "GetMedicalIndicationMedicalIndication",
    "GetMedicalProcedure",
    "GetMedicalProcedureMedicalProcedure",
    "GetMedicalStudy",
    "GetMedicalStudyMedicalStudy",
    "GetMedicalStudyMedicalStudyAddress",
    "GetMedicalTest",
    "GetMedicalTestMedicalTest",
    "GetMedicalTherapy",
    "GetMedicalTherapyMedicalTherapy",
    "GetOrganization",
    "GetOrganizationOrganization",
    "GetOrganizationOrganizationAddress",
    "GetPerson",
    "GetPersonPerson",
    "GetPersonPersonAddress",
    "GetPlace",
    "GetPlacePlace",
    "GetPlacePlaceAddress",
    "GetProduct",
    "GetProductProduct",
    "GetProductProductAddress",
    "GetProject",
    "GetProjectProject",
    "GetProjectProjectEmbeddings",
    "GetProjectProjectEmbeddingsImageSpecification",
    "GetProjectProjectEmbeddingsTextSpecification",
    "GetProjectProjectQuota",
    "GetProjectProjectSpecification",
    "GetProjectProjectWorkflow",
    "GetRepo",
    "GetRepoRepo",
    "GetSharePointConsentUri",
    "GetSharePointConsentUriSharePointConsentUri",
    "GetSoftware",
    "GetSoftwareSoftware",
    "GetSpecification",
    "GetSpecificationSpecification",
    "GetSpecificationSpecificationAnthropic",
    "GetSpecificationSpecificationAzureAi",
    "GetSpecificationSpecificationAzureOpenAi",
    "GetSpecificationSpecificationBedrock",
    "GetSpecificationSpecificationCerebras",
    "GetSpecificationSpecificationCohere",
    "GetSpecificationSpecificationDeepseek",
    "GetSpecificationSpecificationGoogle",
    "GetSpecificationSpecificationGraphStrategy",
    "GetSpecificationSpecificationGroq",
    "GetSpecificationSpecificationJina",
    "GetSpecificationSpecificationMistral",
    "GetSpecificationSpecificationOpenAi",
    "GetSpecificationSpecificationOwner",
    "GetSpecificationSpecificationPromptStrategy",
    "GetSpecificationSpecificationReplicate",
    "GetSpecificationSpecificationRerankingStrategy",
    "GetSpecificationSpecificationRetrievalStrategy",
    "GetSpecificationSpecificationRevisionStrategy",
    "GetSpecificationSpecificationStrategy",
    "GetSpecificationSpecificationVoyage",
    "GetUser",
    "GetUserUser",
    "GetUserUserConnectors",
    "GetUserUserConnectorsAuthentication",
    "GetUserUserConnectorsAuthenticationGoogle",
    "GetUserUserConnectorsAuthenticationMicrosoft",
    "GetUserUserConnectorsIntegration",
    "GetUserUserConnectorsIntegrationEmail",
    "GetUserUserConnectorsIntegrationSlack",
    "GetUserUserConnectorsIntegrationTwitter",
    "GetUserUserOwner",
    "GetWorkflow",
    "GetWorkflowWorkflow",
    "GetWorkflowWorkflowActions",
    "GetWorkflowWorkflowActionsConnector",
    "GetWorkflowWorkflowActionsConnectorEmail",
    "GetWorkflowWorkflowActionsConnectorSlack",
    "GetWorkflowWorkflowActionsConnectorTwitter",
    "GetWorkflowWorkflowClassification",
    "GetWorkflowWorkflowClassificationJobs",
    "GetWorkflowWorkflowClassificationJobsConnector",
    "GetWorkflowWorkflowClassificationJobsConnectorModel",
    "GetWorkflowWorkflowClassificationJobsConnectorModelRules",
    "GetWorkflowWorkflowClassificationJobsConnectorModelSpecification",
    "GetWorkflowWorkflowClassificationJobsConnectorRegex",
    "GetWorkflowWorkflowClassificationJobsConnectorRegexRules",
    "GetWorkflowWorkflowEnrichment",
    "GetWorkflowWorkflowEnrichmentJobs",
    "GetWorkflowWorkflowEnrichmentJobsConnector",
    "GetWorkflowWorkflowEnrichmentJobsConnectorDiffbot",
    "GetWorkflowWorkflowEnrichmentJobsConnectorFhir",
    "GetWorkflowWorkflowEnrichmentLink",
    "GetWorkflowWorkflowExtraction",
    "GetWorkflowWorkflowExtractionJobs",
    "GetWorkflowWorkflowExtractionJobsConnector",
    "GetWorkflowWorkflowExtractionJobsConnectorAzureImage",
    "GetWorkflowWorkflowExtractionJobsConnectorAzureText",
    "GetWorkflowWorkflowExtractionJobsConnectorModelImage",
    "GetWorkflowWorkflowExtractionJobsConnectorModelImageSpecification",
    "GetWorkflowWorkflowExtractionJobsConnectorModelText",
    "GetWorkflowWorkflowExtractionJobsConnectorModelTextSpecification",
    "GetWorkflowWorkflowIndexing",
    "GetWorkflowWorkflowIndexingJobs",
    "GetWorkflowWorkflowIndexingJobsConnector",
    "GetWorkflowWorkflowIngestion",
    "GetWorkflowWorkflowIngestionCollections",
    "GetWorkflowWorkflowIngestionIf",
    "GetWorkflowWorkflowIngestionObservations",
    "GetWorkflowWorkflowIngestionObservationsObservable",
    "GetWorkflowWorkflowOwner",
    "GetWorkflowWorkflowPreparation",
    "GetWorkflowWorkflowPreparationJobs",
    "GetWorkflowWorkflowPreparationJobsConnector",
    "GetWorkflowWorkflowPreparationJobsConnectorAssemblyAi",
    "GetWorkflowWorkflowPreparationJobsConnectorAzureDocument",
    "GetWorkflowWorkflowPreparationJobsConnectorDeepgram",
    "GetWorkflowWorkflowPreparationJobsConnectorDocument",
    "GetWorkflowWorkflowPreparationJobsConnectorEmail",
    "GetWorkflowWorkflowPreparationJobsConnectorMistral",
    "GetWorkflowWorkflowPreparationJobsConnectorModelDocument",
    "GetWorkflowWorkflowPreparationJobsConnectorModelDocumentSpecification",
    "GetWorkflowWorkflowPreparationJobsConnectorPage",
    "GetWorkflowWorkflowPreparationSummarizations",
    "GetWorkflowWorkflowPreparationSummarizationsSpecification",
    "GetWorkflowWorkflowStorage",
    "GetWorkflowWorkflowStoragePolicy",
    "GitHubFeedPropertiesInput",
    "GitHubFeedPropertiesUpdateInput",
    "GitHubIssuesFeedPropertiesInput",
    "GitHubIssuesFeedPropertiesUpdateInput",
    "GoogleAuthenticationPropertiesInput",
    "GoogleDriveAuthenticationTypes",
    "GoogleDriveFeedPropertiesInput",
    "GoogleDriveFeedPropertiesUpdateInput",
    "GoogleEmailFeedPropertiesInput",
    "GoogleEmailFeedPropertiesUpdateInput",
    "GoogleFeedPropertiesInput",
    "GoogleFeedPropertiesUpdateInput",
    "GoogleModelPropertiesInput",
    "GoogleModelPropertiesUpdateInput",
    "GoogleModels",
    "GraphQLClientError",
    "GraphQLClientGraphQLError",
    "GraphQLClientGraphQLMultiError",
    "GraphQLClientHttpError",
    "GraphQLClientInvalidResponseError",
    "GraphStrategyInput",
    "GraphStrategyTypes",
    "GraphStrategyUpdateInput",
    "GroqModelPropertiesInput",
    "GroqModelPropertiesUpdateInput",
    "GroqModels",
    "H3Filter",
    "H3IndexFilter",
    "H3ResolutionTypes",
    "INGEST_BATCH_GQL",
    "INGEST_ENCODED_FILE_GQL",
    "INGEST_MEMORY_GQL",
    "INGEST_TEXT_BATCH_GQL",
    "INGEST_TEXT_GQL",
    "INGEST_URI_GQL",
    "IS_CONTENT_DONE_GQL",
    "IS_FEED_DONE_GQL",
    "ImageMetadataInput",
    "ImageProjectionTypes",
    "IndexingWorkflowJobInput",
    "IndexingWorkflowStageInput",
    "IngestBatch",
    "IngestBatchIngestBatch",
    "IngestBatchIngestBatchCollections",
    "IngestBatchIngestBatchObservations",
    "IngestBatchIngestBatchObservationsObservable",
    "IngestBatchIngestBatchObservationsOccurrences",
    "IngestBatchIngestBatchObservationsOccurrencesBoundingBox",
    "IngestBatchIngestBatchObservationsRelated",
    "IngestEncodedFile",
    "IngestEncodedFileIngestEncodedFile",
    "IngestEncodedFileIngestEncodedFileCollections",
    "IngestEncodedFileIngestEncodedFileObservations",
    "IngestEncodedFileIngestEncodedFileObservationsObservable",
    "IngestEncodedFileIngestEncodedFileObservationsOccurrences",
    "IngestEncodedFileIngestEncodedFileObservationsOccurrencesBoundingBox",
    "IngestEncodedFileIngestEncodedFileObservationsRelated",
    "IngestMemory",
    "IngestMemoryIngestMemory",
    "IngestMemoryIngestMemoryCollections",
    "IngestMemoryIngestMemoryObservations",
    "IngestMemoryIngestMemoryObservationsObservable",
    "IngestMemoryIngestMemoryObservationsOccurrences",
    "IngestMemoryIngestMemoryObservationsOccurrencesBoundingBox",
    "IngestMemoryIngestMemoryObservationsRelated",
    "IngestText",
    "IngestTextBatch",
    "IngestTextBatchIngestTextBatch",
    "IngestTextBatchIngestTextBatchCollections",
    "IngestTextBatchIngestTextBatchObservations",
    "IngestTextBatchIngestTextBatchObservationsObservable",
    "IngestTextBatchIngestTextBatchObservationsOccurrences",
    "IngestTextBatchIngestTextBatchObservationsOccurrencesBoundingBox",
    "IngestTextBatchIngestTextBatchObservationsRelated",
    "IngestTextIngestText",
    "IngestTextIngestTextCollections",
    "IngestTextIngestTextObservations",
    "IngestTextIngestTextObservationsObservable",
    "IngestTextIngestTextObservationsOccurrences",
    "IngestTextIngestTextObservationsOccurrencesBoundingBox",
    "IngestTextIngestTextObservationsRelated",
    "IngestUri",
    "IngestUriIngestUri",
    "IngestUriIngestUriCollections",
    "IngestUriIngestUriObservations",
    "IngestUriIngestUriObservationsObservable",
    "IngestUriIngestUriObservationsOccurrences",
    "IngestUriIngestUriObservationsOccurrencesBoundingBox",
    "IngestUriIngestUriObservationsRelated",
    "IngestionContentFilterInput",
    "IngestionWorkflowStageInput",
    "Int64RangeFilter",
    "IntegrationConnectorInput",
    "IntegrationConnectorUpdateInput",
    "IntegrationServiceTypes",
    "IntercomFeedPropertiesInput",
    "IntercomFeedPropertiesUpdateInput",
    "IntercomTicketsFeedPropertiesInput",
    "IntercomTicketsFeedPropertiesUpdateInput",
    "IsContentDone",
    "IsContentDoneIsContentDone",
    "IsFeedDone",
    "IsFeedDoneIsFeedDone",
    "IssueFeedPropertiesInput",
    "IssueFeedPropertiesUpdateInput",
    "IssueMetadataInput",
    "JinaModelPropertiesInput",
    "JinaModelPropertiesUpdateInput",
    "JinaModels",
    "LOOKUP_CREDITS_GQL",
    "LOOKUP_USAGE_GQL",
    "LabelFacetInput",
    "LabelFacetTypes",
    "LabelFilter",
    "LabelInput",
    "LabelUpdateInput",
    "LanguageMetadataInput",
    "LinearFeedPropertiesInput",
    "LinearFeedPropertiesUpdateInput",
    "LinearProjectsInput",
    "LinkStrategyInput",
    "LinkTypes",
    "LookupCredits",
    "LookupCreditsLookupCredits",
    "LookupUsage",
    "LookupUsageLookupUsage",
    "MAP_WEB_GQL",
    "MailImportance",
    "MailPriority",
    "MailSensitivity",
    "MapWeb",
    "MapWebMapWeb",
    "MedicalConditionFacetInput",
    "MedicalConditionFacetTypes",
    "MedicalConditionFilter",
    "MedicalConditionInput",
    "MedicalConditionUpdateInput",
    "MedicalContraindicationFacetInput",
    "MedicalContraindicationFacetTypes",
    "MedicalContraindicationFilter",
    "MedicalContraindicationInput",
    "MedicalContraindicationUpdateInput",
    "MedicalDeviceFacetInput",
    "MedicalDeviceFacetTypes",
    "MedicalDeviceFilter",
    "MedicalDeviceInput",
    "MedicalDeviceUpdateInput",
    "MedicalDrugClassFacetInput",
    "MedicalDrugClassFacetTypes",
    "MedicalDrugClassFilter",
    "MedicalDrugClassInput",
    "MedicalDrugClassUpdateInput",
    "MedicalDrugFacetInput",
    "MedicalDrugFacetTypes",
    "MedicalDrugFilter",
    "MedicalDrugInput",
    "MedicalDrugUpdateInput",
    "MedicalGuidelineFacetInput",
    "MedicalGuidelineFacetTypes",
    "MedicalGuidelineFilter",
    "MedicalGuidelineInput",
    "MedicalGuidelineUpdateInput",
    "MedicalIndicationFacetInput",
    "MedicalIndicationFacetTypes",
    "MedicalIndicationFilter",
    "MedicalIndicationInput",
    "MedicalIndicationUpdateInput",
    "MedicalProcedureFacetInput",
    "MedicalProcedureFacetTypes",
    "MedicalProcedureFilter",
    "MedicalProcedureInput",
    "MedicalProcedureUpdateInput",
    "MedicalStudyFacetInput",
    "MedicalStudyFacetTypes",
    "MedicalStudyFilter",
    "MedicalStudyInput",
    "MedicalStudyUpdateInput",
    "MedicalTestFacetInput",
    "MedicalTestFacetTypes",
    "MedicalTestFilter",
    "MedicalTestInput",
    "MedicalTestUpdateInput",
    "MedicalTherapyFacetInput",
    "MedicalTherapyFacetTypes",
    "MedicalTherapyFilter",
    "MedicalTherapyInput",
    "MedicalTherapyUpdateInput",
    "MetadataFilter",
    "MetadataInput",
    "MetadataTypes",
    "MetadataUpdateInput",
    "MicrosoftAuthenticationPropertiesInput",
    "MicrosoftEmailFeedPropertiesInput",
    "MicrosoftEmailFeedPropertiesUpdateInput",
    "MicrosoftTeamsChannelsInput",
    "MicrosoftTeamsFeedPropertiesInput",
    "MicrosoftTeamsFeedPropertiesUpdateInput",
    "MicrosoftTeamsTeamsInput",
    "MistralDocumentPreparationPropertiesInput",
    "MistralModelPropertiesInput",
    "MistralModelPropertiesUpdateInput",
    "MistralModels",
    "ModelContentClassificationPropertiesInput",
    "ModelDocumentPreparationPropertiesInput",
    "ModelFilter",
    "ModelImageExtractionPropertiesInput",
    "ModelServiceTypes",
    "ModelTextExtractionPropertiesInput",
    "ModelTypes",
    "NamedEntityReferenceInput",
    "NotionDatabasesInput",
    "NotionFeedPropertiesInput",
    "NotionFeedPropertiesUpdateInput",
    "NotionPagesInput",
    "NotionTypes",
    "ObservableTypes",
    "ObservationCriteriaInput",
    "ObservationInput",
    "ObservationOccurrenceInput",
    "ObservationReferenceFilter",
    "ObservationReferenceInput",
    "ObservationUpdateInput",
    "OccurrenceTypes",
    "OneDriveFeedPropertiesInput",
    "OneDriveFeedPropertiesUpdateInput",
    "OneDriveFoldersInput",
    "OpenAIImageModels",
    "OpenAIImagePublishingPropertiesInput",
    "OpenAIModelPropertiesInput",
    "OpenAIModelPropertiesUpdateInput",
    "OpenAIModels",
    "OpenAIReasoningEffortLevels",
    "OpenAIVisionDetailLevels",
    "OperationTypes",
    "OrderByTypes",
    "OrderDirectionTypes",
    "OrganizationFacetInput",
    "OrganizationFacetTypes",
    "OrganizationFilter",
    "OrganizationInput",
    "OrganizationUpdateInput",
    "OrientationTypes",
    "PROMPT_CONVERSATION_GQL",
    "PROMPT_GQL",
    "PROMPT_SPECIFICATIONS_GQL",
    "PUBLISH_CONTENTS_GQL",
    "PUBLISH_CONVERSATION_GQL",
    "PUBLISH_TEXT_GQL",
    "PackageMetadataInput",
    "PagePreparationPropertiesInput",
    "PersonFacetInput",
    "PersonFacetTypes",
    "PersonFilter",
    "PersonInput",
    "PersonUpdateInput",
    "PlaceFacetInput",
    "PlaceFacetTypes",
    "PlaceFilter",
    "PlaceInput",
    "PlaceUpdateInput",
    "PointCloudMetadataInput",
    "PointFilter",
    "PointInput",
    "PolicyTimeTypes",
    "PreparationWorkflowJobInput",
    "PreparationWorkflowStageInput",
    "ProductFacetInput",
    "ProductFacetTypes",
    "ProductFilter",
    "ProductInput",
    "ProductUpdateInput",
    "ProjectFilter",
    "ProjectInput",
    "ProjectQuotaInput",
    "ProjectUpdateInput",
    "Prompt",
    "PromptClassificationRuleInput",
    "PromptConversation",
    "PromptConversationPromptConversation",
    "PromptConversationPromptConversationConversation",
    "PromptConversationPromptConversationDetails",
    "PromptConversationPromptConversationDetailsMessages",
    "PromptConversationPromptConversationDetailsMessagesCitations",
    "PromptConversationPromptConversationDetailsMessagesCitationsContent",
    "PromptConversationPromptConversationDetailsMessagesCitationsContentAudio",
    "PromptConversationPromptConversationDetailsMessagesCitationsContentDocument",
    "PromptConversationPromptConversationDetailsMessagesCitationsContentImage",
    "PromptConversationPromptConversationDetailsMessagesCitationsContentVideo",
    "PromptConversationPromptConversationDetailsMessagesToolCalls",
    "PromptConversationPromptConversationFacets",
    "PromptConversationPromptConversationFacetsObservable",
    "PromptConversationPromptConversationFacetsObservableObservable",
    "PromptConversationPromptConversationFacetsRange",
    "PromptConversationPromptConversationGraph",
    "PromptConversationPromptConversationGraphEdges",
    "PromptConversationPromptConversationGraphNodes",
    "PromptConversationPromptConversationMessage",
    "PromptConversationPromptConversationMessageCitations",
    "PromptConversationPromptConversationMessageCitationsContent",
    "PromptConversationPromptConversationMessageCitationsContentAudio",
    "PromptConversationPromptConversationMessageCitationsContentDocument",
    "PromptConversationPromptConversationMessageCitationsContentImage",
    "PromptConversationPromptConversationMessageCitationsContentVideo",
    "PromptConversationPromptConversationMessageToolCalls",
    "PromptPrompt",
    "PromptPromptMessages",
    "PromptPromptMessagesCitations",
    "PromptPromptMessagesCitationsContent",
    "PromptPromptMessagesCitationsContentAudio",
    "PromptPromptMessagesCitationsContentDocument",
    "PromptPromptMessagesCitationsContentImage",
    "PromptPromptMessagesCitationsContentVideo",
    "PromptPromptMessagesToolCalls",
    "PromptPromptSpecification",
    "PromptSpecifications",
    "PromptSpecificationsPromptSpecifications",
    "PromptSpecificationsPromptSpecificationsMessages",
    "PromptSpecificationsPromptSpecificationsMessagesCitations",
    "PromptSpecificationsPromptSpecificationsMessagesCitationsContent",
    "PromptSpecificationsPromptSpecificationsMessagesCitationsContentAudio",
    "PromptSpecificationsPromptSpecificationsMessagesCitationsContentDocument",
    "PromptSpecificationsPromptSpecificationsMessagesCitationsContentImage",
    "PromptSpecificationsPromptSpecificationsMessagesCitationsContentVideo",
    "PromptSpecificationsPromptSpecificationsMessagesToolCalls",
    "PromptSpecificationsPromptSpecificationsSpecification",
    "PromptStrategyInput",
    "PromptStrategyTypes",
    "PromptStrategyUpdateInput",
    "PublishContents",
    "PublishContentsPublishContents",
    "PublishContentsPublishContentsContents",
    "PublishContentsPublishContentsContentsAudio",
    "PublishContentsPublishContentsContentsDocument",
    "PublishContentsPublishContentsContentsImage",
    "PublishContentsPublishContentsContentsVideo",
    "PublishContentsPublishContentsDetails",
    "PublishContentsPublishContentsDetailsContents",
    "PublishConversation",
    "PublishConversationPublishConversation",
    "PublishConversationPublishConversationContents",
    "PublishConversationPublishConversationContentsAudio",
    "PublishConversationPublishConversationContentsDocument",
    "PublishConversationPublishConversationContentsImage",
    "PublishConversationPublishConversationContentsVideo",
    "PublishConversationPublishConversationDetails",
    "PublishConversationPublishConversationDetailsContents",
    "PublishText",
    "PublishTextPublishText",
    "PublishTextPublishTextContents",
    "PublishTextPublishTextContentsAudio",
    "PublishTextPublishTextContentsDocument",
    "PublishTextPublishTextContentsImage",
    "PublishTextPublishTextContentsVideo",
    "PublishTextPublishTextDetails",
    "PublishTextPublishTextDetailsContents",
    "QUERY_ALERTS_GQL",
    "QUERY_CATEGORIES_GQL",
    "QUERY_COLLECTIONS_GQL",
    "QUERY_CONTENTS_FACETS_GQL",
    "QUERY_CONTENTS_GQL",
    "QUERY_CONTENTS_GRAPH_GQL",
    "QUERY_CONVERSATIONS_GQL",
    "QUERY_CREDITS_GQL",
    "QUERY_EVENTS_GQL",
    "QUERY_FEEDS_GQL",
    "QUERY_LABELS_GQL",
    "QUERY_LINEAR_PROJECTS_GQL",
    "QUERY_MEDICAL_CONDITIONS_GQL",
    "QUERY_MEDICAL_CONTRAINDICATIONS_GQL",
    "QUERY_MEDICAL_DEVICES_GQL",
    "QUERY_MEDICAL_DRUGS_GQL",
    "QUERY_MEDICAL_DRUG_CLASSES_GQL",
    "QUERY_MEDICAL_GUIDELINES_GQL",
    "QUERY_MEDICAL_INDICATIONS_GQL",
    "QUERY_MEDICAL_PROCEDURES_GQL",
    "QUERY_MEDICAL_STUDIES_GQL",
    "QUERY_MEDICAL_TESTS_GQL",
    "QUERY_MEDICAL_THERAPIES_GQL",
    "QUERY_MICROSOFT_TEAMS_CHANNELS_GQL",
    "QUERY_MICROSOFT_TEAMS_TEAMS_GQL",
    "QUERY_MODELS_GQL",
    "QUERY_NOTION_DATABASES_GQL",
    "QUERY_NOTION_PAGES_GQL",
    "QUERY_ONE_DRIVE_FOLDERS_GQL",
    "QUERY_ORGANIZATIONS_GQL",
    "QUERY_PERSONS_GQL",
    "QUERY_PLACES_GQL",
    "QUERY_PRODUCTS_GQL",
    "QUERY_REPOS_GQL",
    "QUERY_SHARE_POINT_FOLDERS_GQL",
    "QUERY_SHARE_POINT_LIBRARIES_GQL",
    "QUERY_SLACK_CHANNELS_GQL",
    "QUERY_SOFTWARES_GQL",
    "QUERY_SPECIFICATIONS_GQL",
    "QUERY_TOKENS_GQL",
    "QUERY_USAGE_GQL",
    "QUERY_USERS_GQL",
    "QUERY_WORKFLOWS_GQL",
    "QueryAlerts",
    "QueryAlertsAlerts",
    "QueryAlertsAlertsResults",
    "QueryAlertsAlertsResultsFilter",
    "QueryAlertsAlertsResultsFilterAnd",
    "QueryAlertsAlertsResultsFilterAndCollections",
    "QueryAlertsAlertsResultsFilterAndFeeds",
    "QueryAlertsAlertsResultsFilterAndObservations",
    "QueryAlertsAlertsResultsFilterAndObservationsObservable",
    "QueryAlertsAlertsResultsFilterAndUsers",
    "QueryAlertsAlertsResultsFilterAndWorkflows",
    "QueryAlertsAlertsResultsFilterCollections",
    "QueryAlertsAlertsResultsFilterContents",
    "QueryAlertsAlertsResultsFilterCreationDateRange",
    "QueryAlertsAlertsResultsFilterDateRange",
    "QueryAlertsAlertsResultsFilterFeeds",
    "QueryAlertsAlertsResultsFilterObservations",
    "QueryAlertsAlertsResultsFilterObservationsObservable",
    "QueryAlertsAlertsResultsFilterOr",
    "QueryAlertsAlertsResultsFilterOrCollections",
    "QueryAlertsAlertsResultsFilterOrFeeds",
    "QueryAlertsAlertsResultsFilterOrObservations",
    "QueryAlertsAlertsResultsFilterOrObservationsObservable",
    "QueryAlertsAlertsResultsFilterOrUsers",
    "QueryAlertsAlertsResultsFilterOrWorkflows",
    "QueryAlertsAlertsResultsFilterSimilarContents",
    "QueryAlertsAlertsResultsFilterUsers",
    "QueryAlertsAlertsResultsFilterWorkflows",
    "QueryAlertsAlertsResultsIntegration",
    "QueryAlertsAlertsResultsIntegrationEmail",
    "QueryAlertsAlertsResultsIntegrationSlack",
    "QueryAlertsAlertsResultsIntegrationTwitter",
    "QueryAlertsAlertsResultsOwner",
    "QueryAlertsAlertsResultsPublishSpecification",
    "QueryAlertsAlertsResultsPublishing",
    "QueryAlertsAlertsResultsPublishingElevenLabs",
    "QueryAlertsAlertsResultsPublishingOpenAiImage",
    "QueryAlertsAlertsResultsPublishingOpenAiImageSeed",
    "QueryAlertsAlertsResultsSummarySpecification",
    "QueryCategories",
    "QueryCategoriesCategories",
    "QueryCategoriesCategoriesResults",
    "QueryCollections",
    "QueryCollectionsCollections",
    "QueryCollectionsCollectionsResults",
    "QueryCollectionsCollectionsResultsContents",
    "QueryCollectionsCollectionsResultsOwner",
    "QueryContents",
    "QueryContentsContents",
    "QueryContentsContentsResults",
    "QueryContentsContentsResultsAddress",
    "QueryContentsContentsResultsAudio",
    "QueryContentsContentsResultsCollections",
    "QueryContentsContentsResultsDocument",
    "QueryContentsContentsResultsEmail",
    "QueryContentsContentsResultsEmailBcc",
    "QueryContentsContentsResultsEmailCc",
    "QueryContentsContentsResultsEmailFrom",
    "QueryContentsContentsResultsEmailTo",
    "QueryContentsContentsResultsFeed",
    "QueryContentsContentsResultsFrames",
    "QueryContentsContentsResultsImage",
    "QueryContentsContentsResultsIssue",
    "QueryContentsContentsResultsLanguage",
    "QueryContentsContentsResultsLinks",
    "QueryContentsContentsResultsLocation",
    "QueryContentsContentsResultsObservations",
    "QueryContentsContentsResultsObservationsObservable",
    "QueryContentsContentsResultsObservationsOccurrences",
    "QueryContentsContentsResultsObservationsOccurrencesBoundingBox",
    "QueryContentsContentsResultsObservationsRelated",
    "QueryContentsContentsResultsOwner",
    "QueryContentsContentsResultsPackage",
    "QueryContentsContentsResultsPages",
    "QueryContentsContentsResultsPagesChunks",
    "QueryContentsContentsResultsPagesImages",
    "QueryContentsContentsResultsSegments",
    "QueryContentsContentsResultsVideo",
    "QueryContentsContentsResultsWorkflow",
    "QueryContentsFacets",
    "QueryContentsFacetsContents",
    "QueryContentsFacetsContentsFacets",
    "QueryContentsFacetsContentsFacetsObservable",
    "QueryContentsFacetsContentsFacetsObservableObservable",
    "QueryContentsFacetsContentsFacetsRange",
    "QueryContentsGraph",
    "QueryContentsGraphContents",
    "QueryContentsGraphContentsGraph",
    "QueryContentsGraphContentsGraphEdges",
    "QueryContentsGraphContentsGraphNodes",
    "QueryConversations",
    "QueryConversationsConversations",
    "QueryConversationsConversationsResults",
    "QueryConversationsConversationsResultsAugmentedFilter",
    "QueryConversationsConversationsResultsAugmentedFilterAnd",
    "QueryConversationsConversationsResultsAugmentedFilterAndCollections",
    "QueryConversationsConversationsResultsAugmentedFilterAndFeeds",
    "QueryConversationsConversationsResultsAugmentedFilterAndObservations",
    "QueryConversationsConversationsResultsAugmentedFilterAndObservationsObservable",
    "QueryConversationsConversationsResultsAugmentedFilterAndUsers",
    "QueryConversationsConversationsResultsAugmentedFilterAndWorkflows",
    "QueryConversationsConversationsResultsAugmentedFilterCollections",
    "QueryConversationsConversationsResultsAugmentedFilterContents",
    "QueryConversationsConversationsResultsAugmentedFilterCreationDateRange",
    "QueryConversationsConversationsResultsAugmentedFilterDateRange",
    "QueryConversationsConversationsResultsAugmentedFilterFeeds",
    "QueryConversationsConversationsResultsAugmentedFilterObservations",
    "QueryConversationsConversationsResultsAugmentedFilterObservationsObservable",
    "QueryConversationsConversationsResultsAugmentedFilterOr",
    "QueryConversationsConversationsResultsAugmentedFilterOrCollections",
    "QueryConversationsConversationsResultsAugmentedFilterOrFeeds",
    "QueryConversationsConversationsResultsAugmentedFilterOrObservations",
    "QueryConversationsConversationsResultsAugmentedFilterOrObservationsObservable",
    "QueryConversationsConversationsResultsAugmentedFilterOrUsers",
    "QueryConversationsConversationsResultsAugmentedFilterOrWorkflows",
    "QueryConversationsConversationsResultsAugmentedFilterSimilarContents",
    "QueryConversationsConversationsResultsAugmentedFilterUsers",
    "QueryConversationsConversationsResultsAugmentedFilterWorkflows",
    "QueryConversationsConversationsResultsFallbacks",
    "QueryConversationsConversationsResultsFilter",
    "QueryConversationsConversationsResultsFilterAnd",
    "QueryConversationsConversationsResultsFilterAndCollections",
    "QueryConversationsConversationsResultsFilterAndFeeds",
    "QueryConversationsConversationsResultsFilterAndObservations",
    "QueryConversationsConversationsResultsFilterAndObservationsObservable",
    "QueryConversationsConversationsResultsFilterAndUsers",
    "QueryConversationsConversationsResultsFilterAndWorkflows",
    "QueryConversationsConversationsResultsFilterCollections",
    "QueryConversationsConversationsResultsFilterContents",
    "QueryConversationsConversationsResultsFilterCreationDateRange",
    "QueryConversationsConversationsResultsFilterDateRange",
    "QueryConversationsConversationsResultsFilterFeeds",
    "QueryConversationsConversationsResultsFilterObservations",
    "QueryConversationsConversationsResultsFilterObservationsObservable",
    "QueryConversationsConversationsResultsFilterOr",
    "QueryConversationsConversationsResultsFilterOrCollections",
    "QueryConversationsConversationsResultsFilterOrFeeds",
    "QueryConversationsConversationsResultsFilterOrObservations",
    "QueryConversationsConversationsResultsFilterOrObservationsObservable",
    "QueryConversationsConversationsResultsFilterOrUsers",
    "QueryConversationsConversationsResultsFilterOrWorkflows",
    "QueryConversationsConversationsResultsFilterSimilarContents",
    "QueryConversationsConversationsResultsFilterUsers",
    "QueryConversationsConversationsResultsFilterWorkflows",
    "QueryConversationsConversationsResultsMessages",
    "QueryConversationsConversationsResultsMessagesCitations",
    "QueryConversationsConversationsResultsMessagesCitationsContent",
    "QueryConversationsConversationsResultsMessagesCitationsContentAudio",
    "QueryConversationsConversationsResultsMessagesCitationsContentDocument",
    "QueryConversationsConversationsResultsMessagesCitationsContentImage",
    "QueryConversationsConversationsResultsMessagesCitationsContentVideo",
    "QueryConversationsConversationsResultsMessagesToolCalls",
    "QueryConversationsConversationsResultsOwner",
    "QueryConversationsConversationsResultsSpecification",
    "QueryCredits",
    "QueryCreditsCredits",
    "QueryEvents",
    "QueryEventsEvents",
    "QueryEventsEventsResults",
    "QueryEventsEventsResultsAddress",
    "QueryFeeds",
    "QueryFeedsFeeds",
    "QueryFeedsFeedsResults",
    "QueryFeedsFeedsResultsDiscord",
    "QueryFeedsFeedsResultsEmail",
    "QueryFeedsFeedsResultsEmailGoogle",
    "QueryFeedsFeedsResultsEmailMicrosoft",
    "QueryFeedsFeedsResultsIntercom",
    "QueryFeedsFeedsResultsIssue",
    "QueryFeedsFeedsResultsIssueGithub",
    "QueryFeedsFeedsResultsIssueIntercom",
    "QueryFeedsFeedsResultsIssueJira",
    "QueryFeedsFeedsResultsIssueLinear",
    "QueryFeedsFeedsResultsIssueTrello",
    "QueryFeedsFeedsResultsIssueZendesk",
    "QueryFeedsFeedsResultsMicrosoftTeams",
    "QueryFeedsFeedsResultsNotion",
    "QueryFeedsFeedsResultsOwner",
    "QueryFeedsFeedsResultsReddit",
    "QueryFeedsFeedsResultsRss",
    "QueryFeedsFeedsResultsSchedulePolicy",
    "QueryFeedsFeedsResultsSearch",
    "QueryFeedsFeedsResultsSite",
    "QueryFeedsFeedsResultsSiteAzureBlob",
    "QueryFeedsFeedsResultsSiteAzureFile",
    "QueryFeedsFeedsResultsSiteBox",
    "QueryFeedsFeedsResultsSiteDropbox",
    "QueryFeedsFeedsResultsSiteGithub",
    "QueryFeedsFeedsResultsSiteGoogle",
    "QueryFeedsFeedsResultsSiteGoogleDrive",
    "QueryFeedsFeedsResultsSiteOneDrive",
    "QueryFeedsFeedsResultsSiteS3",
    "QueryFeedsFeedsResultsSiteSharePoint",
    "QueryFeedsFeedsResultsSlack",
    "QueryFeedsFeedsResultsTwitter",
    "QueryFeedsFeedsResultsWeb",
    "QueryFeedsFeedsResultsWorkflow",
    "QueryFeedsFeedsResultsYoutube",
    "QueryFeedsFeedsResultsZendesk",
    "QueryLabels",
    "QueryLabelsLabels",
    "QueryLabelsLabelsResults",
    "QueryLinearProjects",
    "QueryLinearProjectsLinearProjects",
    "QueryMedicalConditions",
    "QueryMedicalConditionsMedicalConditions",
    "QueryMedicalConditionsMedicalConditionsResults",
    "QueryMedicalContraindications",
    "QueryMedicalContraindicationsMedicalContraindications",
    "QueryMedicalContraindicationsMedicalContraindicationsResults",
    "QueryMedicalDevices",
    "QueryMedicalDevicesMedicalDevices",
    "QueryMedicalDevicesMedicalDevicesResults",
    "QueryMedicalDrugClasses",
    "QueryMedicalDrugClassesMedicalDrugClasses",
    "QueryMedicalDrugClassesMedicalDrugClassesResults",
    "QueryMedicalDrugs",
    "QueryMedicalDrugsMedicalDrugs",
    "QueryMedicalDrugsMedicalDrugsResults",
    "QueryMedicalGuidelines",
    "QueryMedicalGuidelinesMedicalGuidelines",
    "QueryMedicalGuidelinesMedicalGuidelinesResults",
    "QueryMedicalIndications",
    "QueryMedicalIndicationsMedicalIndications",
    "QueryMedicalIndicationsMedicalIndicationsResults",
    "QueryMedicalProcedures",
    "QueryMedicalProceduresMedicalProcedures",
    "QueryMedicalProceduresMedicalProceduresResults",
    "QueryMedicalStudies",
    "QueryMedicalStudiesMedicalStudies",
    "QueryMedicalStudiesMedicalStudiesResults",
    "QueryMedicalStudiesMedicalStudiesResultsAddress",
    "QueryMedicalTests",
    "QueryMedicalTestsMedicalTests",
    "QueryMedicalTestsMedicalTestsResults",
    "QueryMedicalTherapies",
    "QueryMedicalTherapiesMedicalTherapies",
    "QueryMedicalTherapiesMedicalTherapiesResults",
    "QueryMicrosoftTeamsChannels",
    "QueryMicrosoftTeamsChannelsMicrosoftTeamsChannels",
    "QueryMicrosoftTeamsChannelsMicrosoftTeamsChannelsResults",
    "QueryMicrosoftTeamsTeams",
    "QueryMicrosoftTeamsTeamsMicrosoftTeamsTeams",
    "QueryMicrosoftTeamsTeamsMicrosoftTeamsTeamsResults",
    "QueryModels",
    "QueryModelsModels",
    "QueryModelsModelsResults",
    "QueryModelsModelsResultsFeatures",
    "QueryModelsModelsResultsMetadata",
    "QueryNotionDatabases",
    "QueryNotionDatabasesNotionDatabases",
    "QueryNotionPages",
    "QueryNotionPagesNotionPages",
    "QueryOneDriveFolders",
    "QueryOneDriveFoldersOneDriveFolders",
    "QueryOneDriveFoldersOneDriveFoldersResults",
    "QueryOrganizations",
    "QueryOrganizationsOrganizations",
    "QueryOrganizationsOrganizationsResults",
    "QueryOrganizationsOrganizationsResultsAddress",
    "QueryPersons",
    "QueryPersonsPersons",
    "QueryPersonsPersonsResults",
    "QueryPersonsPersonsResultsAddress",
    "QueryPlaces",
    "QueryPlacesPlaces",
    "QueryPlacesPlacesResults",
    "QueryPlacesPlacesResultsAddress",
    "QueryProducts",
    "QueryProductsProducts",
    "QueryProductsProductsResults",
    "QueryProductsProductsResultsAddress",
    "QueryRepos",
    "QueryReposRepos",
    "QueryReposReposResults",
    "QuerySharePointFolders",
    "QuerySharePointFoldersSharePointFolders",
    "QuerySharePointFoldersSharePointFoldersResults",
    "QuerySharePointLibraries",
    "QuerySharePointLibrariesSharePointLibraries",
    "QuerySharePointLibrariesSharePointLibrariesResults",
    "QuerySlackChannels",
    "QuerySlackChannelsSlackChannels",
    "QuerySoftwares",
    "QuerySoftwaresSoftwares",
    "QuerySoftwaresSoftwaresResults",
    "QuerySpecifications",
    "QuerySpecificationsSpecifications",
    "QuerySpecificationsSpecificationsResults",
    "QuerySpecificationsSpecificationsResultsAnthropic",
    "QuerySpecificationsSpecificationsResultsAzureAi",
    "QuerySpecificationsSpecificationsResultsAzureOpenAi",
    "QuerySpecificationsSpecificationsResultsBedrock",
    "QuerySpecificationsSpecificationsResultsCerebras",
    "QuerySpecificationsSpecificationsResultsCohere",
    "QuerySpecificationsSpecificationsResultsDeepseek",
    "QuerySpecificationsSpecificationsResultsGoogle",
    "QuerySpecificationsSpecificationsResultsGraphStrategy",
    "QuerySpecificationsSpecificationsResultsGroq",
    "QuerySpecificationsSpecificationsResultsJina",
    "QuerySpecificationsSpecificationsResultsMistral",
    "QuerySpecificationsSpecificationsResultsOpenAi",
    "QuerySpecificationsSpecificationsResultsOwner",
    "QuerySpecificationsSpecificationsResultsPromptStrategy",
    "QuerySpecificationsSpecificationsResultsReplicate",
    "QuerySpecificationsSpecificationsResultsRerankingStrategy",
    "QuerySpecificationsSpecificationsResultsRetrievalStrategy",
    "QuerySpecificationsSpecificationsResultsRevisionStrategy",
    "QuerySpecificationsSpecificationsResultsStrategy",
    "QuerySpecificationsSpecificationsResultsVoyage",
    "QueryTokens",
    "QueryTokensTokens",
    "QueryUsage",
    "QueryUsageUsage",
    "QueryUsers",
    "QueryUsersUsers",
    "QueryUsersUsersResults",
    "QueryUsersUsersResultsConnectors",
    "QueryUsersUsersResultsConnectorsAuthentication",
    "QueryUsersUsersResultsConnectorsAuthenticationGoogle",
    "QueryUsersUsersResultsConnectorsAuthenticationMicrosoft",
    "QueryUsersUsersResultsConnectorsIntegration",
    "QueryUsersUsersResultsConnectorsIntegrationEmail",
    "QueryUsersUsersResultsConnectorsIntegrationSlack",
    "QueryUsersUsersResultsConnectorsIntegrationTwitter",
    "QueryUsersUsersResultsOwner",
    "QueryWorkflows",
    "QueryWorkflowsWorkflows",
    "QueryWorkflowsWorkflowsResults",
    "QueryWorkflowsWorkflowsResultsActions",
    "QueryWorkflowsWorkflowsResultsActionsConnector",
    "QueryWorkflowsWorkflowsResultsActionsConnectorEmail",
    "QueryWorkflowsWorkflowsResultsActionsConnectorSlack",
    "QueryWorkflowsWorkflowsResultsActionsConnectorTwitter",
    "QueryWorkflowsWorkflowsResultsClassification",
    "QueryWorkflowsWorkflowsResultsClassificationJobs",
    "QueryWorkflowsWorkflowsResultsClassificationJobsConnector",
    "QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModel",
    "QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModelRules",
    "QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModelSpecification",
    "QueryWorkflowsWorkflowsResultsClassificationJobsConnectorRegex",
    "QueryWorkflowsWorkflowsResultsClassificationJobsConnectorRegexRules",
    "QueryWorkflowsWorkflowsResultsEnrichment",
    "QueryWorkflowsWorkflowsResultsEnrichmentJobs",
    "QueryWorkflowsWorkflowsResultsEnrichmentJobsConnector",
    "QueryWorkflowsWorkflowsResultsEnrichmentJobsConnectorDiffbot",
    "QueryWorkflowsWorkflowsResultsEnrichmentJobsConnectorFhir",
    "QueryWorkflowsWorkflowsResultsEnrichmentLink",
    "QueryWorkflowsWorkflowsResultsExtraction",
    "QueryWorkflowsWorkflowsResultsExtractionJobs",
    "QueryWorkflowsWorkflowsResultsExtractionJobsConnector",
    "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorAzureImage",
    "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorAzureText",
    "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelImage",
    "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelImageSpecification",
    "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelText",
    "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelTextSpecification",
    "QueryWorkflowsWorkflowsResultsIndexing",
    "QueryWorkflowsWorkflowsResultsIndexingJobs",
    "QueryWorkflowsWorkflowsResultsIndexingJobsConnector",
    "QueryWorkflowsWorkflowsResultsIngestion",
    "QueryWorkflowsWorkflowsResultsIngestionCollections",
    "QueryWorkflowsWorkflowsResultsIngestionIf",
    "QueryWorkflowsWorkflowsResultsIngestionObservations",
    "QueryWorkflowsWorkflowsResultsIngestionObservationsObservable",
    "QueryWorkflowsWorkflowsResultsOwner",
    "QueryWorkflowsWorkflowsResultsPreparation",
    "QueryWorkflowsWorkflowsResultsPreparationJobs",
    "QueryWorkflowsWorkflowsResultsPreparationJobsConnector",
    "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorAssemblyAi",
    "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorAzureDocument",
    "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorDeepgram",
    "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorDocument",
    "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorEmail",
    "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorMistral",
    "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorModelDocument",
    "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorModelDocumentSpecification",
    "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorPage",
    "QueryWorkflowsWorkflowsResultsPreparationSummarizations",
    "QueryWorkflowsWorkflowsResultsPreparationSummarizationsSpecification",
    "QueryWorkflowsWorkflowsResultsStorage",
    "QueryWorkflowsWorkflowsResultsStoragePolicy",
    "REMOVE_CONTENTS_FROM_COLLECTION_GQL",
    "RETRIEVE_SOURCES_GQL",
    "REVISE_CONTENT_GQL",
    "REVISE_ENCODED_IMAGE_GQL",
    "REVISE_IMAGE_GQL",
    "REVISE_TEXT_GQL",
    "RSSFeedPropertiesInput",
    "RSSFeedPropertiesUpdateInput",
    "RedditFeedPropertiesInput",
    "RedditFeedPropertiesUpdateInput",
    "RegexClassificationRuleInput",
    "RegexContentClassificationPropertiesInput",
    "RegexSourceTypes",
    "RemoveContentsFromCollection",
    "RemoveContentsFromCollectionRemoveContentsFromCollection",
    "RemoveContentsFromCollectionRemoveContentsFromCollectionContents",
    "RenditionTypes",
    "ReplicateModelPropertiesInput",
    "ReplicateModelPropertiesUpdateInput",
    "ReplicateModels",
    "RepoFacetInput",
    "RepoFacetTypes",
    "RepoFilter",
    "RepoInput",
    "RepoUpdateInput",
    "RerankingModelServiceTypes",
    "RerankingStrategyInput",
    "RerankingStrategyUpdateInput",
    "ResourceConnectorTypes",
    "RetrievalStrategyInput",
    "RetrievalStrategyTypes",
    "RetrievalStrategyUpdateInput",
    "RetrieveSources",
    "RetrieveSourcesRetrieveSources",
    "RetrieveSourcesRetrieveSourcesResults",
    "RetrieveSourcesRetrieveSourcesResultsContent",
    "ReviseContent",
    "ReviseContentReviseContent",
    "ReviseContentReviseContentConversation",
    "ReviseContentReviseContentMessage",
    "ReviseContentReviseContentMessageCitations",
    "ReviseContentReviseContentMessageCitationsContent",
    "ReviseContentReviseContentMessageCitationsContentAudio",
    "ReviseContentReviseContentMessageCitationsContentDocument",
    "ReviseContentReviseContentMessageCitationsContentImage",
    "ReviseContentReviseContentMessageCitationsContentVideo",
    "ReviseContentReviseContentMessageToolCalls",
    "ReviseEncodedImage",
    "ReviseEncodedImageReviseEncodedImage",
    "ReviseEncodedImageReviseEncodedImageConversation",
    "ReviseEncodedImageReviseEncodedImageMessage",
    "ReviseEncodedImageReviseEncodedImageMessageCitations",
    "ReviseEncodedImageReviseEncodedImageMessageCitationsContent",
    "ReviseEncodedImageReviseEncodedImageMessageCitationsContentAudio",
    "ReviseEncodedImageReviseEncodedImageMessageCitationsContentDocument",
    "ReviseEncodedImageReviseEncodedImageMessageCitationsContentImage",
    "ReviseEncodedImageReviseEncodedImageMessageCitationsContentVideo",
    "ReviseEncodedImageReviseEncodedImageMessageToolCalls",
    "ReviseImage",
    "ReviseImageReviseImage",
    "ReviseImageReviseImageConversation",
    "ReviseImageReviseImageMessage",
    "ReviseImageReviseImageMessageCitations",
    "ReviseImageReviseImageMessageCitationsContent",
    "ReviseImageReviseImageMessageCitationsContentAudio",
    "ReviseImageReviseImageMessageCitationsContentDocument",
    "ReviseImageReviseImageMessageCitationsContentImage",
    "ReviseImageReviseImageMessageCitationsContentVideo",
    "ReviseImageReviseImageMessageToolCalls",
    "ReviseText",
    "ReviseTextReviseText",
    "ReviseTextReviseTextConversation",
    "ReviseTextReviseTextMessage",
    "ReviseTextReviseTextMessageCitations",
    "ReviseTextReviseTextMessageCitationsContent",
    "ReviseTextReviseTextMessageCitationsContentAudio",
    "ReviseTextReviseTextMessageCitationsContentDocument",
    "ReviseTextReviseTextMessageCitationsContentImage",
    "ReviseTextReviseTextMessageCitationsContentVideo",
    "ReviseTextReviseTextMessageToolCalls",
    "RevisionStrategyInput",
    "RevisionStrategyTypes",
    "RevisionStrategyUpdateInput",
    "SCREENSHOT_PAGE_GQL",
    "SEARCH_WEB_GQL",
    "SEND_NOTIFICATION_GQL",
    "SPECIFICATION_EXISTS_GQL",
    "SUGGEST_CONVERSATION_GQL",
    "SUMMARIZE_CONTENTS_GQL",
    "SUMMARIZE_TEXT_GQL",
    "ScreenshotPage",
    "ScreenshotPageScreenshotPage",
    "ScreenshotPageScreenshotPageCollections",
    "ScreenshotPageScreenshotPageObservations",
    "ScreenshotPageScreenshotPageObservationsObservable",
    "ScreenshotPageScreenshotPageObservationsOccurrences",
    "ScreenshotPageScreenshotPageObservationsOccurrencesBoundingBox",
    "ScreenshotPageScreenshotPageObservationsRelated",
    "SdkTypes",
    "SearchFeedPropertiesInput",
    "SearchFeedPropertiesUpdateInput",
    "SearchQueryTypes",
    "SearchServiceTypes",
    "SearchTypes",
    "SearchWeb",
    "SearchWebSearchWeb",
    "SearchWebSearchWebResults",
    "SendNotification",
    "SendNotificationSendNotification",
    "ShapeMetadataInput",
    "SharePointAuthenticationTypes",
    "SharePointFeedPropertiesInput",
    "SharePointFeedPropertiesUpdateInput",
    "SharePointFoldersInput",
    "SharePointLibrariesInput",
    "SiteFeedPropertiesInput",
    "SiteFeedPropertiesUpdateInput",
    "SiteTypes",
    "SlackChannelsInput",
    "SlackFeedPropertiesInput",
    "SlackFeedPropertiesUpdateInput",
    "SlackIntegrationPropertiesInput",
    "SoftwareFacetInput",
    "SoftwareFacetTypes",
    "SoftwareFilter",
    "SoftwareInput",
    "SoftwareUpdateInput",
    "SpecificationExists",
    "SpecificationExistsSpecificationExists",
    "SpecificationFilter",
    "SpecificationInput",
    "SpecificationTypes",
    "SpecificationUpdateInput",
    "StoragePolicyInput",
    "StoragePolicyTypes",
    "StorageWorkflowStageInput",
    "SuggestConversation",
    "SuggestConversationSuggestConversation",
    "SummarizationStrategyInput",
    "SummarizationTypes",
    "SummarizeContents",
    "SummarizeContentsSummarizeContents",
    "SummarizeContentsSummarizeContentsContent",
    "SummarizeContentsSummarizeContentsItems",
    "SummarizeContentsSummarizeContentsSpecification",
    "SummarizeText",
    "SummarizeTextSummarizeText",
    "SummarizeTextSummarizeTextContent",
    "SummarizeTextSummarizeTextItems",
    "SummarizeTextSummarizeTextSpecification",
    "TextContentInput",
    "TextRoles",
    "TextTypes",
    "TimeIntervalTypes",
    "TimedPolicyRecurrenceTypes",
    "ToolDefinitionInput",
    "TrelloFeedPropertiesInput",
    "TrelloFeedPropertiesUpdateInput",
    "TrelloTypes",
    "TwitterFeedPropertiesInput",
    "TwitterFeedPropertiesUpdateInput",
    "TwitterIntegrationPropertiesInput",
    "TwitterListingTypes",
    "UPDATE_ALERT_GQL",
    "UPDATE_CATEGORY_GQL",
    "UPDATE_COLLECTION_GQL",
    "UPDATE_CONTENT_GQL",
    "UPDATE_CONVERSATION_GQL",
    "UPDATE_EVENT_GQL",
    "UPDATE_FEED_GQL",
    "UPDATE_LABEL_GQL",
    "UPDATE_MEDICAL_CONDITION_GQL",
    "UPDATE_MEDICAL_CONTRAINDICATION_GQL",
    "UPDATE_MEDICAL_DEVICE_GQL",
    "UPDATE_MEDICAL_DRUG_CLASS_GQL",
    "UPDATE_MEDICAL_DRUG_GQL",
    "UPDATE_MEDICAL_GUIDELINE_GQL",
    "UPDATE_MEDICAL_INDICATION_GQL",
    "UPDATE_MEDICAL_PROCEDURE_GQL",
    "UPDATE_MEDICAL_STUDY_GQL",
    "UPDATE_MEDICAL_TEST_GQL",
    "UPDATE_MEDICAL_THERAPY_GQL",
    "UPDATE_OBSERVATION_GQL",
    "UPDATE_ORGANIZATION_GQL",
    "UPDATE_PERSON_GQL",
    "UPDATE_PLACE_GQL",
    "UPDATE_PRODUCT_GQL",
    "UPDATE_PROJECT_GQL",
    "UPDATE_REPO_GQL",
    "UPDATE_SOFTWARE_GQL",
    "UPDATE_SPECIFICATION_GQL",
    "UPDATE_USER_GQL",
    "UPDATE_WORKFLOW_GQL",
    "UPSERT_CATEGORY_GQL",
    "UPSERT_LABEL_GQL",
    "UPSERT_SPECIFICATION_GQL",
    "UPSERT_WORKFLOW_GQL",
    "UnitTypes",
    "UpdateAlert",
    "UpdateAlertUpdateAlert",
    "UpdateCategory",
    "UpdateCategoryUpdateCategory",
    "UpdateCollection",
    "UpdateCollectionUpdateCollection",
    "UpdateContent",
    "UpdateContentUpdateContent",
    "UpdateContentUpdateContentCollections",
    "UpdateContentUpdateContentObservations",
    "UpdateContentUpdateContentObservationsObservable",
    "UpdateContentUpdateContentObservationsOccurrences",
    "UpdateContentUpdateContentObservationsOccurrencesBoundingBox",
    "UpdateContentUpdateContentObservationsRelated",
    "UpdateConversation",
    "UpdateConversationUpdateConversation",
    "UpdateEvent",
    "UpdateEventUpdateEvent",
    "UpdateFeed",
    "UpdateFeedUpdateFeed",
    "UpdateLabel",
    "UpdateLabelUpdateLabel",
    "UpdateMedicalCondition",
    "UpdateMedicalConditionUpdateMedicalCondition",
    "UpdateMedicalContraindication",
    "UpdateMedicalContraindicationUpdateMedicalContraindication",
    "UpdateMedicalDevice",
    "UpdateMedicalDeviceUpdateMedicalDevice",
    "UpdateMedicalDrug",
    "UpdateMedicalDrugClass",
    "UpdateMedicalDrugClassUpdateMedicalDrugClass",
    "UpdateMedicalDrugUpdateMedicalDrug",
    "UpdateMedicalGuideline",
    "UpdateMedicalGuidelineUpdateMedicalGuideline",
    "UpdateMedicalIndication",
    "UpdateMedicalIndicationUpdateMedicalIndication",
    "UpdateMedicalProcedure",
    "UpdateMedicalProcedureUpdateMedicalProcedure",
    "UpdateMedicalStudy",
    "UpdateMedicalStudyUpdateMedicalStudy",
    "UpdateMedicalTest",
    "UpdateMedicalTestUpdateMedicalTest",
    "UpdateMedicalTherapy",
    "UpdateMedicalTherapyUpdateMedicalTherapy",
    "UpdateObservation",
    "UpdateObservationUpdateObservation",
    "UpdateOrganization",
    "UpdateOrganizationUpdateOrganization",
    "UpdatePerson",
    "UpdatePersonUpdatePerson",
    "UpdatePlace",
    "UpdatePlaceUpdatePlace",
    "UpdateProduct",
    "UpdateProductUpdateProduct",
    "UpdateProject",
    "UpdateProjectUpdateProject",
    "UpdateRepo",
    "UpdateRepoUpdateRepo",
    "UpdateSoftware",
    "UpdateSoftwareUpdateSoftware",
    "UpdateSpecification",
    "UpdateSpecificationUpdateSpecification",
    "UpdateUser",
    "UpdateUserUpdateUser",
    "UpdateWorkflow",
    "UpdateWorkflowUpdateWorkflow",
    "UpdateWorkflowUpdateWorkflowActions",
    "UpdateWorkflowUpdateWorkflowActionsConnector",
    "UpdateWorkflowUpdateWorkflowActionsConnectorEmail",
    "UpdateWorkflowUpdateWorkflowActionsConnectorSlack",
    "UpdateWorkflowUpdateWorkflowActionsConnectorTwitter",
    "UpdateWorkflowUpdateWorkflowClassification",
    "UpdateWorkflowUpdateWorkflowClassificationJobs",
    "UpdateWorkflowUpdateWorkflowClassificationJobsConnector",
    "UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModel",
    "UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModelRules",
    "UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModelSpecification",
    "UpdateWorkflowUpdateWorkflowClassificationJobsConnectorRegex",
    "UpdateWorkflowUpdateWorkflowClassificationJobsConnectorRegexRules",
    "UpdateWorkflowUpdateWorkflowEnrichment",
    "UpdateWorkflowUpdateWorkflowEnrichmentJobs",
    "UpdateWorkflowUpdateWorkflowEnrichmentJobsConnector",
    "UpdateWorkflowUpdateWorkflowEnrichmentJobsConnectorDiffbot",
    "UpdateWorkflowUpdateWorkflowEnrichmentJobsConnectorFhir",
    "UpdateWorkflowUpdateWorkflowEnrichmentLink",
    "UpdateWorkflowUpdateWorkflowExtraction",
    "UpdateWorkflowUpdateWorkflowExtractionJobs",
    "UpdateWorkflowUpdateWorkflowExtractionJobsConnector",
    "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorAzureImage",
    "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorAzureText",
    "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelImage",
    "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelImageSpecification",
    "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelText",
    "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelTextSpecification",
    "UpdateWorkflowUpdateWorkflowIndexing",
    "UpdateWorkflowUpdateWorkflowIndexingJobs",
    "UpdateWorkflowUpdateWorkflowIndexingJobsConnector",
    "UpdateWorkflowUpdateWorkflowIngestion",
    "UpdateWorkflowUpdateWorkflowIngestionCollections",
    "UpdateWorkflowUpdateWorkflowIngestionIf",
    "UpdateWorkflowUpdateWorkflowIngestionObservations",
    "UpdateWorkflowUpdateWorkflowIngestionObservationsObservable",
    "UpdateWorkflowUpdateWorkflowPreparation",
    "UpdateWorkflowUpdateWorkflowPreparationJobs",
    "UpdateWorkflowUpdateWorkflowPreparationJobsConnector",
    "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorAssemblyAi",
    "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorAzureDocument",
    "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorDeepgram",
    "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorDocument",
    "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorEmail",
    "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorMistral",
    "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorModelDocument",
    "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorModelDocumentSpecification",
    "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorPage",
    "UpdateWorkflowUpdateWorkflowPreparationSummarizations",
    "UpdateWorkflowUpdateWorkflowPreparationSummarizationsSpecification",
    "UpdateWorkflowUpdateWorkflowStorage",
    "UpdateWorkflowUpdateWorkflowStoragePolicy",
    "Upload",
    "UpsertCategory",
    "UpsertCategoryUpsertCategory",
    "UpsertLabel",
    "UpsertLabelUpsertLabel",
    "UpsertSpecification",
    "UpsertSpecificationUpsertSpecification",
    "UpsertWorkflow",
    "UpsertWorkflowUpsertWorkflow",
    "UpsertWorkflowUpsertWorkflowActions",
    "UpsertWorkflowUpsertWorkflowActionsConnector",
    "UpsertWorkflowUpsertWorkflowActionsConnectorEmail",
    "UpsertWorkflowUpsertWorkflowActionsConnectorSlack",
    "UpsertWorkflowUpsertWorkflowActionsConnectorTwitter",
    "UpsertWorkflowUpsertWorkflowClassification",
    "UpsertWorkflowUpsertWorkflowClassificationJobs",
    "UpsertWorkflowUpsertWorkflowClassificationJobsConnector",
    "UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModel",
    "UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModelRules",
    "UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModelSpecification",
    "UpsertWorkflowUpsertWorkflowClassificationJobsConnectorRegex",
    "UpsertWorkflowUpsertWorkflowClassificationJobsConnectorRegexRules",
    "UpsertWorkflowUpsertWorkflowEnrichment",
    "UpsertWorkflowUpsertWorkflowEnrichmentJobs",
    "UpsertWorkflowUpsertWorkflowEnrichmentJobsConnector",
    "UpsertWorkflowUpsertWorkflowEnrichmentJobsConnectorDiffbot",
    "UpsertWorkflowUpsertWorkflowEnrichmentJobsConnectorFhir",
    "UpsertWorkflowUpsertWorkflowEnrichmentLink",
    "UpsertWorkflowUpsertWorkflowExtraction",
    "UpsertWorkflowUpsertWorkflowExtractionJobs",
    "UpsertWorkflowUpsertWorkflowExtractionJobsConnector",
    "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorAzureImage",
    "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorAzureText",
    "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelImage",
    "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelImageSpecification",
    "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelText",
    "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelTextSpecification",
    "UpsertWorkflowUpsertWorkflowIndexing",
    "UpsertWorkflowUpsertWorkflowIndexingJobs",
    "UpsertWorkflowUpsertWorkflowIndexingJobsConnector",
    "UpsertWorkflowUpsertWorkflowIngestion",
    "UpsertWorkflowUpsertWorkflowIngestionCollections",
    "UpsertWorkflowUpsertWorkflowIngestionIf",
    "UpsertWorkflowUpsertWorkflowIngestionObservations",
    "UpsertWorkflowUpsertWorkflowIngestionObservationsObservable",
    "UpsertWorkflowUpsertWorkflowPreparation",
    "UpsertWorkflowUpsertWorkflowPreparationJobs",
    "UpsertWorkflowUpsertWorkflowPreparationJobsConnector",
    "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorAssemblyAi",
    "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorAzureDocument",
    "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorDeepgram",
    "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorDocument",
    "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorEmail",
    "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorMistral",
    "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorModelDocument",
    "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorModelDocumentSpecification",
    "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorPage",
    "UpsertWorkflowUpsertWorkflowPreparationSummarizations",
    "UpsertWorkflowUpsertWorkflowPreparationSummarizationsSpecification",
    "UpsertWorkflowUpsertWorkflowStorage",
    "UpsertWorkflowUpsertWorkflowStoragePolicy",
    "UserFilter",
    "UserInput",
    "UserTypes",
    "UserUpdateInput",
    "VideoMetadataInput",
    "VoyageModelPropertiesInput",
    "VoyageModelPropertiesUpdateInput",
    "VoyageModels",
    "WORKFLOW_EXISTS_GQL",
    "WebFeedPropertiesInput",
    "WebFeedPropertiesUpdateInput",
    "WorkflowActionInput",
    "WorkflowExists",
    "WorkflowExistsWorkflowExists",
    "WorkflowFilter",
    "WorkflowInput",
    "WorkflowUpdateInput",
    "YouTubeFeedPropertiesInput",
    "YouTubeFeedPropertiesUpdateInput",
    "YouTubeTypes",
    "ZendeskFeedPropertiesInput",
    "ZendeskFeedPropertiesUpdateInput",
    "ZendeskTicketsFeedPropertiesInput",
    "ZendeskTicketsFeedPropertiesUpdateInput",
]



================================================
FILE: graphlit_api/add_contents_to_collections.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import CollectionTypes, EntityState


class AddContentsToCollections(BaseModel):
    add_contents_to_collections: Optional[
        List[Optional["AddContentsToCollectionsAddContentsToCollections"]]
    ] = Field(alias="addContentsToCollections")


class AddContentsToCollectionsAddContentsToCollections(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[CollectionTypes]
    contents: Optional[
        List[Optional["AddContentsToCollectionsAddContentsToCollectionsContents"]]
    ]


class AddContentsToCollectionsAddContentsToCollectionsContents(BaseModel):
    id: str
    name: str


AddContentsToCollections.model_rebuild()
AddContentsToCollectionsAddContentsToCollections.model_rebuild()



================================================
FILE: graphlit_api/ask_graphlit.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    OrientationTypes,
)


class AskGraphlit(BaseModel):
    ask_graphlit: Optional["AskGraphlitAskGraphlit"] = Field(alias="askGraphlit")


class AskGraphlitAskGraphlit(BaseModel):
    conversation: Optional["AskGraphlitAskGraphlitConversation"]
    message: Optional["AskGraphlitAskGraphlitMessage"]
    message_count: Optional[int] = Field(alias="messageCount")


class AskGraphlitAskGraphlitConversation(BaseModel):
    id: str


class AskGraphlitAskGraphlitMessage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[List[Optional["AskGraphlitAskGraphlitMessageCitations"]]]
    tool_calls: Optional[List[Optional["AskGraphlitAskGraphlitMessageToolCalls"]]] = (
        Field(alias="toolCalls")
    )
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class AskGraphlitAskGraphlitMessageCitations(BaseModel):
    content: Optional["AskGraphlitAskGraphlitMessageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class AskGraphlitAskGraphlitMessageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["AskGraphlitAskGraphlitMessageCitationsContentVideo"]
    audio: Optional["AskGraphlitAskGraphlitMessageCitationsContentAudio"]
    image: Optional["AskGraphlitAskGraphlitMessageCitationsContentImage"]
    document: Optional["AskGraphlitAskGraphlitMessageCitationsContentDocument"]


class AskGraphlitAskGraphlitMessageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class AskGraphlitAskGraphlitMessageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class AskGraphlitAskGraphlitMessageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class AskGraphlitAskGraphlitMessageCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class AskGraphlitAskGraphlitMessageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


AskGraphlit.model_rebuild()
AskGraphlitAskGraphlit.model_rebuild()
AskGraphlitAskGraphlitMessage.model_rebuild()
AskGraphlitAskGraphlitMessageCitations.model_rebuild()
AskGraphlitAskGraphlitMessageCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/async_base_client.py
================================================
# Generated by ariadne-codegen

import enum
import json
from typing import IO, Any, AsyncIterator, Dict, List, Optional, Tuple, TypeVar, cast
from uuid import uuid4

import httpx
from pydantic import BaseModel
from pydantic_core import to_jsonable_python

from .base_model import UNSET, Upload
from .exceptions import (
    GraphQLClientGraphQLMultiError,
    GraphQLClientHttpError,
    GraphQLClientInvalidMessageFormat,
    GraphQLClientInvalidResponseError,
)

try:
    from websockets.client import (  # type: ignore[import-not-found,unused-ignore]
        WebSocketClientProtocol,
        connect as ws_connect,
    )
    from websockets.typing import (  # type: ignore[import-not-found,unused-ignore]
        Data,
        Origin,
        Subprotocol,
    )
except ImportError:
    from contextlib import asynccontextmanager

    @asynccontextmanager  # type: ignore
    async def ws_connect(*args, **kwargs):  # pylint: disable=unused-argument
        raise NotImplementedError("Subscriptions require 'websockets' package.")
        yield  # pylint: disable=unreachable

    WebSocketClientProtocol = Any  # type: ignore[misc,assignment,unused-ignore]
    Data = Any  # type: ignore[misc,assignment,unused-ignore]
    Origin = Any  # type: ignore[misc,assignment,unused-ignore]

    def Subprotocol(*args, **kwargs):  # type: ignore # pylint: disable=invalid-name
        raise NotImplementedError("Subscriptions require 'websockets' package.")


Self = TypeVar("Self", bound="AsyncBaseClient")

GRAPHQL_TRANSPORT_WS = "graphql-transport-ws"


class GraphQLTransportWSMessageType(str, enum.Enum):
    CONNECTION_INIT = "connection_init"
    CONNECTION_ACK = "connection_ack"
    PING = "ping"
    PONG = "pong"
    SUBSCRIBE = "subscribe"
    NEXT = "next"
    ERROR = "error"
    COMPLETE = "complete"


class AsyncBaseClient:
    def __init__(
        self,
        url: str = "",
        headers: Optional[Dict[str, str]] = None,
        http_client: Optional[httpx.AsyncClient] = None,
        ws_url: str = "",
        ws_headers: Optional[Dict[str, Any]] = None,
        ws_origin: Optional[str] = None,
        ws_connection_init_payload: Optional[Dict[str, Any]] = None,
    ) -> None:
        self.url = url
        self.headers = headers
        self.http_client = (
            http_client if http_client else httpx.AsyncClient(headers=headers)
        )

        self.ws_url = ws_url
        self.ws_headers = ws_headers or {}
        self.ws_origin = Origin(ws_origin) if ws_origin else None
        self.ws_connection_init_payload = ws_connection_init_payload

    async def __aenter__(self: Self) -> Self:
        return self

    async def __aexit__(
        self,
        exc_type: object,
        exc_val: object,
        exc_tb: object,
    ) -> None:
        await self.http_client.aclose()

    async def execute(
        self,
        query: str,
        operation_name: Optional[str] = None,
        variables: Optional[Dict[str, Any]] = None,
        **kwargs: Any,
    ) -> httpx.Response:
        processed_variables, files, files_map = self._process_variables(variables)

        if files and files_map:
            return await self._execute_multipart(
                query=query,
                operation_name=operation_name,
                variables=processed_variables,
                files=files,
                files_map=files_map,
                **kwargs,
            )

        return await self._execute_json(
            query=query,
            operation_name=operation_name,
            variables=processed_variables,
            **kwargs,
        )

    def get_data(self, response: httpx.Response) -> Dict[str, Any]:
        if not response.is_success:
            raise GraphQLClientHttpError(
                status_code=response.status_code, response=response
            )

        try:
            response_json = response.json()
        except ValueError as exc:
            raise GraphQLClientInvalidResponseError(response=response) from exc

        if (not isinstance(response_json, dict)) or (
            "data" not in response_json and "errors" not in response_json
        ):
            raise GraphQLClientInvalidResponseError(response=response)

        data = response_json.get("data")
        errors = response_json.get("errors")

        if errors:
            raise GraphQLClientGraphQLMultiError.from_errors_dicts(
                errors_dicts=errors, data=data
            )

        return cast(Dict[str, Any], data)

    async def execute_ws(
        self,
        query: str,
        operation_name: Optional[str] = None,
        variables: Optional[Dict[str, Any]] = None,
        **kwargs: Any,
    ) -> AsyncIterator[Dict[str, Any]]:
        headers = self.ws_headers.copy()
        headers.update(kwargs.get("extra_headers", {}))

        merged_kwargs: Dict[str, Any] = {"origin": self.ws_origin}
        merged_kwargs.update(kwargs)
        merged_kwargs["extra_headers"] = headers

        operation_id = str(uuid4())
        async with ws_connect(
            self.ws_url,
            subprotocols=[Subprotocol(GRAPHQL_TRANSPORT_WS)],
            **merged_kwargs,
        ) as websocket:
            await self._send_connection_init(websocket)
            # wait for connection_ack from server
            await self._handle_ws_message(
                await websocket.recv(),
                websocket,
                expected_type=GraphQLTransportWSMessageType.CONNECTION_ACK,
            )
            await self._send_subscribe(
                websocket,
                operation_id=operation_id,
                query=query,
                operation_name=operation_name,
                variables=variables,
            )

            async for message in websocket:
                data = await self._handle_ws_message(message, websocket)
                if data:
                    yield data

    def _process_variables(
        self, variables: Optional[Dict[str, Any]]
    ) -> Tuple[
        Dict[str, Any], Dict[str, Tuple[str, IO[bytes], str]], Dict[str, List[str]]
    ]:
        if not variables:
            return {}, {}, {}

        serializable_variables = self._convert_dict_to_json_serializable(variables)
        return self._get_files_from_variables(serializable_variables)

    def _convert_dict_to_json_serializable(
        self, dict_: Dict[str, Any]
    ) -> Dict[str, Any]:
        return {
            key: self._convert_value(value)
            for key, value in dict_.items()
            if value is not UNSET
        }

    def _convert_value(self, value: Any) -> Any:
        if isinstance(value, BaseModel):
            return value.model_dump(by_alias=True, exclude_unset=True)
        if isinstance(value, list):
            return [self._convert_value(item) for item in value]
        return value

    def _get_files_from_variables(
        self, variables: Dict[str, Any]
    ) -> Tuple[
        Dict[str, Any], Dict[str, Tuple[str, IO[bytes], str]], Dict[str, List[str]]
    ]:
        files_map: Dict[str, List[str]] = {}
        files_list: List[Upload] = []

        def separate_files(path: str, obj: Any) -> Any:
            if isinstance(obj, list):
                nulled_list = []
                for index, value in enumerate(obj):
                    value = separate_files(f"{path}.{index}", value)
                    nulled_list.append(value)
                return nulled_list

            if isinstance(obj, dict):
                nulled_dict = {}
                for key, value in obj.items():
                    value = separate_files(f"{path}.{key}", value)
                    nulled_dict[key] = value
                return nulled_dict

            if isinstance(obj, Upload):
                if obj in files_list:
                    file_index = files_list.index(obj)
                    files_map[str(file_index)].append(path)
                else:
                    file_index = len(files_list)
                    files_list.append(obj)
                    files_map[str(file_index)] = [path]
                return None

            return obj

        nulled_variables = separate_files("variables", variables)
        files: Dict[str, Tuple[str, IO[bytes], str]] = {
            str(i): (file_.filename, cast(IO[bytes], file_.content), file_.content_type)
            for i, file_ in enumerate(files_list)
        }
        return nulled_variables, files, files_map

    async def _execute_multipart(
        self,
        query: str,
        operation_name: Optional[str],
        variables: Dict[str, Any],
        files: Dict[str, Tuple[str, IO[bytes], str]],
        files_map: Dict[str, List[str]],
        **kwargs: Any,
    ) -> httpx.Response:
        data = {
            "operations": json.dumps(
                {
                    "query": query,
                    "operationName": operation_name,
                    "variables": variables,
                },
                default=to_jsonable_python,
            ),
            "map": json.dumps(files_map, default=to_jsonable_python),
        }

        return await self.http_client.post(
            url=self.url, data=data, files=files, **kwargs
        )

    async def _execute_json(
        self,
        query: str,
        operation_name: Optional[str],
        variables: Dict[str, Any],
        **kwargs: Any,
    ) -> httpx.Response:
        headers: Dict[str, str] = {"Content-Type": "application/json"}
        headers.update(kwargs.get("headers", {}))

        merged_kwargs: Dict[str, Any] = kwargs.copy()
        merged_kwargs["headers"] = headers

        return await self.http_client.post(
            url=self.url,
            content=json.dumps(
                {
                    "query": query,
                    "operationName": operation_name,
                    "variables": variables,
                },
                default=to_jsonable_python,
            ),
            **merged_kwargs,
        )

    async def _send_connection_init(self, websocket: WebSocketClientProtocol) -> None:
        payload: Dict[str, Any] = {
            "type": GraphQLTransportWSMessageType.CONNECTION_INIT.value
        }
        if self.ws_connection_init_payload:
            payload["payload"] = self.ws_connection_init_payload
        await websocket.send(json.dumps(payload))

    async def _send_subscribe(
        self,
        websocket: WebSocketClientProtocol,
        operation_id: str,
        query: str,
        operation_name: Optional[str] = None,
        variables: Optional[Dict[str, Any]] = None,
    ) -> None:
        payload: Dict[str, Any] = {
            "id": operation_id,
            "type": GraphQLTransportWSMessageType.SUBSCRIBE.value,
            "payload": {"query": query, "operationName": operation_name},
        }
        if variables:
            payload["payload"]["variables"] = self._convert_dict_to_json_serializable(
                variables
            )
        await websocket.send(json.dumps(payload))

    async def _handle_ws_message(
        self,
        message: Data,
        websocket: WebSocketClientProtocol,
        expected_type: Optional[GraphQLTransportWSMessageType] = None,
    ) -> Optional[Dict[str, Any]]:
        try:
            message_dict = json.loads(message)
        except json.JSONDecodeError as exc:
            raise GraphQLClientInvalidMessageFormat(message=message) from exc

        type_ = message_dict.get("type")
        payload = message_dict.get("payload", {})

        if not type_ or type_ not in {t.value for t in GraphQLTransportWSMessageType}:
            raise GraphQLClientInvalidMessageFormat(message=message)

        if expected_type and expected_type != type_:
            raise GraphQLClientInvalidMessageFormat(
                f"Invalid message received. Expected: {expected_type.value}"
            )

        if type_ == GraphQLTransportWSMessageType.NEXT:
            if "data" not in payload:
                raise GraphQLClientInvalidMessageFormat(message=message)
            return cast(Dict[str, Any], payload["data"])

        if type_ == GraphQLTransportWSMessageType.COMPLETE:
            await websocket.close()
        elif type_ == GraphQLTransportWSMessageType.PING:
            await websocket.send(
                json.dumps({"type": GraphQLTransportWSMessageType.PONG.value})
            )
        elif type_ == GraphQLTransportWSMessageType.ERROR:
            raise GraphQLClientGraphQLMultiError.from_errors_dicts(
                errors_dicts=payload, data=message_dict
            )

        return None



================================================
FILE: graphlit_api/base_model.py
================================================
# Generated by ariadne-codegen

from io import IOBase

from pydantic import BaseModel as PydanticBaseModel, ConfigDict


class UnsetType:
    def __bool__(self) -> bool:
        return False


UNSET = UnsetType()


class BaseModel(PydanticBaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        arbitrary_types_allowed=True,
        protected_namespaces=(),
    )


class Upload:
    def __init__(self, filename: str, content: IOBase, content_type: str):
        self.filename = filename
        self.content = content
        self.content_type = content_type



================================================
FILE: graphlit_api/clear_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import ConversationTypes, EntityState


class ClearConversation(BaseModel):
    clear_conversation: Optional["ClearConversationClearConversation"] = Field(
        alias="clearConversation"
    )


class ClearConversationClearConversation(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ConversationTypes]


ClearConversation.model_rebuild()



================================================
FILE: graphlit_api/client.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Dict, List, Optional, Union

from .add_contents_to_collections import AddContentsToCollections
from .ask_graphlit import AskGraphlit
from .async_base_client import AsyncBaseClient
from .base_model import UNSET, UnsetType
from .clear_conversation import ClearConversation
from .close_conversation import CloseConversation
from .complete_conversation import CompleteConversation
from .continue_conversation import ContinueConversation
from .count_alerts import CountAlerts
from .count_categories import CountCategories
from .count_collections import CountCollections
from .count_contents import CountContents
from .count_conversations import CountConversations
from .count_events import CountEvents
from .count_feeds import CountFeeds
from .count_labels import CountLabels
from .count_medical_conditions import CountMedicalConditions
from .count_medical_contraindications import CountMedicalContraindications
from .count_medical_devices import CountMedicalDevices
from .count_medical_drug_classes import CountMedicalDrugClasses
from .count_medical_drugs import CountMedicalDrugs
from .count_medical_guidelines import CountMedicalGuidelines
from .count_medical_indications import CountMedicalIndications
from .count_medical_procedures import CountMedicalProcedures
from .count_medical_studies import CountMedicalStudies
from .count_medical_tests import CountMedicalTests
from .count_medical_therapies import CountMedicalTherapies
from .count_organizations import CountOrganizations
from .count_persons import CountPersons
from .count_places import CountPlaces
from .count_products import CountProducts
from .count_repos import CountRepos
from .count_softwares import CountSoftwares
from .count_specifications import CountSpecifications
from .count_users import CountUsers
from .count_workflows import CountWorkflows
from .create_alert import CreateAlert
from .create_category import CreateCategory
from .create_collection import CreateCollection
from .create_conversation import CreateConversation
from .create_event import CreateEvent
from .create_feed import CreateFeed
from .create_label import CreateLabel
from .create_medical_condition import CreateMedicalCondition
from .create_medical_contraindication import CreateMedicalContraindication
from .create_medical_device import CreateMedicalDevice
from .create_medical_drug import CreateMedicalDrug
from .create_medical_drug_class import CreateMedicalDrugClass
from .create_medical_guideline import CreateMedicalGuideline
from .create_medical_indication import CreateMedicalIndication
from .create_medical_procedure import CreateMedicalProcedure
from .create_medical_study import CreateMedicalStudy
from .create_medical_test import CreateMedicalTest
from .create_medical_therapy import CreateMedicalTherapy
from .create_observation import CreateObservation
from .create_organization import CreateOrganization
from .create_person import CreatePerson
from .create_place import CreatePlace
from .create_product import CreateProduct
from .create_repo import CreateRepo
from .create_software import CreateSoftware
from .create_specification import CreateSpecification
from .create_user import CreateUser
from .create_workflow import CreateWorkflow
from .delete_alert import DeleteAlert
from .delete_alerts import DeleteAlerts
from .delete_all_alerts import DeleteAllAlerts
from .delete_all_categories import DeleteAllCategories
from .delete_all_collections import DeleteAllCollections
from .delete_all_contents import DeleteAllContents
from .delete_all_conversations import DeleteAllConversations
from .delete_all_events import DeleteAllEvents
from .delete_all_feeds import DeleteAllFeeds
from .delete_all_labels import DeleteAllLabels
from .delete_all_medical_conditions import DeleteAllMedicalConditions
from .delete_all_medical_contraindications import DeleteAllMedicalContraindications
from .delete_all_medical_devices import DeleteAllMedicalDevices
from .delete_all_medical_drug_classes import DeleteAllMedicalDrugClasses
from .delete_all_medical_drugs import DeleteAllMedicalDrugs
from .delete_all_medical_guidelines import DeleteAllMedicalGuidelines
from .delete_all_medical_indications import DeleteAllMedicalIndications
from .delete_all_medical_procedures import DeleteAllMedicalProcedures
from .delete_all_medical_studies import DeleteAllMedicalStudies
from .delete_all_medical_tests import DeleteAllMedicalTests
from .delete_all_medical_therapies import DeleteAllMedicalTherapies
from .delete_all_organizations import DeleteAllOrganizations
from .delete_all_persons import DeleteAllPersons
from .delete_all_places import DeleteAllPlaces
from .delete_all_products import DeleteAllProducts
from .delete_all_repos import DeleteAllRepos
from .delete_all_softwares import DeleteAllSoftwares
from .delete_all_specifications import DeleteAllSpecifications
from .delete_all_workflows import DeleteAllWorkflows
from .delete_categories import DeleteCategories
from .delete_category import DeleteCategory
from .delete_collection import DeleteCollection
from .delete_collections import DeleteCollections
from .delete_content import DeleteContent
from .delete_contents import DeleteContents
from .delete_conversation import DeleteConversation
from .delete_conversations import DeleteConversations
from .delete_event import DeleteEvent
from .delete_events import DeleteEvents
from .delete_feed import DeleteFeed
from .delete_feeds import DeleteFeeds
from .delete_label import DeleteLabel
from .delete_labels import DeleteLabels
from .delete_medical_condition import DeleteMedicalCondition
from .delete_medical_conditions import DeleteMedicalConditions
from .delete_medical_contraindication import DeleteMedicalContraindication
from .delete_medical_contraindications import DeleteMedicalContraindications
from .delete_medical_device import DeleteMedicalDevice
from .delete_medical_devices import DeleteMedicalDevices
from .delete_medical_drug import DeleteMedicalDrug
from .delete_medical_drug_class import DeleteMedicalDrugClass
from .delete_medical_drug_classes import DeleteMedicalDrugClasses
from .delete_medical_drugs import DeleteMedicalDrugs
from .delete_medical_guideline import DeleteMedicalGuideline
from .delete_medical_guidelines import DeleteMedicalGuidelines
from .delete_medical_indication import DeleteMedicalIndication
from .delete_medical_indications import DeleteMedicalIndications
from .delete_medical_procedure import DeleteMedicalProcedure
from .delete_medical_procedures import DeleteMedicalProcedures
from .delete_medical_studies import DeleteMedicalStudies
from .delete_medical_study import DeleteMedicalStudy
from .delete_medical_test import DeleteMedicalTest
from .delete_medical_tests import DeleteMedicalTests
from .delete_medical_therapies import DeleteMedicalTherapies
from .delete_medical_therapy import DeleteMedicalTherapy
from .delete_observation import DeleteObservation
from .delete_organization import DeleteOrganization
from .delete_organizations import DeleteOrganizations
from .delete_person import DeletePerson
from .delete_persons import DeletePersons
from .delete_place import DeletePlace
from .delete_places import DeletePlaces
from .delete_product import DeleteProduct
from .delete_products import DeleteProducts
from .delete_repo import DeleteRepo
from .delete_repos import DeleteRepos
from .delete_software import DeleteSoftware
from .delete_softwares import DeleteSoftwares
from .delete_specification import DeleteSpecification
from .delete_specifications import DeleteSpecifications
from .delete_user import DeleteUser
from .delete_workflow import DeleteWorkflow
from .delete_workflows import DeleteWorkflows
from .describe_encoded_image import DescribeEncodedImage
from .describe_image import DescribeImage
from .disable_alert import DisableAlert
from .disable_feed import DisableFeed
from .disable_user import DisableUser
from .enable_alert import EnableAlert
from .enable_feed import EnableFeed
from .enable_user import EnableUser
from .enums import SdkTypes, SearchServiceTypes, TextTypes
from .extract_contents import ExtractContents
from .extract_text import ExtractText
from .feed_exists import FeedExists
from .format_conversation import FormatConversation
from .get_alert import GetAlert
from .get_category import GetCategory
from .get_collection import GetCollection
from .get_content import GetContent
from .get_conversation import GetConversation
from .get_event import GetEvent
from .get_feed import GetFeed
from .get_label import GetLabel
from .get_medical_condition import GetMedicalCondition
from .get_medical_contraindication import GetMedicalContraindication
from .get_medical_device import GetMedicalDevice
from .get_medical_drug import GetMedicalDrug
from .get_medical_drug_class import GetMedicalDrugClass
from .get_medical_guideline import GetMedicalGuideline
from .get_medical_indication import GetMedicalIndication
from .get_medical_procedure import GetMedicalProcedure
from .get_medical_study import GetMedicalStudy
from .get_medical_test import GetMedicalTest
from .get_medical_therapy import GetMedicalTherapy
from .get_organization import GetOrganization
from .get_person import GetPerson
from .get_place import GetPlace
from .get_product import GetProduct
from .get_project import GetProject
from .get_repo import GetRepo
from .get_share_point_consent_uri import GetSharePointConsentUri
from .get_software import GetSoftware
from .get_specification import GetSpecification
from .get_user import GetUser
from .get_workflow import GetWorkflow
from .ingest_batch import IngestBatch
from .ingest_encoded_file import IngestEncodedFile
from .ingest_memory import IngestMemory
from .ingest_text import IngestText
from .ingest_text_batch import IngestTextBatch
from .ingest_uri import IngestUri
from .input_types import (
    AlertFilter,
    AlertInput,
    AlertUpdateInput,
    CategoryFilter,
    CategoryInput,
    CategoryUpdateInput,
    CollectionFilter,
    CollectionInput,
    CollectionUpdateInput,
    ContentFacetInput,
    ContentFilter,
    ContentGraphInput,
    ContentPublishingConnectorInput,
    ContentUpdateInput,
    ConversationFilter,
    ConversationInput,
    ConversationMessageInput,
    ConversationToolResponseInput,
    ConversationUpdateInput,
    EntityReferenceInput,
    EventFilter,
    EventInput,
    EventUpdateInput,
    FeedFilter,
    FeedInput,
    FeedUpdateInput,
    IntegrationConnectorInput,
    LabelFilter,
    LabelInput,
    LabelUpdateInput,
    LinearProjectsInput,
    MedicalConditionFilter,
    MedicalConditionInput,
    MedicalConditionUpdateInput,
    MedicalContraindicationFilter,
    MedicalContraindicationInput,
    MedicalContraindicationUpdateInput,
    MedicalDeviceFilter,
    MedicalDeviceInput,
    MedicalDeviceUpdateInput,
    MedicalDrugClassFilter,
    MedicalDrugClassInput,
    MedicalDrugClassUpdateInput,
    MedicalDrugFilter,
    MedicalDrugInput,
    MedicalDrugUpdateInput,
    MedicalGuidelineFilter,
    MedicalGuidelineInput,
    MedicalGuidelineUpdateInput,
    MedicalIndicationFilter,
    MedicalIndicationInput,
    MedicalIndicationUpdateInput,
    MedicalProcedureFilter,
    MedicalProcedureInput,
    MedicalProcedureUpdateInput,
    MedicalStudyFilter,
    MedicalStudyInput,
    MedicalStudyUpdateInput,
    MedicalTestFilter,
    MedicalTestInput,
    MedicalTestUpdateInput,
    MedicalTherapyFilter,
    MedicalTherapyInput,
    MedicalTherapyUpdateInput,
    MicrosoftTeamsChannelsInput,
    MicrosoftTeamsTeamsInput,
    ModelFilter,
    NotionDatabasesInput,
    NotionPagesInput,
    ObservationInput,
    ObservationReferenceInput,
    ObservationUpdateInput,
    OneDriveFoldersInput,
    OrganizationFilter,
    OrganizationInput,
    OrganizationUpdateInput,
    PersonFilter,
    PersonInput,
    PersonUpdateInput,
    PlaceFilter,
    PlaceInput,
    PlaceUpdateInput,
    ProductFilter,
    ProductInput,
    ProductUpdateInput,
    ProjectUpdateInput,
    RepoFilter,
    RepoInput,
    RepoUpdateInput,
    RerankingStrategyInput,
    RetrievalStrategyInput,
    SharePointFoldersInput,
    SharePointLibrariesInput,
    SlackChannelsInput,
    SoftwareFilter,
    SoftwareInput,
    SoftwareUpdateInput,
    SpecificationFilter,
    SpecificationInput,
    SpecificationUpdateInput,
    SummarizationStrategyInput,
    TextContentInput,
    ToolDefinitionInput,
    UserFilter,
    UserInput,
    UserUpdateInput,
    WorkflowFilter,
    WorkflowInput,
    WorkflowUpdateInput,
)
from .is_content_done import IsContentDone
from .is_feed_done import IsFeedDone
from .lookup_credits import LookupCredits
from .lookup_usage import LookupUsage
from .map_web import MapWeb
from .operations import (
    ADD_CONTENTS_TO_COLLECTIONS_GQL,
    ASK_GRAPHLIT_GQL,
    CLEAR_CONVERSATION_GQL,
    CLOSE_CONVERSATION_GQL,
    COMPLETE_CONVERSATION_GQL,
    CONTINUE_CONVERSATION_GQL,
    COUNT_ALERTS_GQL,
    COUNT_CATEGORIES_GQL,
    COUNT_COLLECTIONS_GQL,
    COUNT_CONTENTS_GQL,
    COUNT_CONVERSATIONS_GQL,
    COUNT_EVENTS_GQL,
    COUNT_FEEDS_GQL,
    COUNT_LABELS_GQL,
    COUNT_MEDICAL_CONDITIONS_GQL,
    COUNT_MEDICAL_CONTRAINDICATIONS_GQL,
    COUNT_MEDICAL_DEVICES_GQL,
    COUNT_MEDICAL_DRUG_CLASSES_GQL,
    COUNT_MEDICAL_DRUGS_GQL,
    COUNT_MEDICAL_GUIDELINES_GQL,
    COUNT_MEDICAL_INDICATIONS_GQL,
    COUNT_MEDICAL_PROCEDURES_GQL,
    COUNT_MEDICAL_STUDIES_GQL,
    COUNT_MEDICAL_TESTS_GQL,
    COUNT_MEDICAL_THERAPIES_GQL,
    COUNT_ORGANIZATIONS_GQL,
    COUNT_PERSONS_GQL,
    COUNT_PLACES_GQL,
    COUNT_PRODUCTS_GQL,
    COUNT_REPOS_GQL,
    COUNT_SOFTWARES_GQL,
    COUNT_SPECIFICATIONS_GQL,
    COUNT_USERS_GQL,
    COUNT_WORKFLOWS_GQL,
    CREATE_ALERT_GQL,
    CREATE_CATEGORY_GQL,
    CREATE_COLLECTION_GQL,
    CREATE_CONVERSATION_GQL,
    CREATE_EVENT_GQL,
    CREATE_FEED_GQL,
    CREATE_LABEL_GQL,
    CREATE_MEDICAL_CONDITION_GQL,
    CREATE_MEDICAL_CONTRAINDICATION_GQL,
    CREATE_MEDICAL_DEVICE_GQL,
    CREATE_MEDICAL_DRUG_CLASS_GQL,
    CREATE_MEDICAL_DRUG_GQL,
    CREATE_MEDICAL_GUIDELINE_GQL,
    CREATE_MEDICAL_INDICATION_GQL,
    CREATE_MEDICAL_PROCEDURE_GQL,
    CREATE_MEDICAL_STUDY_GQL,
    CREATE_MEDICAL_TEST_GQL,
    CREATE_MEDICAL_THERAPY_GQL,
    CREATE_OBSERVATION_GQL,
    CREATE_ORGANIZATION_GQL,
    CREATE_PERSON_GQL,
    CREATE_PLACE_GQL,
    CREATE_PRODUCT_GQL,
    CREATE_REPO_GQL,
    CREATE_SOFTWARE_GQL,
    CREATE_SPECIFICATION_GQL,
    CREATE_USER_GQL,
    CREATE_WORKFLOW_GQL,
    DELETE_ALERT_GQL,
    DELETE_ALERTS_GQL,
    DELETE_ALL_ALERTS_GQL,
    DELETE_ALL_CATEGORIES_GQL,
    DELETE_ALL_COLLECTIONS_GQL,
    DELETE_ALL_CONTENTS_GQL,
    DELETE_ALL_CONVERSATIONS_GQL,
    DELETE_ALL_EVENTS_GQL,
    DELETE_ALL_FEEDS_GQL,
    DELETE_ALL_LABELS_GQL,
    DELETE_ALL_MEDICAL_CONDITIONS_GQL,
    DELETE_ALL_MEDICAL_CONTRAINDICATIONS_GQL,
    DELETE_ALL_MEDICAL_DEVICES_GQL,
    DELETE_ALL_MEDICAL_DRUG_CLASSES_GQL,
    DELETE_ALL_MEDICAL_DRUGS_GQL,
    DELETE_ALL_MEDICAL_GUIDELINES_GQL,
    DELETE_ALL_MEDICAL_INDICATIONS_GQL,
    DELETE_ALL_MEDICAL_PROCEDURES_GQL,
    DELETE_ALL_MEDICAL_STUDIES_GQL,
    DELETE_ALL_MEDICAL_TESTS_GQL,
    DELETE_ALL_MEDICAL_THERAPIES_GQL,
    DELETE_ALL_ORGANIZATIONS_GQL,
    DELETE_ALL_PERSONS_GQL,
    DELETE_ALL_PLACES_GQL,
    DELETE_ALL_PRODUCTS_GQL,
    DELETE_ALL_REPOS_GQL,
    DELETE_ALL_SOFTWARES_GQL,
    DELETE_ALL_SPECIFICATIONS_GQL,
    DELETE_ALL_WORKFLOWS_GQL,
    DELETE_CATEGORIES_GQL,
    DELETE_CATEGORY_GQL,
    DELETE_COLLECTION_GQL,
    DELETE_COLLECTIONS_GQL,
    DELETE_CONTENT_GQL,
    DELETE_CONTENTS_GQL,
    DELETE_CONVERSATION_GQL,
    DELETE_CONVERSATIONS_GQL,
    DELETE_EVENT_GQL,
    DELETE_EVENTS_GQL,
    DELETE_FEED_GQL,
    DELETE_FEEDS_GQL,
    DELETE_LABEL_GQL,
    DELETE_LABELS_GQL,
    DELETE_MEDICAL_CONDITION_GQL,
    DELETE_MEDICAL_CONDITIONS_GQL,
    DELETE_MEDICAL_CONTRAINDICATION_GQL,
    DELETE_MEDICAL_CONTRAINDICATIONS_GQL,
    DELETE_MEDICAL_DEVICE_GQL,
    DELETE_MEDICAL_DEVICES_GQL,
    DELETE_MEDICAL_DRUG_CLASS_GQL,
    DELETE_MEDICAL_DRUG_CLASSES_GQL,
    DELETE_MEDICAL_DRUG_GQL,
    DELETE_MEDICAL_DRUGS_GQL,
    DELETE_MEDICAL_GUIDELINE_GQL,
    DELETE_MEDICAL_GUIDELINES_GQL,
    DELETE_MEDICAL_INDICATION_GQL,
    DELETE_MEDICAL_INDICATIONS_GQL,
    DELETE_MEDICAL_PROCEDURE_GQL,
    DELETE_MEDICAL_PROCEDURES_GQL,
    DELETE_MEDICAL_STUDIES_GQL,
    DELETE_MEDICAL_STUDY_GQL,
    DELETE_MEDICAL_TEST_GQL,
    DELETE_MEDICAL_TESTS_GQL,
    DELETE_MEDICAL_THERAPIES_GQL,
    DELETE_MEDICAL_THERAPY_GQL,
    DELETE_OBSERVATION_GQL,
    DELETE_ORGANIZATION_GQL,
    DELETE_ORGANIZATIONS_GQL,
    DELETE_PERSON_GQL,
    DELETE_PERSONS_GQL,
    DELETE_PLACE_GQL,
    DELETE_PLACES_GQL,
    DELETE_PRODUCT_GQL,
    DELETE_PRODUCTS_GQL,
    DELETE_REPO_GQL,
    DELETE_REPOS_GQL,
    DELETE_SOFTWARE_GQL,
    DELETE_SOFTWARES_GQL,
    DELETE_SPECIFICATION_GQL,
    DELETE_SPECIFICATIONS_GQL,
    DELETE_USER_GQL,
    DELETE_WORKFLOW_GQL,
    DELETE_WORKFLOWS_GQL,
    DESCRIBE_ENCODED_IMAGE_GQL,
    DESCRIBE_IMAGE_GQL,
    DISABLE_ALERT_GQL,
    DISABLE_FEED_GQL,
    DISABLE_USER_GQL,
    ENABLE_ALERT_GQL,
    ENABLE_FEED_GQL,
    ENABLE_USER_GQL,
    EXTRACT_CONTENTS_GQL,
    EXTRACT_TEXT_GQL,
    FEED_EXISTS_GQL,
    FORMAT_CONVERSATION_GQL,
    GET_ALERT_GQL,
    GET_CATEGORY_GQL,
    GET_COLLECTION_GQL,
    GET_CONTENT_GQL,
    GET_CONVERSATION_GQL,
    GET_EVENT_GQL,
    GET_FEED_GQL,
    GET_LABEL_GQL,
    GET_MEDICAL_CONDITION_GQL,
    GET_MEDICAL_CONTRAINDICATION_GQL,
    GET_MEDICAL_DEVICE_GQL,
    GET_MEDICAL_DRUG_CLASS_GQL,
    GET_MEDICAL_DRUG_GQL,
    GET_MEDICAL_GUIDELINE_GQL,
    GET_MEDICAL_INDICATION_GQL,
    GET_MEDICAL_PROCEDURE_GQL,
    GET_MEDICAL_STUDY_GQL,
    GET_MEDICAL_TEST_GQL,
    GET_MEDICAL_THERAPY_GQL,
    GET_ORGANIZATION_GQL,
    GET_PERSON_GQL,
    GET_PLACE_GQL,
    GET_PRODUCT_GQL,
    GET_PROJECT_GQL,
    GET_REPO_GQL,
    GET_SHARE_POINT_CONSENT_URI_GQL,
    GET_SOFTWARE_GQL,
    GET_SPECIFICATION_GQL,
    GET_USER_GQL,
    GET_WORKFLOW_GQL,
    INGEST_BATCH_GQL,
    INGEST_ENCODED_FILE_GQL,
    INGEST_MEMORY_GQL,
    INGEST_TEXT_BATCH_GQL,
    INGEST_TEXT_GQL,
    INGEST_URI_GQL,
    IS_CONTENT_DONE_GQL,
    IS_FEED_DONE_GQL,
    LOOKUP_CREDITS_GQL,
    LOOKUP_USAGE_GQL,
    MAP_WEB_GQL,
    PROMPT_CONVERSATION_GQL,
    PROMPT_GQL,
    PROMPT_SPECIFICATIONS_GQL,
    PUBLISH_CONTENTS_GQL,
    PUBLISH_CONVERSATION_GQL,
    PUBLISH_TEXT_GQL,
    QUERY_ALERTS_GQL,
    QUERY_CATEGORIES_GQL,
    QUERY_COLLECTIONS_GQL,
    QUERY_CONTENTS_FACETS_GQL,
    QUERY_CONTENTS_GQL,
    QUERY_CONTENTS_GRAPH_GQL,
    QUERY_CONVERSATIONS_GQL,
    QUERY_CREDITS_GQL,
    QUERY_EVENTS_GQL,
    QUERY_FEEDS_GQL,
    QUERY_LABELS_GQL,
    QUERY_LINEAR_PROJECTS_GQL,
    QUERY_MEDICAL_CONDITIONS_GQL,
    QUERY_MEDICAL_CONTRAINDICATIONS_GQL,
    QUERY_MEDICAL_DEVICES_GQL,
    QUERY_MEDICAL_DRUG_CLASSES_GQL,
    QUERY_MEDICAL_DRUGS_GQL,
    QUERY_MEDICAL_GUIDELINES_GQL,
    QUERY_MEDICAL_INDICATIONS_GQL,
    QUERY_MEDICAL_PROCEDURES_GQL,
    QUERY_MEDICAL_STUDIES_GQL,
    QUERY_MEDICAL_TESTS_GQL,
    QUERY_MEDICAL_THERAPIES_GQL,
    QUERY_MICROSOFT_TEAMS_CHANNELS_GQL,
    QUERY_MICROSOFT_TEAMS_TEAMS_GQL,
    QUERY_MODELS_GQL,
    QUERY_NOTION_DATABASES_GQL,
    QUERY_NOTION_PAGES_GQL,
    QUERY_ONE_DRIVE_FOLDERS_GQL,
    QUERY_ORGANIZATIONS_GQL,
    QUERY_PERSONS_GQL,
    QUERY_PLACES_GQL,
    QUERY_PRODUCTS_GQL,
    QUERY_REPOS_GQL,
    QUERY_SHARE_POINT_FOLDERS_GQL,
    QUERY_SHARE_POINT_LIBRARIES_GQL,
    QUERY_SLACK_CHANNELS_GQL,
    QUERY_SOFTWARES_GQL,
    QUERY_SPECIFICATIONS_GQL,
    QUERY_TOKENS_GQL,
    QUERY_USAGE_GQL,
    QUERY_USERS_GQL,
    QUERY_WORKFLOWS_GQL,
    REMOVE_CONTENTS_FROM_COLLECTION_GQL,
    RETRIEVE_SOURCES_GQL,
    REVISE_CONTENT_GQL,
    REVISE_ENCODED_IMAGE_GQL,
    REVISE_IMAGE_GQL,
    REVISE_TEXT_GQL,
    SCREENSHOT_PAGE_GQL,
    SEARCH_WEB_GQL,
    SEND_NOTIFICATION_GQL,
    SPECIFICATION_EXISTS_GQL,
    SUGGEST_CONVERSATION_GQL,
    SUMMARIZE_CONTENTS_GQL,
    SUMMARIZE_TEXT_GQL,
    UPDATE_ALERT_GQL,
    UPDATE_CATEGORY_GQL,
    UPDATE_COLLECTION_GQL,
    UPDATE_CONTENT_GQL,
    UPDATE_CONVERSATION_GQL,
    UPDATE_EVENT_GQL,
    UPDATE_FEED_GQL,
    UPDATE_LABEL_GQL,
    UPDATE_MEDICAL_CONDITION_GQL,
    UPDATE_MEDICAL_CONTRAINDICATION_GQL,
    UPDATE_MEDICAL_DEVICE_GQL,
    UPDATE_MEDICAL_DRUG_CLASS_GQL,
    UPDATE_MEDICAL_DRUG_GQL,
    UPDATE_MEDICAL_GUIDELINE_GQL,
    UPDATE_MEDICAL_INDICATION_GQL,
    UPDATE_MEDICAL_PROCEDURE_GQL,
    UPDATE_MEDICAL_STUDY_GQL,
    UPDATE_MEDICAL_TEST_GQL,
    UPDATE_MEDICAL_THERAPY_GQL,
    UPDATE_OBSERVATION_GQL,
    UPDATE_ORGANIZATION_GQL,
    UPDATE_PERSON_GQL,
    UPDATE_PLACE_GQL,
    UPDATE_PRODUCT_GQL,
    UPDATE_PROJECT_GQL,
    UPDATE_REPO_GQL,
    UPDATE_SOFTWARE_GQL,
    UPDATE_SPECIFICATION_GQL,
    UPDATE_USER_GQL,
    UPDATE_WORKFLOW_GQL,
    UPSERT_CATEGORY_GQL,
    UPSERT_LABEL_GQL,
    UPSERT_SPECIFICATION_GQL,
    UPSERT_WORKFLOW_GQL,
    WORKFLOW_EXISTS_GQL,
)
from .prompt import Prompt
from .prompt_conversation import PromptConversation
from .prompt_specifications import PromptSpecifications
from .publish_contents import PublishContents
from .publish_conversation import PublishConversation
from .publish_text import PublishText
from .query_alerts import QueryAlerts
from .query_categories import QueryCategories
from .query_collections import QueryCollections
from .query_contents import QueryContents
from .query_contents_facets import QueryContentsFacets
from .query_contents_graph import QueryContentsGraph
from .query_conversations import QueryConversations
from .query_credits import QueryCredits
from .query_events import QueryEvents
from .query_feeds import QueryFeeds
from .query_labels import QueryLabels
from .query_linear_projects import QueryLinearProjects
from .query_medical_conditions import QueryMedicalConditions
from .query_medical_contraindications import QueryMedicalContraindications
from .query_medical_devices import QueryMedicalDevices
from .query_medical_drug_classes import QueryMedicalDrugClasses
from .query_medical_drugs import QueryMedicalDrugs
from .query_medical_guidelines import QueryMedicalGuidelines
from .query_medical_indications import QueryMedicalIndications
from .query_medical_procedures import QueryMedicalProcedures
from .query_medical_studies import QueryMedicalStudies
from .query_medical_tests import QueryMedicalTests
from .query_medical_therapies import QueryMedicalTherapies
from .query_microsoft_teams_channels import QueryMicrosoftTeamsChannels
from .query_microsoft_teams_teams import QueryMicrosoftTeamsTeams
from .query_models import QueryModels
from .query_notion_databases import QueryNotionDatabases
from .query_notion_pages import QueryNotionPages
from .query_one_drive_folders import QueryOneDriveFolders
from .query_organizations import QueryOrganizations
from .query_persons import QueryPersons
from .query_places import QueryPlaces
from .query_products import QueryProducts
from .query_repos import QueryRepos
from .query_share_point_folders import QuerySharePointFolders
from .query_share_point_libraries import QuerySharePointLibraries
from .query_slack_channels import QuerySlackChannels
from .query_softwares import QuerySoftwares
from .query_specifications import QuerySpecifications
from .query_tokens import QueryTokens
from .query_usage import QueryUsage
from .query_users import QueryUsers
from .query_workflows import QueryWorkflows
from .remove_contents_from_collection import RemoveContentsFromCollection
from .retrieve_sources import RetrieveSources
from .revise_content import ReviseContent
from .revise_encoded_image import ReviseEncodedImage
from .revise_image import ReviseImage
from .revise_text import ReviseText
from .screenshot_page import ScreenshotPage
from .search_web import SearchWeb
from .send_notification import SendNotification
from .specification_exists import SpecificationExists
from .suggest_conversation import SuggestConversation
from .summarize_contents import SummarizeContents
from .summarize_text import SummarizeText
from .update_alert import UpdateAlert
from .update_category import UpdateCategory
from .update_collection import UpdateCollection
from .update_content import UpdateContent
from .update_conversation import UpdateConversation
from .update_event import UpdateEvent
from .update_feed import UpdateFeed
from .update_label import UpdateLabel
from .update_medical_condition import UpdateMedicalCondition
from .update_medical_contraindication import UpdateMedicalContraindication
from .update_medical_device import UpdateMedicalDevice
from .update_medical_drug import UpdateMedicalDrug
from .update_medical_drug_class import UpdateMedicalDrugClass
from .update_medical_guideline import UpdateMedicalGuideline
from .update_medical_indication import UpdateMedicalIndication
from .update_medical_procedure import UpdateMedicalProcedure
from .update_medical_study import UpdateMedicalStudy
from .update_medical_test import UpdateMedicalTest
from .update_medical_therapy import UpdateMedicalTherapy
from .update_observation import UpdateObservation
from .update_organization import UpdateOrganization
from .update_person import UpdatePerson
from .update_place import UpdatePlace
from .update_product import UpdateProduct
from .update_project import UpdateProject
from .update_repo import UpdateRepo
from .update_software import UpdateSoftware
from .update_specification import UpdateSpecification
from .update_user import UpdateUser
from .update_workflow import UpdateWorkflow
from .upsert_category import UpsertCategory
from .upsert_label import UpsertLabel
from .upsert_specification import UpsertSpecification
from .upsert_workflow import UpsertWorkflow
from .workflow_exists import WorkflowExists


def gql(q: str) -> str:
    return q


class Client(AsyncBaseClient):
    async def count_alerts(
        self,
        filter: Union[Optional[AlertFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountAlerts:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_ALERTS_GQL,
            operation_name="CountAlerts",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountAlerts.model_validate(data)

    async def create_alert(
        self,
        alert: AlertInput,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CreateAlert:
        variables: Dict[str, object] = {"alert": alert, "correlationId": correlation_id}
        response = await self.execute(
            query=CREATE_ALERT_GQL,
            operation_name="CreateAlert",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateAlert.model_validate(data)

    async def delete_alert(self, id: str, **kwargs: Any) -> DeleteAlert:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_ALERT_GQL,
            operation_name="DeleteAlert",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAlert.model_validate(data)

    async def delete_alerts(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAlerts:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_ALERTS_GQL,
            operation_name="DeleteAlerts",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAlerts.model_validate(data)

    async def delete_all_alerts(
        self,
        filter: Union[Optional[AlertFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllAlerts:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_ALERTS_GQL,
            operation_name="DeleteAllAlerts",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllAlerts.model_validate(data)

    async def disable_alert(self, id: str, **kwargs: Any) -> DisableAlert:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DISABLE_ALERT_GQL,
            operation_name="DisableAlert",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DisableAlert.model_validate(data)

    async def enable_alert(self, id: str, **kwargs: Any) -> EnableAlert:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=ENABLE_ALERT_GQL,
            operation_name="EnableAlert",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return EnableAlert.model_validate(data)

    async def get_alert(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetAlert:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_ALERT_GQL,
            operation_name="GetAlert",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetAlert.model_validate(data)

    async def query_alerts(
        self,
        filter: Union[Optional[AlertFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryAlerts:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_ALERTS_GQL,
            operation_name="QueryAlerts",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryAlerts.model_validate(data)

    async def update_alert(self, alert: AlertUpdateInput, **kwargs: Any) -> UpdateAlert:
        variables: Dict[str, object] = {"alert": alert}
        response = await self.execute(
            query=UPDATE_ALERT_GQL,
            operation_name="UpdateAlert",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateAlert.model_validate(data)

    async def count_categories(
        self,
        filter: Union[Optional[CategoryFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountCategories:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_CATEGORIES_GQL,
            operation_name="CountCategories",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountCategories.model_validate(data)

    async def create_category(
        self, category: CategoryInput, **kwargs: Any
    ) -> CreateCategory:
        variables: Dict[str, object] = {"category": category}
        response = await self.execute(
            query=CREATE_CATEGORY_GQL,
            operation_name="CreateCategory",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateCategory.model_validate(data)

    async def delete_all_categories(
        self,
        filter: Union[Optional[CategoryFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllCategories:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_CATEGORIES_GQL,
            operation_name="DeleteAllCategories",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllCategories.model_validate(data)

    async def delete_categories(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteCategories:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_CATEGORIES_GQL,
            operation_name="DeleteCategories",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteCategories.model_validate(data)

    async def delete_category(self, id: str, **kwargs: Any) -> DeleteCategory:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_CATEGORY_GQL,
            operation_name="DeleteCategory",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteCategory.model_validate(data)

    async def get_category(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetCategory:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_CATEGORY_GQL,
            operation_name="GetCategory",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetCategory.model_validate(data)

    async def query_categories(
        self,
        filter: Union[Optional[CategoryFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryCategories:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_CATEGORIES_GQL,
            operation_name="QueryCategories",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryCategories.model_validate(data)

    async def update_category(
        self, category: CategoryUpdateInput, **kwargs: Any
    ) -> UpdateCategory:
        variables: Dict[str, object] = {"category": category}
        response = await self.execute(
            query=UPDATE_CATEGORY_GQL,
            operation_name="UpdateCategory",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateCategory.model_validate(data)

    async def upsert_category(
        self, category: CategoryInput, **kwargs: Any
    ) -> UpsertCategory:
        variables: Dict[str, object] = {"category": category}
        response = await self.execute(
            query=UPSERT_CATEGORY_GQL,
            operation_name="UpsertCategory",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpsertCategory.model_validate(data)

    async def add_contents_to_collections(
        self,
        contents: List[EntityReferenceInput],
        collections: List[EntityReferenceInput],
        **kwargs: Any
    ) -> AddContentsToCollections:
        variables: Dict[str, object] = {
            "contents": contents,
            "collections": collections,
        }
        response = await self.execute(
            query=ADD_CONTENTS_TO_COLLECTIONS_GQL,
            operation_name="AddContentsToCollections",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return AddContentsToCollections.model_validate(data)

    async def count_collections(
        self,
        filter: Union[Optional[CollectionFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountCollections:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_COLLECTIONS_GQL,
            operation_name="CountCollections",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountCollections.model_validate(data)

    async def create_collection(
        self, collection: CollectionInput, **kwargs: Any
    ) -> CreateCollection:
        variables: Dict[str, object] = {"collection": collection}
        response = await self.execute(
            query=CREATE_COLLECTION_GQL,
            operation_name="CreateCollection",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateCollection.model_validate(data)

    async def delete_all_collections(
        self,
        filter: Union[Optional[CollectionFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllCollections:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_COLLECTIONS_GQL,
            operation_name="DeleteAllCollections",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllCollections.model_validate(data)

    async def delete_collection(self, id: str, **kwargs: Any) -> DeleteCollection:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_COLLECTION_GQL,
            operation_name="DeleteCollection",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteCollection.model_validate(data)

    async def delete_collections(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteCollections:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_COLLECTIONS_GQL,
            operation_name="DeleteCollections",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteCollections.model_validate(data)

    async def get_collection(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetCollection:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_COLLECTION_GQL,
            operation_name="GetCollection",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetCollection.model_validate(data)

    async def query_collections(
        self,
        filter: Union[Optional[CollectionFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryCollections:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_COLLECTIONS_GQL,
            operation_name="QueryCollections",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryCollections.model_validate(data)

    async def remove_contents_from_collection(
        self,
        contents: List[EntityReferenceInput],
        collection: EntityReferenceInput,
        **kwargs: Any
    ) -> RemoveContentsFromCollection:
        variables: Dict[str, object] = {"contents": contents, "collection": collection}
        response = await self.execute(
            query=REMOVE_CONTENTS_FROM_COLLECTION_GQL,
            operation_name="RemoveContentsFromCollection",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return RemoveContentsFromCollection.model_validate(data)

    async def update_collection(
        self, collection: CollectionUpdateInput, **kwargs: Any
    ) -> UpdateCollection:
        variables: Dict[str, object] = {"collection": collection}
        response = await self.execute(
            query=UPDATE_COLLECTION_GQL,
            operation_name="UpdateCollection",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateCollection.model_validate(data)

    async def count_contents(
        self,
        filter: Union[Optional[ContentFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountContents:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_CONTENTS_GQL,
            operation_name="CountContents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountContents.model_validate(data)

    async def delete_all_contents(
        self,
        filter: Union[Optional[ContentFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllContents:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_CONTENTS_GQL,
            operation_name="DeleteAllContents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllContents.model_validate(data)

    async def delete_content(self, id: str, **kwargs: Any) -> DeleteContent:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_CONTENT_GQL,
            operation_name="DeleteContent",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteContent.model_validate(data)

    async def delete_contents(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteContents:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_CONTENTS_GQL,
            operation_name="DeleteContents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteContents.model_validate(data)

    async def describe_encoded_image(
        self,
        prompt: str,
        mime_type: str,
        data: str,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DescribeEncodedImage:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "mimeType": mime_type,
            "data": data,
            "specification": specification,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DESCRIBE_ENCODED_IMAGE_GQL,
            operation_name="DescribeEncodedImage",
            variables=variables,
            **kwargs
        )
        _data = self.get_data(response)
        return DescribeEncodedImage.model_validate(_data)

    async def describe_image(
        self,
        prompt: str,
        uri: Any,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DescribeImage:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "uri": uri,
            "specification": specification,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DESCRIBE_IMAGE_GQL,
            operation_name="DescribeImage",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DescribeImage.model_validate(data)

    async def extract_contents(
        self,
        prompt: str,
        tools: List[ToolDefinitionInput],
        filter: Union[Optional[ContentFilter], UnsetType] = UNSET,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ExtractContents:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "filter": filter,
            "specification": specification,
            "tools": tools,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=EXTRACT_CONTENTS_GQL,
            operation_name="ExtractContents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ExtractContents.model_validate(data)

    async def extract_text(
        self,
        prompt: str,
        text: str,
        tools: List[ToolDefinitionInput],
        text_type: Union[Optional[TextTypes], UnsetType] = UNSET,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ExtractText:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "text": text,
            "textType": text_type,
            "specification": specification,
            "tools": tools,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=EXTRACT_TEXT_GQL,
            operation_name="ExtractText",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ExtractText.model_validate(data)

    async def get_content(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetContent:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_CONTENT_GQL,
            operation_name="GetContent",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetContent.model_validate(data)

    async def ingest_batch(
        self,
        uris: List[Any],
        workflow: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        collections: Union[Optional[List[EntityReferenceInput]], UnsetType] = UNSET,
        observations: Union[
            Optional[List[ObservationReferenceInput]], UnsetType
        ] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> IngestBatch:
        variables: Dict[str, object] = {
            "uris": uris,
            "workflow": workflow,
            "collections": collections,
            "observations": observations,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=INGEST_BATCH_GQL,
            operation_name="IngestBatch",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return IngestBatch.model_validate(data)

    async def ingest_encoded_file(
        self,
        name: str,
        data: str,
        mime_type: str,
        id: Union[Optional[str], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        collections: Union[Optional[List[EntityReferenceInput]], UnsetType] = UNSET,
        observations: Union[
            Optional[List[ObservationReferenceInput]], UnsetType
        ] = UNSET,
        workflow: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> IngestEncodedFile:
        variables: Dict[str, object] = {
            "name": name,
            "data": data,
            "mimeType": mime_type,
            "id": id,
            "isSynchronous": is_synchronous,
            "collections": collections,
            "observations": observations,
            "workflow": workflow,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=INGEST_ENCODED_FILE_GQL,
            operation_name="IngestEncodedFile",
            variables=variables,
            **kwargs
        )
        _data = self.get_data(response)
        return IngestEncodedFile.model_validate(_data)

    async def ingest_memory(
        self,
        text: str,
        name: Union[Optional[str], UnsetType] = UNSET,
        text_type: Union[Optional[TextTypes], UnsetType] = UNSET,
        collections: Union[Optional[List[EntityReferenceInput]], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> IngestMemory:
        variables: Dict[str, object] = {
            "text": text,
            "name": name,
            "textType": text_type,
            "collections": collections,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=INGEST_MEMORY_GQL,
            operation_name="IngestMemory",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return IngestMemory.model_validate(data)

    async def ingest_text(
        self,
        text: str,
        name: Union[Optional[str], UnsetType] = UNSET,
        text_type: Union[Optional[TextTypes], UnsetType] = UNSET,
        uri: Union[Optional[Any], UnsetType] = UNSET,
        id: Union[Optional[str], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        workflow: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        collections: Union[Optional[List[EntityReferenceInput]], UnsetType] = UNSET,
        observations: Union[
            Optional[List[ObservationReferenceInput]], UnsetType
        ] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> IngestText:
        variables: Dict[str, object] = {
            "text": text,
            "name": name,
            "textType": text_type,
            "uri": uri,
            "id": id,
            "isSynchronous": is_synchronous,
            "workflow": workflow,
            "collections": collections,
            "observations": observations,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=INGEST_TEXT_GQL,
            operation_name="IngestText",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return IngestText.model_validate(data)

    async def ingest_text_batch(
        self,
        batch: List[TextContentInput],
        text_type: Union[Optional[TextTypes], UnsetType] = UNSET,
        workflow: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        collections: Union[Optional[List[EntityReferenceInput]], UnsetType] = UNSET,
        observations: Union[
            Optional[List[ObservationReferenceInput]], UnsetType
        ] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> IngestTextBatch:
        variables: Dict[str, object] = {
            "batch": batch,
            "textType": text_type,
            "workflow": workflow,
            "collections": collections,
            "observations": observations,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=INGEST_TEXT_BATCH_GQL,
            operation_name="IngestTextBatch",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return IngestTextBatch.model_validate(data)

    async def ingest_uri(
        self,
        uri: Any,
        name: Union[Optional[str], UnsetType] = UNSET,
        id: Union[Optional[str], UnsetType] = UNSET,
        mime_type: Union[Optional[str], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        workflow: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        collections: Union[Optional[List[EntityReferenceInput]], UnsetType] = UNSET,
        observations: Union[
            Optional[List[ObservationReferenceInput]], UnsetType
        ] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> IngestUri:
        variables: Dict[str, object] = {
            "name": name,
            "uri": uri,
            "id": id,
            "mimeType": mime_type,
            "isSynchronous": is_synchronous,
            "workflow": workflow,
            "collections": collections,
            "observations": observations,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=INGEST_URI_GQL,
            operation_name="IngestUri",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return IngestUri.model_validate(data)

    async def is_content_done(self, id: str, **kwargs: Any) -> IsContentDone:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=IS_CONTENT_DONE_GQL,
            operation_name="IsContentDone",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return IsContentDone.model_validate(data)

    async def publish_contents(
        self,
        publish_prompt: str,
        connector: ContentPublishingConnectorInput,
        summary_prompt: Union[Optional[str], UnsetType] = UNSET,
        filter: Union[Optional[ContentFilter], UnsetType] = UNSET,
        include_details: Union[Optional[bool], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        name: Union[Optional[str], UnsetType] = UNSET,
        summary_specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        publish_specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        workflow: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        **kwargs: Any
    ) -> PublishContents:
        variables: Dict[str, object] = {
            "summaryPrompt": summary_prompt,
            "publishPrompt": publish_prompt,
            "connector": connector,
            "filter": filter,
            "includeDetails": include_details,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
            "name": name,
            "summarySpecification": summary_specification,
            "publishSpecification": publish_specification,
            "workflow": workflow,
        }
        response = await self.execute(
            query=PUBLISH_CONTENTS_GQL,
            operation_name="PublishContents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return PublishContents.model_validate(data)

    async def publish_text(
        self,
        text: str,
        connector: ContentPublishingConnectorInput,
        text_type: Union[Optional[TextTypes], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        name: Union[Optional[str], UnsetType] = UNSET,
        workflow: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        **kwargs: Any
    ) -> PublishText:
        variables: Dict[str, object] = {
            "text": text,
            "textType": text_type,
            "connector": connector,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
            "name": name,
            "workflow": workflow,
        }
        response = await self.execute(
            query=PUBLISH_TEXT_GQL,
            operation_name="PublishText",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return PublishText.model_validate(data)

    async def query_contents(
        self,
        filter: Union[Optional[ContentFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryContents:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_CONTENTS_GQL,
            operation_name="QueryContents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryContents.model_validate(data)

    async def query_contents_facets(
        self,
        filter: Union[Optional[ContentFilter], UnsetType] = UNSET,
        facets: Union[Optional[List[ContentFacetInput]], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryContentsFacets:
        variables: Dict[str, object] = {
            "filter": filter,
            "facets": facets,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_CONTENTS_FACETS_GQL,
            operation_name="QueryContentsFacets",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryContentsFacets.model_validate(data)

    async def query_contents_graph(
        self,
        filter: Union[Optional[ContentFilter], UnsetType] = UNSET,
        graph: Union[Optional[ContentGraphInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryContentsGraph:
        variables: Dict[str, object] = {
            "filter": filter,
            "graph": graph,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_CONTENTS_GRAPH_GQL,
            operation_name="QueryContentsGraph",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryContentsGraph.model_validate(data)

    async def screenshot_page(
        self,
        uri: Any,
        maximum_height: Union[Optional[int], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        workflow: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        collections: Union[Optional[List[EntityReferenceInput]], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ScreenshotPage:
        variables: Dict[str, object] = {
            "uri": uri,
            "maximumHeight": maximum_height,
            "isSynchronous": is_synchronous,
            "workflow": workflow,
            "collections": collections,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=SCREENSHOT_PAGE_GQL,
            operation_name="ScreenshotPage",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ScreenshotPage.model_validate(data)

    async def summarize_contents(
        self,
        summarizations: List[SummarizationStrategyInput],
        filter: Union[Optional[ContentFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> SummarizeContents:
        variables: Dict[str, object] = {
            "summarizations": summarizations,
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=SUMMARIZE_CONTENTS_GQL,
            operation_name="SummarizeContents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return SummarizeContents.model_validate(data)

    async def summarize_text(
        self,
        summarization: SummarizationStrategyInput,
        text: str,
        text_type: Union[Optional[TextTypes], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> SummarizeText:
        variables: Dict[str, object] = {
            "summarization": summarization,
            "text": text,
            "textType": text_type,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=SUMMARIZE_TEXT_GQL,
            operation_name="SummarizeText",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return SummarizeText.model_validate(data)

    async def update_content(
        self, content: ContentUpdateInput, **kwargs: Any
    ) -> UpdateContent:
        variables: Dict[str, object] = {"content": content}
        response = await self.execute(
            query=UPDATE_CONTENT_GQL,
            operation_name="UpdateContent",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateContent.model_validate(data)

    async def ask_graphlit(
        self,
        prompt: str,
        type: Union[Optional[SdkTypes], UnsetType] = UNSET,
        id: Union[Optional[str], UnsetType] = UNSET,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> AskGraphlit:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "type": type,
            "id": id,
            "specification": specification,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=ASK_GRAPHLIT_GQL,
            operation_name="AskGraphlit",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return AskGraphlit.model_validate(data)

    async def clear_conversation(self, id: str, **kwargs: Any) -> ClearConversation:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=CLEAR_CONVERSATION_GQL,
            operation_name="ClearConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ClearConversation.model_validate(data)

    async def close_conversation(self, id: str, **kwargs: Any) -> CloseConversation:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=CLOSE_CONVERSATION_GQL,
            operation_name="CloseConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CloseConversation.model_validate(data)

    async def complete_conversation(
        self,
        completion: str,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CompleteConversation:
        variables: Dict[str, object] = {
            "completion": completion,
            "id": id,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COMPLETE_CONVERSATION_GQL,
            operation_name="CompleteConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CompleteConversation.model_validate(data)

    async def continue_conversation(
        self,
        id: str,
        responses: List[ConversationToolResponseInput],
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ContinueConversation:
        variables: Dict[str, object] = {
            "id": id,
            "responses": responses,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=CONTINUE_CONVERSATION_GQL,
            operation_name="ContinueConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ContinueConversation.model_validate(data)

    async def count_conversations(
        self,
        filter: Union[Optional[ConversationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountConversations:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_CONVERSATIONS_GQL,
            operation_name="CountConversations",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountConversations.model_validate(data)

    async def create_conversation(
        self,
        conversation: ConversationInput,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CreateConversation:
        variables: Dict[str, object] = {
            "conversation": conversation,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=CREATE_CONVERSATION_GQL,
            operation_name="CreateConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateConversation.model_validate(data)

    async def delete_all_conversations(
        self,
        filter: Union[Optional[ConversationFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllConversations:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_CONVERSATIONS_GQL,
            operation_name="DeleteAllConversations",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllConversations.model_validate(data)

    async def delete_conversation(self, id: str, **kwargs: Any) -> DeleteConversation:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_CONVERSATION_GQL,
            operation_name="DeleteConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteConversation.model_validate(data)

    async def delete_conversations(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteConversations:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_CONVERSATIONS_GQL,
            operation_name="DeleteConversations",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteConversations.model_validate(data)

    async def format_conversation(
        self,
        prompt: str,
        id: Union[Optional[str], UnsetType] = UNSET,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        include_details: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> FormatConversation:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "id": id,
            "specification": specification,
            "includeDetails": include_details,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=FORMAT_CONVERSATION_GQL,
            operation_name="FormatConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return FormatConversation.model_validate(data)

    async def get_conversation(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetConversation:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_CONVERSATION_GQL,
            operation_name="GetConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetConversation.model_validate(data)

    async def prompt(
        self,
        prompt: Union[Optional[str], UnsetType] = UNSET,
        mime_type: Union[Optional[str], UnsetType] = UNSET,
        data: Union[Optional[str], UnsetType] = UNSET,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        messages: Union[Optional[List[ConversationMessageInput]], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> Prompt:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "mimeType": mime_type,
            "data": data,
            "specification": specification,
            "messages": messages,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=PROMPT_GQL, operation_name="Prompt", variables=variables, **kwargs
        )
        _data = self.get_data(response)
        return Prompt.model_validate(_data)

    async def prompt_conversation(
        self,
        prompt: str,
        mime_type: Union[Optional[str], UnsetType] = UNSET,
        data: Union[Optional[str], UnsetType] = UNSET,
        id: Union[Optional[str], UnsetType] = UNSET,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        tools: Union[Optional[List[ToolDefinitionInput]], UnsetType] = UNSET,
        require_tool: Union[Optional[bool], UnsetType] = UNSET,
        include_details: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> PromptConversation:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "mimeType": mime_type,
            "data": data,
            "id": id,
            "specification": specification,
            "tools": tools,
            "requireTool": require_tool,
            "includeDetails": include_details,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=PROMPT_CONVERSATION_GQL,
            operation_name="PromptConversation",
            variables=variables,
            **kwargs
        )
        _data = self.get_data(response)
        return PromptConversation.model_validate(_data)

    async def publish_conversation(
        self,
        id: str,
        connector: ContentPublishingConnectorInput,
        name: Union[Optional[str], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        workflow: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> PublishConversation:
        variables: Dict[str, object] = {
            "id": id,
            "connector": connector,
            "name": name,
            "isSynchronous": is_synchronous,
            "workflow": workflow,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=PUBLISH_CONVERSATION_GQL,
            operation_name="PublishConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return PublishConversation.model_validate(data)

    async def query_conversations(
        self,
        filter: Union[Optional[ConversationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryConversations:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_CONVERSATIONS_GQL,
            operation_name="QueryConversations",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryConversations.model_validate(data)

    async def retrieve_sources(
        self,
        prompt: str,
        filter: Union[Optional[ContentFilter], UnsetType] = UNSET,
        augmented_filter: Union[Optional[ContentFilter], UnsetType] = UNSET,
        retrieval_strategy: Union[Optional[RetrievalStrategyInput], UnsetType] = UNSET,
        reranking_strategy: Union[Optional[RerankingStrategyInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> RetrieveSources:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "filter": filter,
            "augmentedFilter": augmented_filter,
            "retrievalStrategy": retrieval_strategy,
            "rerankingStrategy": reranking_strategy,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=RETRIEVE_SOURCES_GQL,
            operation_name="RetrieveSources",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return RetrieveSources.model_validate(data)

    async def revise_content(
        self,
        prompt: str,
        content: EntityReferenceInput,
        id: Union[Optional[str], UnsetType] = UNSET,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ReviseContent:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "content": content,
            "id": id,
            "specification": specification,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=REVISE_CONTENT_GQL,
            operation_name="ReviseContent",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ReviseContent.model_validate(data)

    async def revise_encoded_image(
        self,
        prompt: str,
        mime_type: str,
        data: str,
        id: Union[Optional[str], UnsetType] = UNSET,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ReviseEncodedImage:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "mimeType": mime_type,
            "data": data,
            "id": id,
            "specification": specification,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=REVISE_ENCODED_IMAGE_GQL,
            operation_name="ReviseEncodedImage",
            variables=variables,
            **kwargs
        )
        _data = self.get_data(response)
        return ReviseEncodedImage.model_validate(_data)

    async def revise_image(
        self,
        prompt: str,
        uri: Any,
        id: Union[Optional[str], UnsetType] = UNSET,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ReviseImage:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "uri": uri,
            "id": id,
            "specification": specification,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=REVISE_IMAGE_GQL,
            operation_name="ReviseImage",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ReviseImage.model_validate(data)

    async def revise_text(
        self,
        prompt: str,
        text: str,
        id: Union[Optional[str], UnsetType] = UNSET,
        specification: Union[Optional[EntityReferenceInput], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ReviseText:
        variables: Dict[str, object] = {
            "prompt": prompt,
            "text": text,
            "id": id,
            "specification": specification,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=REVISE_TEXT_GQL,
            operation_name="ReviseText",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ReviseText.model_validate(data)

    async def suggest_conversation(
        self,
        id: str,
        count: Union[Optional[int], UnsetType] = UNSET,
        prompt: Union[Optional[str], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> SuggestConversation:
        variables: Dict[str, object] = {
            "id": id,
            "count": count,
            "prompt": prompt,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=SUGGEST_CONVERSATION_GQL,
            operation_name="SuggestConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return SuggestConversation.model_validate(data)

    async def update_conversation(
        self, conversation: ConversationUpdateInput, **kwargs: Any
    ) -> UpdateConversation:
        variables: Dict[str, object] = {"conversation": conversation}
        response = await self.execute(
            query=UPDATE_CONVERSATION_GQL,
            operation_name="UpdateConversation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateConversation.model_validate(data)

    async def count_events(
        self,
        filter: Union[Optional[EventFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountEvents:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_EVENTS_GQL,
            operation_name="CountEvents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountEvents.model_validate(data)

    async def create_event(self, event: EventInput, **kwargs: Any) -> CreateEvent:
        variables: Dict[str, object] = {"event": event}
        response = await self.execute(
            query=CREATE_EVENT_GQL,
            operation_name="CreateEvent",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateEvent.model_validate(data)

    async def delete_all_events(
        self,
        filter: Union[Optional[EventFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllEvents:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_EVENTS_GQL,
            operation_name="DeleteAllEvents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllEvents.model_validate(data)

    async def delete_event(self, id: str, **kwargs: Any) -> DeleteEvent:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_EVENT_GQL,
            operation_name="DeleteEvent",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteEvent.model_validate(data)

    async def delete_events(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteEvents:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_EVENTS_GQL,
            operation_name="DeleteEvents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteEvents.model_validate(data)

    async def get_event(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetEvent:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_EVENT_GQL,
            operation_name="GetEvent",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetEvent.model_validate(data)

    async def query_events(
        self,
        filter: Union[Optional[EventFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryEvents:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_EVENTS_GQL,
            operation_name="QueryEvents",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryEvents.model_validate(data)

    async def update_event(self, event: EventUpdateInput, **kwargs: Any) -> UpdateEvent:
        variables: Dict[str, object] = {"event": event}
        response = await self.execute(
            query=UPDATE_EVENT_GQL,
            operation_name="UpdateEvent",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateEvent.model_validate(data)

    async def count_feeds(
        self,
        filter: Union[Optional[FeedFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountFeeds:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_FEEDS_GQL,
            operation_name="CountFeeds",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountFeeds.model_validate(data)

    async def create_feed(
        self,
        feed: FeedInput,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CreateFeed:
        variables: Dict[str, object] = {"feed": feed, "correlationId": correlation_id}
        response = await self.execute(
            query=CREATE_FEED_GQL,
            operation_name="CreateFeed",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateFeed.model_validate(data)

    async def delete_all_feeds(
        self,
        filter: Union[Optional[FeedFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllFeeds:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_FEEDS_GQL,
            operation_name="DeleteAllFeeds",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllFeeds.model_validate(data)

    async def delete_feed(self, id: str, **kwargs: Any) -> DeleteFeed:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_FEED_GQL,
            operation_name="DeleteFeed",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteFeed.model_validate(data)

    async def delete_feeds(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteFeeds:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_FEEDS_GQL,
            operation_name="DeleteFeeds",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteFeeds.model_validate(data)

    async def disable_feed(self, id: str, **kwargs: Any) -> DisableFeed:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DISABLE_FEED_GQL,
            operation_name="DisableFeed",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DisableFeed.model_validate(data)

    async def enable_feed(self, id: str, **kwargs: Any) -> EnableFeed:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=ENABLE_FEED_GQL,
            operation_name="EnableFeed",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return EnableFeed.model_validate(data)

    async def feed_exists(
        self,
        filter: Union[Optional[FeedFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> FeedExists:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=FEED_EXISTS_GQL,
            operation_name="FeedExists",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return FeedExists.model_validate(data)

    async def get_feed(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetFeed:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_FEED_GQL, operation_name="GetFeed", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetFeed.model_validate(data)

    async def get_share_point_consent_uri(
        self, tenant_id: str, **kwargs: Any
    ) -> GetSharePointConsentUri:
        variables: Dict[str, object] = {"tenantId": tenant_id}
        response = await self.execute(
            query=GET_SHARE_POINT_CONSENT_URI_GQL,
            operation_name="GetSharePointConsentUri",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetSharePointConsentUri.model_validate(data)

    async def is_feed_done(self, id: str, **kwargs: Any) -> IsFeedDone:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=IS_FEED_DONE_GQL,
            operation_name="IsFeedDone",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return IsFeedDone.model_validate(data)

    async def query_feeds(
        self,
        filter: Union[Optional[FeedFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryFeeds:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_FEEDS_GQL,
            operation_name="QueryFeeds",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryFeeds.model_validate(data)

    async def query_linear_projects(
        self, properties: LinearProjectsInput, **kwargs: Any
    ) -> QueryLinearProjects:
        variables: Dict[str, object] = {"properties": properties}
        response = await self.execute(
            query=QUERY_LINEAR_PROJECTS_GQL,
            operation_name="QueryLinearProjects",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryLinearProjects.model_validate(data)

    async def query_microsoft_teams_channels(
        self, properties: MicrosoftTeamsChannelsInput, team_id: str, **kwargs: Any
    ) -> QueryMicrosoftTeamsChannels:
        variables: Dict[str, object] = {"properties": properties, "teamId": team_id}
        response = await self.execute(
            query=QUERY_MICROSOFT_TEAMS_CHANNELS_GQL,
            operation_name="QueryMicrosoftTeamsChannels",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMicrosoftTeamsChannels.model_validate(data)

    async def query_microsoft_teams_teams(
        self, properties: MicrosoftTeamsTeamsInput, **kwargs: Any
    ) -> QueryMicrosoftTeamsTeams:
        variables: Dict[str, object] = {"properties": properties}
        response = await self.execute(
            query=QUERY_MICROSOFT_TEAMS_TEAMS_GQL,
            operation_name="QueryMicrosoftTeamsTeams",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMicrosoftTeamsTeams.model_validate(data)

    async def query_notion_databases(
        self, properties: NotionDatabasesInput, **kwargs: Any
    ) -> QueryNotionDatabases:
        variables: Dict[str, object] = {"properties": properties}
        response = await self.execute(
            query=QUERY_NOTION_DATABASES_GQL,
            operation_name="QueryNotionDatabases",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryNotionDatabases.model_validate(data)

    async def query_notion_pages(
        self, properties: NotionPagesInput, identifier: str, **kwargs: Any
    ) -> QueryNotionPages:
        variables: Dict[str, object] = {
            "properties": properties,
            "identifier": identifier,
        }
        response = await self.execute(
            query=QUERY_NOTION_PAGES_GQL,
            operation_name="QueryNotionPages",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryNotionPages.model_validate(data)

    async def query_one_drive_folders(
        self,
        properties: OneDriveFoldersInput,
        folder_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryOneDriveFolders:
        variables: Dict[str, object] = {"properties": properties, "folderId": folder_id}
        response = await self.execute(
            query=QUERY_ONE_DRIVE_FOLDERS_GQL,
            operation_name="QueryOneDriveFolders",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryOneDriveFolders.model_validate(data)

    async def query_share_point_folders(
        self,
        properties: SharePointFoldersInput,
        library_id: str,
        folder_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QuerySharePointFolders:
        variables: Dict[str, object] = {
            "properties": properties,
            "libraryId": library_id,
            "folderId": folder_id,
        }
        response = await self.execute(
            query=QUERY_SHARE_POINT_FOLDERS_GQL,
            operation_name="QuerySharePointFolders",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QuerySharePointFolders.model_validate(data)

    async def query_share_point_libraries(
        self, properties: SharePointLibrariesInput, **kwargs: Any
    ) -> QuerySharePointLibraries:
        variables: Dict[str, object] = {"properties": properties}
        response = await self.execute(
            query=QUERY_SHARE_POINT_LIBRARIES_GQL,
            operation_name="QuerySharePointLibraries",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QuerySharePointLibraries.model_validate(data)

    async def query_slack_channels(
        self, properties: SlackChannelsInput, **kwargs: Any
    ) -> QuerySlackChannels:
        variables: Dict[str, object] = {"properties": properties}
        response = await self.execute(
            query=QUERY_SLACK_CHANNELS_GQL,
            operation_name="QuerySlackChannels",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QuerySlackChannels.model_validate(data)

    async def update_feed(self, feed: FeedUpdateInput, **kwargs: Any) -> UpdateFeed:
        variables: Dict[str, object] = {"feed": feed}
        response = await self.execute(
            query=UPDATE_FEED_GQL,
            operation_name="UpdateFeed",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateFeed.model_validate(data)

    async def count_labels(
        self,
        filter: Union[Optional[LabelFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountLabels:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_LABELS_GQL,
            operation_name="CountLabels",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountLabels.model_validate(data)

    async def create_label(self, label: LabelInput, **kwargs: Any) -> CreateLabel:
        variables: Dict[str, object] = {"label": label}
        response = await self.execute(
            query=CREATE_LABEL_GQL,
            operation_name="CreateLabel",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateLabel.model_validate(data)

    async def delete_all_labels(
        self,
        filter: Union[Optional[LabelFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllLabels:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_LABELS_GQL,
            operation_name="DeleteAllLabels",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllLabels.model_validate(data)

    async def delete_label(self, id: str, **kwargs: Any) -> DeleteLabel:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_LABEL_GQL,
            operation_name="DeleteLabel",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteLabel.model_validate(data)

    async def delete_labels(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteLabels:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_LABELS_GQL,
            operation_name="DeleteLabels",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteLabels.model_validate(data)

    async def get_label(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetLabel:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_LABEL_GQL,
            operation_name="GetLabel",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetLabel.model_validate(data)

    async def query_labels(
        self,
        filter: Union[Optional[LabelFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryLabels:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_LABELS_GQL,
            operation_name="QueryLabels",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryLabels.model_validate(data)

    async def update_label(self, label: LabelUpdateInput, **kwargs: Any) -> UpdateLabel:
        variables: Dict[str, object] = {"label": label}
        response = await self.execute(
            query=UPDATE_LABEL_GQL,
            operation_name="UpdateLabel",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateLabel.model_validate(data)

    async def upsert_label(self, label: LabelInput, **kwargs: Any) -> UpsertLabel:
        variables: Dict[str, object] = {"label": label}
        response = await self.execute(
            query=UPSERT_LABEL_GQL,
            operation_name="UpsertLabel",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpsertLabel.model_validate(data)

    async def count_medical_conditions(
        self,
        filter: Union[Optional[MedicalConditionFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalConditions:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_MEDICAL_CONDITIONS_GQL,
            operation_name="CountMedicalConditions",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalConditions.model_validate(data)

    async def create_medical_condition(
        self, medical_condition: MedicalConditionInput, **kwargs: Any
    ) -> CreateMedicalCondition:
        variables: Dict[str, object] = {"medicalCondition": medical_condition}
        response = await self.execute(
            query=CREATE_MEDICAL_CONDITION_GQL,
            operation_name="CreateMedicalCondition",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalCondition.model_validate(data)

    async def delete_all_medical_conditions(
        self,
        filter: Union[Optional[MedicalConditionFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalConditions:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_CONDITIONS_GQL,
            operation_name="DeleteAllMedicalConditions",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalConditions.model_validate(data)

    async def delete_medical_condition(
        self, id: str, **kwargs: Any
    ) -> DeleteMedicalCondition:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_CONDITION_GQL,
            operation_name="DeleteMedicalCondition",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalCondition.model_validate(data)

    async def delete_medical_conditions(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalConditions:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_CONDITIONS_GQL,
            operation_name="DeleteMedicalConditions",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalConditions.model_validate(data)

    async def get_medical_condition(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalCondition:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_CONDITION_GQL,
            operation_name="GetMedicalCondition",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalCondition.model_validate(data)

    async def query_medical_conditions(
        self,
        filter: Union[Optional[MedicalConditionFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalConditions:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_CONDITIONS_GQL,
            operation_name="QueryMedicalConditions",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalConditions.model_validate(data)

    async def update_medical_condition(
        self, medical_condition: MedicalConditionUpdateInput, **kwargs: Any
    ) -> UpdateMedicalCondition:
        variables: Dict[str, object] = {"medicalCondition": medical_condition}
        response = await self.execute(
            query=UPDATE_MEDICAL_CONDITION_GQL,
            operation_name="UpdateMedicalCondition",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalCondition.model_validate(data)

    async def count_medical_contraindications(
        self,
        filter: Union[Optional[MedicalContraindicationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalContraindications:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_MEDICAL_CONTRAINDICATIONS_GQL,
            operation_name="CountMedicalContraindications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalContraindications.model_validate(data)

    async def create_medical_contraindication(
        self, medical_contraindication: MedicalContraindicationInput, **kwargs: Any
    ) -> CreateMedicalContraindication:
        variables: Dict[str, object] = {
            "medicalContraindication": medical_contraindication
        }
        response = await self.execute(
            query=CREATE_MEDICAL_CONTRAINDICATION_GQL,
            operation_name="CreateMedicalContraindication",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalContraindication.model_validate(data)

    async def delete_all_medical_contraindications(
        self,
        filter: Union[Optional[MedicalContraindicationFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalContraindications:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_CONTRAINDICATIONS_GQL,
            operation_name="DeleteAllMedicalContraindications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalContraindications.model_validate(data)

    async def delete_medical_contraindication(
        self, id: str, **kwargs: Any
    ) -> DeleteMedicalContraindication:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_CONTRAINDICATION_GQL,
            operation_name="DeleteMedicalContraindication",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalContraindication.model_validate(data)

    async def delete_medical_contraindications(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalContraindications:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_CONTRAINDICATIONS_GQL,
            operation_name="DeleteMedicalContraindications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalContraindications.model_validate(data)

    async def get_medical_contraindication(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalContraindication:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_CONTRAINDICATION_GQL,
            operation_name="GetMedicalContraindication",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalContraindication.model_validate(data)

    async def query_medical_contraindications(
        self,
        filter: Union[Optional[MedicalContraindicationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalContraindications:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_CONTRAINDICATIONS_GQL,
            operation_name="QueryMedicalContraindications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalContraindications.model_validate(data)

    async def update_medical_contraindication(
        self,
        medical_contraindication: MedicalContraindicationUpdateInput,
        **kwargs: Any
    ) -> UpdateMedicalContraindication:
        variables: Dict[str, object] = {
            "medicalContraindication": medical_contraindication
        }
        response = await self.execute(
            query=UPDATE_MEDICAL_CONTRAINDICATION_GQL,
            operation_name="UpdateMedicalContraindication",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalContraindication.model_validate(data)

    async def count_medical_devices(
        self,
        filter: Union[Optional[MedicalDeviceFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalDevices:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_MEDICAL_DEVICES_GQL,
            operation_name="CountMedicalDevices",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalDevices.model_validate(data)

    async def create_medical_device(
        self, medical_device: MedicalDeviceInput, **kwargs: Any
    ) -> CreateMedicalDevice:
        variables: Dict[str, object] = {"medicalDevice": medical_device}
        response = await self.execute(
            query=CREATE_MEDICAL_DEVICE_GQL,
            operation_name="CreateMedicalDevice",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalDevice.model_validate(data)

    async def delete_all_medical_devices(
        self,
        filter: Union[Optional[MedicalDeviceFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalDevices:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_DEVICES_GQL,
            operation_name="DeleteAllMedicalDevices",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalDevices.model_validate(data)

    async def delete_medical_device(
        self, id: str, **kwargs: Any
    ) -> DeleteMedicalDevice:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_DEVICE_GQL,
            operation_name="DeleteMedicalDevice",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalDevice.model_validate(data)

    async def delete_medical_devices(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalDevices:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_DEVICES_GQL,
            operation_name="DeleteMedicalDevices",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalDevices.model_validate(data)

    async def get_medical_device(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalDevice:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_DEVICE_GQL,
            operation_name="GetMedicalDevice",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalDevice.model_validate(data)

    async def query_medical_devices(
        self,
        filter: Union[Optional[MedicalDeviceFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalDevices:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_DEVICES_GQL,
            operation_name="QueryMedicalDevices",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalDevices.model_validate(data)

    async def update_medical_device(
        self, medical_device: MedicalDeviceUpdateInput, **kwargs: Any
    ) -> UpdateMedicalDevice:
        variables: Dict[str, object] = {"medicalDevice": medical_device}
        response = await self.execute(
            query=UPDATE_MEDICAL_DEVICE_GQL,
            operation_name="UpdateMedicalDevice",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalDevice.model_validate(data)

    async def count_medical_drugs(
        self,
        filter: Union[Optional[MedicalDrugFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalDrugs:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_MEDICAL_DRUGS_GQL,
            operation_name="CountMedicalDrugs",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalDrugs.model_validate(data)

    async def create_medical_drug(
        self, medical_drug: MedicalDrugInput, **kwargs: Any
    ) -> CreateMedicalDrug:
        variables: Dict[str, object] = {"medicalDrug": medical_drug}
        response = await self.execute(
            query=CREATE_MEDICAL_DRUG_GQL,
            operation_name="CreateMedicalDrug",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalDrug.model_validate(data)

    async def delete_all_medical_drugs(
        self,
        filter: Union[Optional[MedicalDrugFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalDrugs:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_DRUGS_GQL,
            operation_name="DeleteAllMedicalDrugs",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalDrugs.model_validate(data)

    async def delete_medical_drug(self, id: str, **kwargs: Any) -> DeleteMedicalDrug:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_DRUG_GQL,
            operation_name="DeleteMedicalDrug",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalDrug.model_validate(data)

    async def delete_medical_drugs(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalDrugs:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_DRUGS_GQL,
            operation_name="DeleteMedicalDrugs",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalDrugs.model_validate(data)

    async def get_medical_drug(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalDrug:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_DRUG_GQL,
            operation_name="GetMedicalDrug",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalDrug.model_validate(data)

    async def query_medical_drugs(
        self,
        filter: Union[Optional[MedicalDrugFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalDrugs:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_DRUGS_GQL,
            operation_name="QueryMedicalDrugs",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalDrugs.model_validate(data)

    async def update_medical_drug(
        self, medical_drug: MedicalDrugUpdateInput, **kwargs: Any
    ) -> UpdateMedicalDrug:
        variables: Dict[str, object] = {"medicalDrug": medical_drug}
        response = await self.execute(
            query=UPDATE_MEDICAL_DRUG_GQL,
            operation_name="UpdateMedicalDrug",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalDrug.model_validate(data)

    async def count_medical_drug_classes(
        self,
        filter: Union[Optional[MedicalDrugClassFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalDrugClasses:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_MEDICAL_DRUG_CLASSES_GQL,
            operation_name="CountMedicalDrugClasses",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalDrugClasses.model_validate(data)

    async def create_medical_drug_class(
        self, medical_drug_class: MedicalDrugClassInput, **kwargs: Any
    ) -> CreateMedicalDrugClass:
        variables: Dict[str, object] = {"medicalDrugClass": medical_drug_class}
        response = await self.execute(
            query=CREATE_MEDICAL_DRUG_CLASS_GQL,
            operation_name="CreateMedicalDrugClass",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalDrugClass.model_validate(data)

    async def delete_all_medical_drug_classes(
        self,
        filter: Union[Optional[MedicalDrugClassFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalDrugClasses:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_DRUG_CLASSES_GQL,
            operation_name="DeleteAllMedicalDrugClasses",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalDrugClasses.model_validate(data)

    async def delete_medical_drug_class(
        self, id: str, **kwargs: Any
    ) -> DeleteMedicalDrugClass:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_DRUG_CLASS_GQL,
            operation_name="DeleteMedicalDrugClass",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalDrugClass.model_validate(data)

    async def delete_medical_drug_classes(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalDrugClasses:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_DRUG_CLASSES_GQL,
            operation_name="DeleteMedicalDrugClasses",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalDrugClasses.model_validate(data)

    async def get_medical_drug_class(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalDrugClass:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_DRUG_CLASS_GQL,
            operation_name="GetMedicalDrugClass",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalDrugClass.model_validate(data)

    async def query_medical_drug_classes(
        self,
        filter: Union[Optional[MedicalDrugClassFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalDrugClasses:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_DRUG_CLASSES_GQL,
            operation_name="QueryMedicalDrugClasses",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalDrugClasses.model_validate(data)

    async def update_medical_drug_class(
        self, medical_drug_class: MedicalDrugClassUpdateInput, **kwargs: Any
    ) -> UpdateMedicalDrugClass:
        variables: Dict[str, object] = {"medicalDrugClass": medical_drug_class}
        response = await self.execute(
            query=UPDATE_MEDICAL_DRUG_CLASS_GQL,
            operation_name="UpdateMedicalDrugClass",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalDrugClass.model_validate(data)

    async def count_medical_guidelines(
        self,
        filter: Union[Optional[MedicalGuidelineFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalGuidelines:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_MEDICAL_GUIDELINES_GQL,
            operation_name="CountMedicalGuidelines",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalGuidelines.model_validate(data)

    async def create_medical_guideline(
        self, medical_guideline: MedicalGuidelineInput, **kwargs: Any
    ) -> CreateMedicalGuideline:
        variables: Dict[str, object] = {"medicalGuideline": medical_guideline}
        response = await self.execute(
            query=CREATE_MEDICAL_GUIDELINE_GQL,
            operation_name="CreateMedicalGuideline",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalGuideline.model_validate(data)

    async def delete_all_medical_guidelines(
        self,
        filter: Union[Optional[MedicalGuidelineFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalGuidelines:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_GUIDELINES_GQL,
            operation_name="DeleteAllMedicalGuidelines",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalGuidelines.model_validate(data)

    async def delete_medical_guideline(
        self, id: str, **kwargs: Any
    ) -> DeleteMedicalGuideline:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_GUIDELINE_GQL,
            operation_name="DeleteMedicalGuideline",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalGuideline.model_validate(data)

    async def delete_medical_guidelines(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalGuidelines:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_GUIDELINES_GQL,
            operation_name="DeleteMedicalGuidelines",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalGuidelines.model_validate(data)

    async def get_medical_guideline(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalGuideline:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_GUIDELINE_GQL,
            operation_name="GetMedicalGuideline",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalGuideline.model_validate(data)

    async def query_medical_guidelines(
        self,
        filter: Union[Optional[MedicalGuidelineFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalGuidelines:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_GUIDELINES_GQL,
            operation_name="QueryMedicalGuidelines",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalGuidelines.model_validate(data)

    async def update_medical_guideline(
        self, medical_guideline: MedicalGuidelineUpdateInput, **kwargs: Any
    ) -> UpdateMedicalGuideline:
        variables: Dict[str, object] = {"medicalGuideline": medical_guideline}
        response = await self.execute(
            query=UPDATE_MEDICAL_GUIDELINE_GQL,
            operation_name="UpdateMedicalGuideline",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalGuideline.model_validate(data)

    async def count_medical_indications(
        self,
        filter: Union[Optional[MedicalIndicationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalIndications:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_MEDICAL_INDICATIONS_GQL,
            operation_name="CountMedicalIndications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalIndications.model_validate(data)

    async def create_medical_indication(
        self, medical_indication: MedicalIndicationInput, **kwargs: Any
    ) -> CreateMedicalIndication:
        variables: Dict[str, object] = {"medicalIndication": medical_indication}
        response = await self.execute(
            query=CREATE_MEDICAL_INDICATION_GQL,
            operation_name="CreateMedicalIndication",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalIndication.model_validate(data)

    async def delete_all_medical_indications(
        self,
        filter: Union[Optional[MedicalIndicationFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalIndications:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_INDICATIONS_GQL,
            operation_name="DeleteAllMedicalIndications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalIndications.model_validate(data)

    async def delete_medical_indication(
        self, id: str, **kwargs: Any
    ) -> DeleteMedicalIndication:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_INDICATION_GQL,
            operation_name="DeleteMedicalIndication",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalIndication.model_validate(data)

    async def delete_medical_indications(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalIndications:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_INDICATIONS_GQL,
            operation_name="DeleteMedicalIndications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalIndications.model_validate(data)

    async def get_medical_indication(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalIndication:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_INDICATION_GQL,
            operation_name="GetMedicalIndication",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalIndication.model_validate(data)

    async def query_medical_indications(
        self,
        filter: Union[Optional[MedicalIndicationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalIndications:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_INDICATIONS_GQL,
            operation_name="QueryMedicalIndications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalIndications.model_validate(data)

    async def update_medical_indication(
        self, medical_indication: MedicalIndicationUpdateInput, **kwargs: Any
    ) -> UpdateMedicalIndication:
        variables: Dict[str, object] = {"medicalIndication": medical_indication}
        response = await self.execute(
            query=UPDATE_MEDICAL_INDICATION_GQL,
            operation_name="UpdateMedicalIndication",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalIndication.model_validate(data)

    async def count_medical_procedures(
        self,
        filter: Union[Optional[MedicalProcedureFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalProcedures:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_MEDICAL_PROCEDURES_GQL,
            operation_name="CountMedicalProcedures",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalProcedures.model_validate(data)

    async def create_medical_procedure(
        self, medical_procedure: MedicalProcedureInput, **kwargs: Any
    ) -> CreateMedicalProcedure:
        variables: Dict[str, object] = {"medicalProcedure": medical_procedure}
        response = await self.execute(
            query=CREATE_MEDICAL_PROCEDURE_GQL,
            operation_name="CreateMedicalProcedure",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalProcedure.model_validate(data)

    async def delete_all_medical_procedures(
        self,
        filter: Union[Optional[MedicalProcedureFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalProcedures:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_PROCEDURES_GQL,
            operation_name="DeleteAllMedicalProcedures",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalProcedures.model_validate(data)

    async def delete_medical_procedure(
        self, id: str, **kwargs: Any
    ) -> DeleteMedicalProcedure:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_PROCEDURE_GQL,
            operation_name="DeleteMedicalProcedure",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalProcedure.model_validate(data)

    async def delete_medical_procedures(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalProcedures:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_PROCEDURES_GQL,
            operation_name="DeleteMedicalProcedures",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalProcedures.model_validate(data)

    async def get_medical_procedure(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalProcedure:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_PROCEDURE_GQL,
            operation_name="GetMedicalProcedure",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalProcedure.model_validate(data)

    async def query_medical_procedures(
        self,
        filter: Union[Optional[MedicalProcedureFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalProcedures:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_PROCEDURES_GQL,
            operation_name="QueryMedicalProcedures",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalProcedures.model_validate(data)

    async def update_medical_procedure(
        self, medical_procedure: MedicalProcedureUpdateInput, **kwargs: Any
    ) -> UpdateMedicalProcedure:
        variables: Dict[str, object] = {"medicalProcedure": medical_procedure}
        response = await self.execute(
            query=UPDATE_MEDICAL_PROCEDURE_GQL,
            operation_name="UpdateMedicalProcedure",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalProcedure.model_validate(data)

    async def count_medical_studies(
        self,
        filter: Union[Optional[MedicalStudyFilter], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalStudies:
        variables: Dict[str, object] = {"filter": filter}
        response = await self.execute(
            query=COUNT_MEDICAL_STUDIES_GQL,
            operation_name="CountMedicalStudies",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalStudies.model_validate(data)

    async def create_medical_study(
        self, medical_study: MedicalStudyInput, **kwargs: Any
    ) -> CreateMedicalStudy:
        variables: Dict[str, object] = {"medicalStudy": medical_study}
        response = await self.execute(
            query=CREATE_MEDICAL_STUDY_GQL,
            operation_name="CreateMedicalStudy",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalStudy.model_validate(data)

    async def delete_all_medical_studies(
        self,
        filter: Union[Optional[MedicalStudyFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalStudies:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_STUDIES_GQL,
            operation_name="DeleteAllMedicalStudies",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalStudies.model_validate(data)

    async def delete_medical_studies(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalStudies:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_STUDIES_GQL,
            operation_name="DeleteMedicalStudies",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalStudies.model_validate(data)

    async def delete_medical_study(self, id: str, **kwargs: Any) -> DeleteMedicalStudy:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_STUDY_GQL,
            operation_name="DeleteMedicalStudy",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalStudy.model_validate(data)

    async def get_medical_study(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalStudy:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_STUDY_GQL,
            operation_name="GetMedicalStudy",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalStudy.model_validate(data)

    async def query_medical_studies(
        self,
        filter: Union[Optional[MedicalStudyFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalStudies:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_STUDIES_GQL,
            operation_name="QueryMedicalStudies",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalStudies.model_validate(data)

    async def update_medical_study(
        self, medical_study: MedicalStudyUpdateInput, **kwargs: Any
    ) -> UpdateMedicalStudy:
        variables: Dict[str, object] = {"medicalStudy": medical_study}
        response = await self.execute(
            query=UPDATE_MEDICAL_STUDY_GQL,
            operation_name="UpdateMedicalStudy",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalStudy.model_validate(data)

    async def count_medical_tests(
        self,
        filter: Union[Optional[MedicalTestFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalTests:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_MEDICAL_TESTS_GQL,
            operation_name="CountMedicalTests",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalTests.model_validate(data)

    async def create_medical_test(
        self, medical_test: MedicalTestInput, **kwargs: Any
    ) -> CreateMedicalTest:
        variables: Dict[str, object] = {"medicalTest": medical_test}
        response = await self.execute(
            query=CREATE_MEDICAL_TEST_GQL,
            operation_name="CreateMedicalTest",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalTest.model_validate(data)

    async def delete_all_medical_tests(
        self,
        filter: Union[Optional[MedicalTestFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalTests:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_TESTS_GQL,
            operation_name="DeleteAllMedicalTests",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalTests.model_validate(data)

    async def delete_medical_test(self, id: str, **kwargs: Any) -> DeleteMedicalTest:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_TEST_GQL,
            operation_name="DeleteMedicalTest",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalTest.model_validate(data)

    async def delete_medical_tests(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalTests:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_TESTS_GQL,
            operation_name="DeleteMedicalTests",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalTests.model_validate(data)

    async def get_medical_test(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalTest:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_TEST_GQL,
            operation_name="GetMedicalTest",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalTest.model_validate(data)

    async def query_medical_tests(
        self,
        filter: Union[Optional[MedicalTestFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalTests:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_TESTS_GQL,
            operation_name="QueryMedicalTests",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalTests.model_validate(data)

    async def update_medical_test(
        self, medical_test: MedicalTestUpdateInput, **kwargs: Any
    ) -> UpdateMedicalTest:
        variables: Dict[str, object] = {"medicalTest": medical_test}
        response = await self.execute(
            query=UPDATE_MEDICAL_TEST_GQL,
            operation_name="UpdateMedicalTest",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalTest.model_validate(data)

    async def count_medical_therapies(
        self,
        filter: Union[Optional[MedicalTherapyFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountMedicalTherapies:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_MEDICAL_THERAPIES_GQL,
            operation_name="CountMedicalTherapies",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountMedicalTherapies.model_validate(data)

    async def create_medical_therapy(
        self, medical_therapy: MedicalTherapyInput, **kwargs: Any
    ) -> CreateMedicalTherapy:
        variables: Dict[str, object] = {"medicalTherapy": medical_therapy}
        response = await self.execute(
            query=CREATE_MEDICAL_THERAPY_GQL,
            operation_name="CreateMedicalTherapy",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMedicalTherapy.model_validate(data)

    async def delete_all_medical_therapies(
        self,
        filter: Union[Optional[MedicalTherapyFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllMedicalTherapies:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_MEDICAL_THERAPIES_GQL,
            operation_name="DeleteAllMedicalTherapies",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllMedicalTherapies.model_validate(data)

    async def delete_medical_therapies(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteMedicalTherapies:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_MEDICAL_THERAPIES_GQL,
            operation_name="DeleteMedicalTherapies",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalTherapies.model_validate(data)

    async def delete_medical_therapy(
        self, id: str, **kwargs: Any
    ) -> DeleteMedicalTherapy:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_MEDICAL_THERAPY_GQL,
            operation_name="DeleteMedicalTherapy",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteMedicalTherapy.model_validate(data)

    async def get_medical_therapy(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetMedicalTherapy:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_MEDICAL_THERAPY_GQL,
            operation_name="GetMedicalTherapy",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetMedicalTherapy.model_validate(data)

    async def query_medical_therapies(
        self,
        filter: Union[Optional[MedicalTherapyFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryMedicalTherapies:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_MEDICAL_THERAPIES_GQL,
            operation_name="QueryMedicalTherapies",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryMedicalTherapies.model_validate(data)

    async def update_medical_therapy(
        self, medical_therapy: MedicalTherapyUpdateInput, **kwargs: Any
    ) -> UpdateMedicalTherapy:
        variables: Dict[str, object] = {"medicalTherapy": medical_therapy}
        response = await self.execute(
            query=UPDATE_MEDICAL_THERAPY_GQL,
            operation_name="UpdateMedicalTherapy",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateMedicalTherapy.model_validate(data)

    async def send_notification(
        self,
        connector: IntegrationConnectorInput,
        text: str,
        text_type: Union[Optional[TextTypes], UnsetType] = UNSET,
        **kwargs: Any
    ) -> SendNotification:
        variables: Dict[str, object] = {
            "connector": connector,
            "text": text,
            "textType": text_type,
        }
        response = await self.execute(
            query=SEND_NOTIFICATION_GQL,
            operation_name="SendNotification",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return SendNotification.model_validate(data)

    async def create_observation(
        self, observation: ObservationInput, **kwargs: Any
    ) -> CreateObservation:
        variables: Dict[str, object] = {"observation": observation}
        response = await self.execute(
            query=CREATE_OBSERVATION_GQL,
            operation_name="CreateObservation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateObservation.model_validate(data)

    async def delete_observation(self, id: str, **kwargs: Any) -> DeleteObservation:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_OBSERVATION_GQL,
            operation_name="DeleteObservation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteObservation.model_validate(data)

    async def update_observation(
        self, observation: ObservationUpdateInput, **kwargs: Any
    ) -> UpdateObservation:
        variables: Dict[str, object] = {"observation": observation}
        response = await self.execute(
            query=UPDATE_OBSERVATION_GQL,
            operation_name="UpdateObservation",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateObservation.model_validate(data)

    async def count_organizations(
        self,
        filter: Union[Optional[OrganizationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountOrganizations:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_ORGANIZATIONS_GQL,
            operation_name="CountOrganizations",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountOrganizations.model_validate(data)

    async def create_organization(
        self, organization: OrganizationInput, **kwargs: Any
    ) -> CreateOrganization:
        variables: Dict[str, object] = {"organization": organization}
        response = await self.execute(
            query=CREATE_ORGANIZATION_GQL,
            operation_name="CreateOrganization",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateOrganization.model_validate(data)

    async def delete_all_organizations(
        self,
        filter: Union[Optional[OrganizationFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllOrganizations:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_ORGANIZATIONS_GQL,
            operation_name="DeleteAllOrganizations",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllOrganizations.model_validate(data)

    async def delete_organization(self, id: str, **kwargs: Any) -> DeleteOrganization:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_ORGANIZATION_GQL,
            operation_name="DeleteOrganization",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteOrganization.model_validate(data)

    async def delete_organizations(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteOrganizations:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_ORGANIZATIONS_GQL,
            operation_name="DeleteOrganizations",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteOrganizations.model_validate(data)

    async def get_organization(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetOrganization:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_ORGANIZATION_GQL,
            operation_name="GetOrganization",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetOrganization.model_validate(data)

    async def query_organizations(
        self,
        filter: Union[Optional[OrganizationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryOrganizations:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_ORGANIZATIONS_GQL,
            operation_name="QueryOrganizations",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryOrganizations.model_validate(data)

    async def update_organization(
        self, organization: OrganizationUpdateInput, **kwargs: Any
    ) -> UpdateOrganization:
        variables: Dict[str, object] = {"organization": organization}
        response = await self.execute(
            query=UPDATE_ORGANIZATION_GQL,
            operation_name="UpdateOrganization",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateOrganization.model_validate(data)

    async def count_persons(
        self,
        filter: Union[Optional[PersonFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountPersons:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_PERSONS_GQL,
            operation_name="CountPersons",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountPersons.model_validate(data)

    async def create_person(self, person: PersonInput, **kwargs: Any) -> CreatePerson:
        variables: Dict[str, object] = {"person": person}
        response = await self.execute(
            query=CREATE_PERSON_GQL,
            operation_name="CreatePerson",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreatePerson.model_validate(data)

    async def delete_all_persons(
        self,
        filter: Union[Optional[PersonFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllPersons:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_PERSONS_GQL,
            operation_name="DeleteAllPersons",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllPersons.model_validate(data)

    async def delete_person(self, id: str, **kwargs: Any) -> DeletePerson:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_PERSON_GQL,
            operation_name="DeletePerson",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeletePerson.model_validate(data)

    async def delete_persons(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeletePersons:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_PERSONS_GQL,
            operation_name="DeletePersons",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeletePersons.model_validate(data)

    async def get_person(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetPerson:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_PERSON_GQL,
            operation_name="GetPerson",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetPerson.model_validate(data)

    async def query_persons(
        self,
        filter: Union[Optional[PersonFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryPersons:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_PERSONS_GQL,
            operation_name="QueryPersons",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryPersons.model_validate(data)

    async def update_person(
        self, person: PersonUpdateInput, **kwargs: Any
    ) -> UpdatePerson:
        variables: Dict[str, object] = {"person": person}
        response = await self.execute(
            query=UPDATE_PERSON_GQL,
            operation_name="UpdatePerson",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdatePerson.model_validate(data)

    async def count_places(
        self,
        filter: Union[Optional[PlaceFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountPlaces:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_PLACES_GQL,
            operation_name="CountPlaces",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountPlaces.model_validate(data)

    async def create_place(self, place: PlaceInput, **kwargs: Any) -> CreatePlace:
        variables: Dict[str, object] = {"place": place}
        response = await self.execute(
            query=CREATE_PLACE_GQL,
            operation_name="CreatePlace",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreatePlace.model_validate(data)

    async def delete_all_places(
        self,
        filter: Union[Optional[PlaceFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllPlaces:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_PLACES_GQL,
            operation_name="DeleteAllPlaces",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllPlaces.model_validate(data)

    async def delete_place(self, id: str, **kwargs: Any) -> DeletePlace:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_PLACE_GQL,
            operation_name="DeletePlace",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeletePlace.model_validate(data)

    async def delete_places(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeletePlaces:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_PLACES_GQL,
            operation_name="DeletePlaces",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeletePlaces.model_validate(data)

    async def get_place(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetPlace:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_PLACE_GQL,
            operation_name="GetPlace",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetPlace.model_validate(data)

    async def query_places(
        self,
        filter: Union[Optional[PlaceFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryPlaces:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_PLACES_GQL,
            operation_name="QueryPlaces",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryPlaces.model_validate(data)

    async def update_place(self, place: PlaceUpdateInput, **kwargs: Any) -> UpdatePlace:
        variables: Dict[str, object] = {"place": place}
        response = await self.execute(
            query=UPDATE_PLACE_GQL,
            operation_name="UpdatePlace",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdatePlace.model_validate(data)

    async def count_products(
        self,
        filter: Union[Optional[ProductFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountProducts:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_PRODUCTS_GQL,
            operation_name="CountProducts",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountProducts.model_validate(data)

    async def create_product(
        self, product: ProductInput, **kwargs: Any
    ) -> CreateProduct:
        variables: Dict[str, object] = {"product": product}
        response = await self.execute(
            query=CREATE_PRODUCT_GQL,
            operation_name="CreateProduct",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateProduct.model_validate(data)

    async def delete_all_products(
        self,
        filter: Union[Optional[ProductFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllProducts:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_PRODUCTS_GQL,
            operation_name="DeleteAllProducts",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllProducts.model_validate(data)

    async def delete_product(self, id: str, **kwargs: Any) -> DeleteProduct:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_PRODUCT_GQL,
            operation_name="DeleteProduct",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteProduct.model_validate(data)

    async def delete_products(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteProducts:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_PRODUCTS_GQL,
            operation_name="DeleteProducts",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteProducts.model_validate(data)

    async def get_product(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetProduct:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_PRODUCT_GQL,
            operation_name="GetProduct",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetProduct.model_validate(data)

    async def query_products(
        self,
        filter: Union[Optional[ProductFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryProducts:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_PRODUCTS_GQL,
            operation_name="QueryProducts",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryProducts.model_validate(data)

    async def update_product(
        self, product: ProductUpdateInput, **kwargs: Any
    ) -> UpdateProduct:
        variables: Dict[str, object] = {"product": product}
        response = await self.execute(
            query=UPDATE_PRODUCT_GQL,
            operation_name="UpdateProduct",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateProduct.model_validate(data)

    async def get_project(self, **kwargs: Any) -> GetProject:
        variables: Dict[str, object] = {}
        response = await self.execute(
            query=GET_PROJECT_GQL,
            operation_name="GetProject",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetProject.model_validate(data)

    async def lookup_credits(self, correlation_id: str, **kwargs: Any) -> LookupCredits:
        variables: Dict[str, object] = {"correlationId": correlation_id}
        response = await self.execute(
            query=LOOKUP_CREDITS_GQL,
            operation_name="LookupCredits",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return LookupCredits.model_validate(data)

    async def lookup_usage(self, correlation_id: str, **kwargs: Any) -> LookupUsage:
        variables: Dict[str, object] = {"correlationId": correlation_id}
        response = await self.execute(
            query=LOOKUP_USAGE_GQL,
            operation_name="LookupUsage",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return LookupUsage.model_validate(data)

    async def query_credits(
        self, start_date: Any, duration: Any, **kwargs: Any
    ) -> QueryCredits:
        variables: Dict[str, object] = {"startDate": start_date, "duration": duration}
        response = await self.execute(
            query=QUERY_CREDITS_GQL,
            operation_name="QueryCredits",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryCredits.model_validate(data)

    async def query_tokens(
        self, start_date: Any, duration: Any, **kwargs: Any
    ) -> QueryTokens:
        variables: Dict[str, object] = {"startDate": start_date, "duration": duration}
        response = await self.execute(
            query=QUERY_TOKENS_GQL,
            operation_name="QueryTokens",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryTokens.model_validate(data)

    async def query_usage(
        self,
        start_date: Any,
        duration: Any,
        names: Union[Optional[List[str]], UnsetType] = UNSET,
        excluded_names: Union[Optional[List[str]], UnsetType] = UNSET,
        offset: Union[Optional[int], UnsetType] = UNSET,
        limit: Union[Optional[int], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryUsage:
        variables: Dict[str, object] = {
            "startDate": start_date,
            "duration": duration,
            "names": names,
            "excludedNames": excluded_names,
            "offset": offset,
            "limit": limit,
        }
        response = await self.execute(
            query=QUERY_USAGE_GQL,
            operation_name="QueryUsage",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryUsage.model_validate(data)

    async def update_project(
        self, project: ProjectUpdateInput, **kwargs: Any
    ) -> UpdateProject:
        variables: Dict[str, object] = {"project": project}
        response = await self.execute(
            query=UPDATE_PROJECT_GQL,
            operation_name="UpdateProject",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateProject.model_validate(data)

    async def count_repos(
        self,
        filter: Union[Optional[RepoFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountRepos:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_REPOS_GQL,
            operation_name="CountRepos",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountRepos.model_validate(data)

    async def create_repo(self, repo: RepoInput, **kwargs: Any) -> CreateRepo:
        variables: Dict[str, object] = {"repo": repo}
        response = await self.execute(
            query=CREATE_REPO_GQL,
            operation_name="CreateRepo",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateRepo.model_validate(data)

    async def delete_all_repos(
        self,
        filter: Union[Optional[RepoFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllRepos:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_REPOS_GQL,
            operation_name="DeleteAllRepos",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllRepos.model_validate(data)

    async def delete_repo(self, id: str, **kwargs: Any) -> DeleteRepo:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_REPO_GQL,
            operation_name="DeleteRepo",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteRepo.model_validate(data)

    async def delete_repos(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteRepos:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_REPOS_GQL,
            operation_name="DeleteRepos",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteRepos.model_validate(data)

    async def get_repo(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetRepo:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_REPO_GQL, operation_name="GetRepo", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetRepo.model_validate(data)

    async def query_repos(
        self,
        filter: Union[Optional[RepoFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryRepos:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_REPOS_GQL,
            operation_name="QueryRepos",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryRepos.model_validate(data)

    async def update_repo(self, repo: RepoUpdateInput, **kwargs: Any) -> UpdateRepo:
        variables: Dict[str, object] = {"repo": repo}
        response = await self.execute(
            query=UPDATE_REPO_GQL,
            operation_name="UpdateRepo",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateRepo.model_validate(data)

    async def map_web(
        self,
        uri: Any,
        allowed_paths: Union[Optional[List[str]], UnsetType] = UNSET,
        excluded_paths: Union[Optional[List[str]], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> MapWeb:
        variables: Dict[str, object] = {
            "uri": uri,
            "allowedPaths": allowed_paths,
            "excludedPaths": excluded_paths,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=MAP_WEB_GQL, operation_name="MapWeb", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return MapWeb.model_validate(data)

    async def search_web(
        self,
        text: str,
        service: Union[Optional[SearchServiceTypes], UnsetType] = UNSET,
        limit: Union[Optional[int], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> SearchWeb:
        variables: Dict[str, object] = {
            "text": text,
            "service": service,
            "limit": limit,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=SEARCH_WEB_GQL,
            operation_name="SearchWeb",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return SearchWeb.model_validate(data)

    async def count_softwares(
        self,
        filter: Union[Optional[SoftwareFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountSoftwares:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_SOFTWARES_GQL,
            operation_name="CountSoftwares",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountSoftwares.model_validate(data)

    async def create_software(
        self, software: SoftwareInput, **kwargs: Any
    ) -> CreateSoftware:
        variables: Dict[str, object] = {"software": software}
        response = await self.execute(
            query=CREATE_SOFTWARE_GQL,
            operation_name="CreateSoftware",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateSoftware.model_validate(data)

    async def delete_all_softwares(
        self,
        filter: Union[Optional[SoftwareFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllSoftwares:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_SOFTWARES_GQL,
            operation_name="DeleteAllSoftwares",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllSoftwares.model_validate(data)

    async def delete_software(self, id: str, **kwargs: Any) -> DeleteSoftware:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_SOFTWARE_GQL,
            operation_name="DeleteSoftware",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteSoftware.model_validate(data)

    async def delete_softwares(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteSoftwares:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_SOFTWARES_GQL,
            operation_name="DeleteSoftwares",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteSoftwares.model_validate(data)

    async def get_software(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetSoftware:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_SOFTWARE_GQL,
            operation_name="GetSoftware",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetSoftware.model_validate(data)

    async def query_softwares(
        self,
        filter: Union[Optional[SoftwareFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QuerySoftwares:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_SOFTWARES_GQL,
            operation_name="QuerySoftwares",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QuerySoftwares.model_validate(data)

    async def update_software(
        self, software: SoftwareUpdateInput, **kwargs: Any
    ) -> UpdateSoftware:
        variables: Dict[str, object] = {"software": software}
        response = await self.execute(
            query=UPDATE_SOFTWARE_GQL,
            operation_name="UpdateSoftware",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateSoftware.model_validate(data)

    async def count_specifications(
        self,
        filter: Union[Optional[SpecificationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountSpecifications:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_SPECIFICATIONS_GQL,
            operation_name="CountSpecifications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountSpecifications.model_validate(data)

    async def create_specification(
        self, specification: SpecificationInput, **kwargs: Any
    ) -> CreateSpecification:
        variables: Dict[str, object] = {"specification": specification}
        response = await self.execute(
            query=CREATE_SPECIFICATION_GQL,
            operation_name="CreateSpecification",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateSpecification.model_validate(data)

    async def delete_all_specifications(
        self,
        filter: Union[Optional[SpecificationFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllSpecifications:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_SPECIFICATIONS_GQL,
            operation_name="DeleteAllSpecifications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllSpecifications.model_validate(data)

    async def delete_specification(self, id: str, **kwargs: Any) -> DeleteSpecification:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_SPECIFICATION_GQL,
            operation_name="DeleteSpecification",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteSpecification.model_validate(data)

    async def delete_specifications(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteSpecifications:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_SPECIFICATIONS_GQL,
            operation_name="DeleteSpecifications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteSpecifications.model_validate(data)

    async def get_specification(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetSpecification:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_SPECIFICATION_GQL,
            operation_name="GetSpecification",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetSpecification.model_validate(data)

    async def prompt_specifications(
        self, prompt: str, ids: List[str], **kwargs: Any
    ) -> PromptSpecifications:
        variables: Dict[str, object] = {"prompt": prompt, "ids": ids}
        response = await self.execute(
            query=PROMPT_SPECIFICATIONS_GQL,
            operation_name="PromptSpecifications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return PromptSpecifications.model_validate(data)

    async def query_models(
        self, filter: Union[Optional[ModelFilter], UnsetType] = UNSET, **kwargs: Any
    ) -> QueryModels:
        variables: Dict[str, object] = {"filter": filter}
        response = await self.execute(
            query=QUERY_MODELS_GQL,
            operation_name="QueryModels",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryModels.model_validate(data)

    async def query_specifications(
        self,
        filter: Union[Optional[SpecificationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QuerySpecifications:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_SPECIFICATIONS_GQL,
            operation_name="QuerySpecifications",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QuerySpecifications.model_validate(data)

    async def specification_exists(
        self,
        filter: Union[Optional[SpecificationFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> SpecificationExists:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=SPECIFICATION_EXISTS_GQL,
            operation_name="SpecificationExists",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return SpecificationExists.model_validate(data)

    async def update_specification(
        self, specification: SpecificationUpdateInput, **kwargs: Any
    ) -> UpdateSpecification:
        variables: Dict[str, object] = {"specification": specification}
        response = await self.execute(
            query=UPDATE_SPECIFICATION_GQL,
            operation_name="UpdateSpecification",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateSpecification.model_validate(data)

    async def upsert_specification(
        self, specification: SpecificationInput, **kwargs: Any
    ) -> UpsertSpecification:
        variables: Dict[str, object] = {"specification": specification}
        response = await self.execute(
            query=UPSERT_SPECIFICATION_GQL,
            operation_name="UpsertSpecification",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpsertSpecification.model_validate(data)

    async def count_users(
        self,
        filter: Union[Optional[UserFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountUsers:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_USERS_GQL,
            operation_name="CountUsers",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountUsers.model_validate(data)

    async def create_user(self, user: UserInput, **kwargs: Any) -> CreateUser:
        variables: Dict[str, object] = {"user": user}
        response = await self.execute(
            query=CREATE_USER_GQL,
            operation_name="CreateUser",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateUser.model_validate(data)

    async def delete_user(self, id: str, **kwargs: Any) -> DeleteUser:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_USER_GQL,
            operation_name="DeleteUser",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteUser.model_validate(data)

    async def disable_user(self, id: str, **kwargs: Any) -> DisableUser:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DISABLE_USER_GQL,
            operation_name="DisableUser",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DisableUser.model_validate(data)

    async def enable_user(self, id: str, **kwargs: Any) -> EnableUser:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=ENABLE_USER_GQL,
            operation_name="EnableUser",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return EnableUser.model_validate(data)

    async def get_user(self, **kwargs: Any) -> GetUser:
        variables: Dict[str, object] = {}
        response = await self.execute(
            query=GET_USER_GQL, operation_name="GetUser", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetUser.model_validate(data)

    async def query_users(
        self,
        filter: Union[Optional[UserFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryUsers:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_USERS_GQL,
            operation_name="QueryUsers",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryUsers.model_validate(data)

    async def update_user(self, user: UserUpdateInput, **kwargs: Any) -> UpdateUser:
        variables: Dict[str, object] = {"user": user}
        response = await self.execute(
            query=UPDATE_USER_GQL,
            operation_name="UpdateUser",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateUser.model_validate(data)

    async def count_workflows(
        self,
        filter: Union[Optional[WorkflowFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CountWorkflows:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=COUNT_WORKFLOWS_GQL,
            operation_name="CountWorkflows",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CountWorkflows.model_validate(data)

    async def create_workflow(
        self, workflow: WorkflowInput, **kwargs: Any
    ) -> CreateWorkflow:
        variables: Dict[str, object] = {"workflow": workflow}
        response = await self.execute(
            query=CREATE_WORKFLOW_GQL,
            operation_name="CreateWorkflow",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateWorkflow.model_validate(data)

    async def delete_all_workflows(
        self,
        filter: Union[Optional[WorkflowFilter], UnsetType] = UNSET,
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteAllWorkflows:
        variables: Dict[str, object] = {
            "filter": filter,
            "isSynchronous": is_synchronous,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=DELETE_ALL_WORKFLOWS_GQL,
            operation_name="DeleteAllWorkflows",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteAllWorkflows.model_validate(data)

    async def delete_workflow(self, id: str, **kwargs: Any) -> DeleteWorkflow:
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=DELETE_WORKFLOW_GQL,
            operation_name="DeleteWorkflow",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteWorkflow.model_validate(data)

    async def delete_workflows(
        self,
        ids: List[str],
        is_synchronous: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DeleteWorkflows:
        variables: Dict[str, object] = {"ids": ids, "isSynchronous": is_synchronous}
        response = await self.execute(
            query=DELETE_WORKFLOWS_GQL,
            operation_name="DeleteWorkflows",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteWorkflows.model_validate(data)

    async def get_workflow(
        self,
        id: str,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetWorkflow:
        variables: Dict[str, object] = {"id": id, "correlationId": correlation_id}
        response = await self.execute(
            query=GET_WORKFLOW_GQL,
            operation_name="GetWorkflow",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetWorkflow.model_validate(data)

    async def query_workflows(
        self,
        filter: Union[Optional[WorkflowFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> QueryWorkflows:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=QUERY_WORKFLOWS_GQL,
            operation_name="QueryWorkflows",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return QueryWorkflows.model_validate(data)

    async def update_workflow(
        self, workflow: WorkflowUpdateInput, **kwargs: Any
    ) -> UpdateWorkflow:
        variables: Dict[str, object] = {"workflow": workflow}
        response = await self.execute(
            query=UPDATE_WORKFLOW_GQL,
            operation_name="UpdateWorkflow",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateWorkflow.model_validate(data)

    async def upsert_workflow(
        self, workflow: WorkflowInput, **kwargs: Any
    ) -> UpsertWorkflow:
        variables: Dict[str, object] = {"workflow": workflow}
        response = await self.execute(
            query=UPSERT_WORKFLOW_GQL,
            operation_name="UpsertWorkflow",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpsertWorkflow.model_validate(data)

    async def workflow_exists(
        self,
        filter: Union[Optional[WorkflowFilter], UnsetType] = UNSET,
        correlation_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> WorkflowExists:
        variables: Dict[str, object] = {
            "filter": filter,
            "correlationId": correlation_id,
        }
        response = await self.execute(
            query=WORKFLOW_EXISTS_GQL,
            operation_name="WorkflowExists",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return WorkflowExists.model_validate(data)



================================================
FILE: graphlit_api/close_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import ConversationTypes, EntityState


class CloseConversation(BaseModel):
    close_conversation: Optional["CloseConversationCloseConversation"] = Field(
        alias="closeConversation"
    )


class CloseConversationCloseConversation(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ConversationTypes]


CloseConversation.model_rebuild()



================================================
FILE: graphlit_api/complete_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentFacetTypes,
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    EntityTypes,
    FacetValueTypes,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    ObservableTypes,
    OrientationTypes,
)


class CompleteConversation(BaseModel):
    complete_conversation: Optional["CompleteConversationCompleteConversation"] = Field(
        alias="completeConversation"
    )


class CompleteConversationCompleteConversation(BaseModel):
    conversation: Optional["CompleteConversationCompleteConversationConversation"]
    message: Optional["CompleteConversationCompleteConversationMessage"]
    message_count: Optional[int] = Field(alias="messageCount")
    facets: Optional[List[Optional["CompleteConversationCompleteConversationFacets"]]]
    graph: Optional["CompleteConversationCompleteConversationGraph"]
    details: Optional["CompleteConversationCompleteConversationDetails"]


class CompleteConversationCompleteConversationConversation(BaseModel):
    id: str


class CompleteConversationCompleteConversationMessage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[Optional["CompleteConversationCompleteConversationMessageCitations"]]
    ]
    tool_calls: Optional[
        List[Optional["CompleteConversationCompleteConversationMessageToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class CompleteConversationCompleteConversationMessageCitations(BaseModel):
    content: Optional["CompleteConversationCompleteConversationMessageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class CompleteConversationCompleteConversationMessageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional[
        "CompleteConversationCompleteConversationMessageCitationsContentVideo"
    ]
    audio: Optional[
        "CompleteConversationCompleteConversationMessageCitationsContentAudio"
    ]
    image: Optional[
        "CompleteConversationCompleteConversationMessageCitationsContentImage"
    ]
    document: Optional[
        "CompleteConversationCompleteConversationMessageCitationsContentDocument"
    ]


class CompleteConversationCompleteConversationMessageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class CompleteConversationCompleteConversationMessageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class CompleteConversationCompleteConversationMessageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class CompleteConversationCompleteConversationMessageCitationsContentDocument(
    BaseModel
):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class CompleteConversationCompleteConversationMessageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


class CompleteConversationCompleteConversationFacets(BaseModel):
    type: Optional[FacetValueTypes]
    value: Optional[str]
    range: Optional["CompleteConversationCompleteConversationFacetsRange"]
    count: Optional[Any]
    facet: Optional[ContentFacetTypes]
    observable: Optional["CompleteConversationCompleteConversationFacetsObservable"]


class CompleteConversationCompleteConversationFacetsRange(BaseModel):
    from_: Optional[str] = Field(alias="from")
    to: Optional[str]


class CompleteConversationCompleteConversationFacetsObservable(BaseModel):
    type: Optional[ObservableTypes]
    observable: Optional[
        "CompleteConversationCompleteConversationFacetsObservableObservable"
    ]


class CompleteConversationCompleteConversationFacetsObservableObservable(BaseModel):
    id: str
    name: Optional[str]


class CompleteConversationCompleteConversationGraph(BaseModel):
    nodes: Optional[
        List[Optional["CompleteConversationCompleteConversationGraphNodes"]]
    ]
    edges: Optional[
        List[Optional["CompleteConversationCompleteConversationGraphEdges"]]
    ]


class CompleteConversationCompleteConversationGraphNodes(BaseModel):
    id: str
    name: str
    type: EntityTypes
    metadata: Optional[str]


class CompleteConversationCompleteConversationGraphEdges(BaseModel):
    from_: str = Field(alias="from")
    to: str
    relation: Optional[str]


class CompleteConversationCompleteConversationDetails(BaseModel):
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    supports_tool_calling: Optional[bool] = Field(alias="supportsToolCalling")
    source_count: Optional[int] = Field(alias="sourceCount")
    observable_count: Optional[int] = Field(alias="observableCount")
    tool_count: Optional[int] = Field(alias="toolCount")
    rendered_source_count: Optional[int] = Field(alias="renderedSourceCount")
    rendered_observable_count: Optional[int] = Field(alias="renderedObservableCount")
    rendered_tool_count: Optional[int] = Field(alias="renderedToolCount")
    ranked_source_count: Optional[int] = Field(alias="rankedSourceCount")
    ranked_observable_count: Optional[int] = Field(alias="rankedObservableCount")
    ranked_tool_count: Optional[int] = Field(alias="rankedToolCount")
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    sources: Optional[str]
    formatted_sources: Optional[str] = Field(alias="formattedSources")
    formatted_observables: Optional[str] = Field(alias="formattedObservables")
    formatted_instructions: Optional[str] = Field(alias="formattedInstructions")
    formatted_tools: Optional[str] = Field(alias="formattedTools")
    specification: Optional[str]
    messages: Optional[
        List[Optional["CompleteConversationCompleteConversationDetailsMessages"]]
    ]


class CompleteConversationCompleteConversationDetailsMessages(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[
            Optional["CompleteConversationCompleteConversationDetailsMessagesCitations"]
        ]
    ]
    tool_calls: Optional[
        List[
            Optional["CompleteConversationCompleteConversationDetailsMessagesToolCalls"]
        ]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class CompleteConversationCompleteConversationDetailsMessagesCitations(BaseModel):
    content: Optional[
        "CompleteConversationCompleteConversationDetailsMessagesCitationsContent"
    ]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class CompleteConversationCompleteConversationDetailsMessagesCitationsContent(
    BaseModel
):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional[
        "CompleteConversationCompleteConversationDetailsMessagesCitationsContentVideo"
    ]
    audio: Optional[
        "CompleteConversationCompleteConversationDetailsMessagesCitationsContentAudio"
    ]
    image: Optional[
        "CompleteConversationCompleteConversationDetailsMessagesCitationsContentImage"
    ]
    document: Optional[
        "CompleteConversationCompleteConversationDetailsMessagesCitationsContentDocument"
    ]


class CompleteConversationCompleteConversationDetailsMessagesCitationsContentVideo(
    BaseModel
):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class CompleteConversationCompleteConversationDetailsMessagesCitationsContentAudio(
    BaseModel
):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class CompleteConversationCompleteConversationDetailsMessagesCitationsContentImage(
    BaseModel
):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class CompleteConversationCompleteConversationDetailsMessagesCitationsContentDocument(
    BaseModel
):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class CompleteConversationCompleteConversationDetailsMessagesToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


CompleteConversation.model_rebuild()
CompleteConversationCompleteConversation.model_rebuild()
CompleteConversationCompleteConversationMessage.model_rebuild()
CompleteConversationCompleteConversationMessageCitations.model_rebuild()
CompleteConversationCompleteConversationMessageCitationsContent.model_rebuild()
CompleteConversationCompleteConversationFacets.model_rebuild()
CompleteConversationCompleteConversationFacetsObservable.model_rebuild()
CompleteConversationCompleteConversationGraph.model_rebuild()
CompleteConversationCompleteConversationDetails.model_rebuild()
CompleteConversationCompleteConversationDetailsMessages.model_rebuild()
CompleteConversationCompleteConversationDetailsMessagesCitations.model_rebuild()
CompleteConversationCompleteConversationDetailsMessagesCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/continue_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentFacetTypes,
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    EntityTypes,
    FacetValueTypes,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    ObservableTypes,
    OrientationTypes,
)


class ContinueConversation(BaseModel):
    continue_conversation: Optional["ContinueConversationContinueConversation"] = Field(
        alias="continueConversation"
    )


class ContinueConversationContinueConversation(BaseModel):
    conversation: Optional["ContinueConversationContinueConversationConversation"]
    message: Optional["ContinueConversationContinueConversationMessage"]
    message_count: Optional[int] = Field(alias="messageCount")
    facets: Optional[List[Optional["ContinueConversationContinueConversationFacets"]]]
    graph: Optional["ContinueConversationContinueConversationGraph"]
    details: Optional["ContinueConversationContinueConversationDetails"]


class ContinueConversationContinueConversationConversation(BaseModel):
    id: str


class ContinueConversationContinueConversationMessage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[Optional["ContinueConversationContinueConversationMessageCitations"]]
    ]
    tool_calls: Optional[
        List[Optional["ContinueConversationContinueConversationMessageToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class ContinueConversationContinueConversationMessageCitations(BaseModel):
    content: Optional["ContinueConversationContinueConversationMessageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class ContinueConversationContinueConversationMessageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional[
        "ContinueConversationContinueConversationMessageCitationsContentVideo"
    ]
    audio: Optional[
        "ContinueConversationContinueConversationMessageCitationsContentAudio"
    ]
    image: Optional[
        "ContinueConversationContinueConversationMessageCitationsContentImage"
    ]
    document: Optional[
        "ContinueConversationContinueConversationMessageCitationsContentDocument"
    ]


class ContinueConversationContinueConversationMessageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class ContinueConversationContinueConversationMessageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class ContinueConversationContinueConversationMessageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class ContinueConversationContinueConversationMessageCitationsContentDocument(
    BaseModel
):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class ContinueConversationContinueConversationMessageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


class ContinueConversationContinueConversationFacets(BaseModel):
    type: Optional[FacetValueTypes]
    value: Optional[str]
    range: Optional["ContinueConversationContinueConversationFacetsRange"]
    count: Optional[Any]
    facet: Optional[ContentFacetTypes]
    observable: Optional["ContinueConversationContinueConversationFacetsObservable"]


class ContinueConversationContinueConversationFacetsRange(BaseModel):
    from_: Optional[str] = Field(alias="from")
    to: Optional[str]


class ContinueConversationContinueConversationFacetsObservable(BaseModel):
    type: Optional[ObservableTypes]
    observable: Optional[
        "ContinueConversationContinueConversationFacetsObservableObservable"
    ]


class ContinueConversationContinueConversationFacetsObservableObservable(BaseModel):
    id: str
    name: Optional[str]


class ContinueConversationContinueConversationGraph(BaseModel):
    nodes: Optional[
        List[Optional["ContinueConversationContinueConversationGraphNodes"]]
    ]
    edges: Optional[
        List[Optional["ContinueConversationContinueConversationGraphEdges"]]
    ]


class ContinueConversationContinueConversationGraphNodes(BaseModel):
    id: str
    name: str
    type: EntityTypes
    metadata: Optional[str]


class ContinueConversationContinueConversationGraphEdges(BaseModel):
    from_: str = Field(alias="from")
    to: str
    relation: Optional[str]


class ContinueConversationContinueConversationDetails(BaseModel):
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    supports_tool_calling: Optional[bool] = Field(alias="supportsToolCalling")
    source_count: Optional[int] = Field(alias="sourceCount")
    observable_count: Optional[int] = Field(alias="observableCount")
    tool_count: Optional[int] = Field(alias="toolCount")
    rendered_source_count: Optional[int] = Field(alias="renderedSourceCount")
    rendered_observable_count: Optional[int] = Field(alias="renderedObservableCount")
    rendered_tool_count: Optional[int] = Field(alias="renderedToolCount")
    ranked_source_count: Optional[int] = Field(alias="rankedSourceCount")
    ranked_observable_count: Optional[int] = Field(alias="rankedObservableCount")
    ranked_tool_count: Optional[int] = Field(alias="rankedToolCount")
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    sources: Optional[str]
    formatted_sources: Optional[str] = Field(alias="formattedSources")
    formatted_observables: Optional[str] = Field(alias="formattedObservables")
    formatted_instructions: Optional[str] = Field(alias="formattedInstructions")
    formatted_tools: Optional[str] = Field(alias="formattedTools")
    specification: Optional[str]
    messages: Optional[
        List[Optional["ContinueConversationContinueConversationDetailsMessages"]]
    ]


class ContinueConversationContinueConversationDetailsMessages(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[
            Optional["ContinueConversationContinueConversationDetailsMessagesCitations"]
        ]
    ]
    tool_calls: Optional[
        List[
            Optional["ContinueConversationContinueConversationDetailsMessagesToolCalls"]
        ]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class ContinueConversationContinueConversationDetailsMessagesCitations(BaseModel):
    content: Optional[
        "ContinueConversationContinueConversationDetailsMessagesCitationsContent"
    ]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class ContinueConversationContinueConversationDetailsMessagesCitationsContent(
    BaseModel
):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional[
        "ContinueConversationContinueConversationDetailsMessagesCitationsContentVideo"
    ]
    audio: Optional[
        "ContinueConversationContinueConversationDetailsMessagesCitationsContentAudio"
    ]
    image: Optional[
        "ContinueConversationContinueConversationDetailsMessagesCitationsContentImage"
    ]
    document: Optional[
        "ContinueConversationContinueConversationDetailsMessagesCitationsContentDocument"
    ]


class ContinueConversationContinueConversationDetailsMessagesCitationsContentVideo(
    BaseModel
):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class ContinueConversationContinueConversationDetailsMessagesCitationsContentAudio(
    BaseModel
):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class ContinueConversationContinueConversationDetailsMessagesCitationsContentImage(
    BaseModel
):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class ContinueConversationContinueConversationDetailsMessagesCitationsContentDocument(
    BaseModel
):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class ContinueConversationContinueConversationDetailsMessagesToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


ContinueConversation.model_rebuild()
ContinueConversationContinueConversation.model_rebuild()
ContinueConversationContinueConversationMessage.model_rebuild()
ContinueConversationContinueConversationMessageCitations.model_rebuild()
ContinueConversationContinueConversationMessageCitationsContent.model_rebuild()
ContinueConversationContinueConversationFacets.model_rebuild()
ContinueConversationContinueConversationFacetsObservable.model_rebuild()
ContinueConversationContinueConversationGraph.model_rebuild()
ContinueConversationContinueConversationDetails.model_rebuild()
ContinueConversationContinueConversationDetailsMessages.model_rebuild()
ContinueConversationContinueConversationDetailsMessagesCitations.model_rebuild()
ContinueConversationContinueConversationDetailsMessagesCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/count_alerts.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountAlerts(BaseModel):
    count_alerts: Optional["CountAlertsCountAlerts"] = Field(alias="countAlerts")


class CountAlertsCountAlerts(BaseModel):
    count: Optional[Any]


CountAlerts.model_rebuild()



================================================
FILE: graphlit_api/count_categories.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountCategories(BaseModel):
    count_categories: Optional["CountCategoriesCountCategories"] = Field(
        alias="countCategories"
    )


class CountCategoriesCountCategories(BaseModel):
    count: Optional[Any]


CountCategories.model_rebuild()



================================================
FILE: graphlit_api/count_collections.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountCollections(BaseModel):
    count_collections: Optional["CountCollectionsCountCollections"] = Field(
        alias="countCollections"
    )


class CountCollectionsCountCollections(BaseModel):
    count: Optional[Any]


CountCollections.model_rebuild()



================================================
FILE: graphlit_api/count_contents.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountContents(BaseModel):
    count_contents: Optional["CountContentsCountContents"] = Field(
        alias="countContents"
    )


class CountContentsCountContents(BaseModel):
    count: Optional[Any]


CountContents.model_rebuild()



================================================
FILE: graphlit_api/count_conversations.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountConversations(BaseModel):
    count_conversations: Optional["CountConversationsCountConversations"] = Field(
        alias="countConversations"
    )


class CountConversationsCountConversations(BaseModel):
    count: Optional[Any]


CountConversations.model_rebuild()



================================================
FILE: graphlit_api/count_events.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountEvents(BaseModel):
    count_events: Optional["CountEventsCountEvents"] = Field(alias="countEvents")


class CountEventsCountEvents(BaseModel):
    count: Optional[Any]


CountEvents.model_rebuild()



================================================
FILE: graphlit_api/count_feeds.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountFeeds(BaseModel):
    count_feeds: Optional["CountFeedsCountFeeds"] = Field(alias="countFeeds")


class CountFeedsCountFeeds(BaseModel):
    count: Optional[Any]


CountFeeds.model_rebuild()



================================================
FILE: graphlit_api/count_labels.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountLabels(BaseModel):
    count_labels: Optional["CountLabelsCountLabels"] = Field(alias="countLabels")


class CountLabelsCountLabels(BaseModel):
    count: Optional[Any]


CountLabels.model_rebuild()



================================================
FILE: graphlit_api/count_medical_conditions.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalConditions(BaseModel):
    count_medical_conditions: Optional[
        "CountMedicalConditionsCountMedicalConditions"
    ] = Field(alias="countMedicalConditions")


class CountMedicalConditionsCountMedicalConditions(BaseModel):
    count: Optional[Any]


CountMedicalConditions.model_rebuild()



================================================
FILE: graphlit_api/count_medical_contraindications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalContraindications(BaseModel):
    count_medical_contraindications: Optional[
        "CountMedicalContraindicationsCountMedicalContraindications"
    ] = Field(alias="countMedicalContraindications")


class CountMedicalContraindicationsCountMedicalContraindications(BaseModel):
    count: Optional[Any]


CountMedicalContraindications.model_rebuild()



================================================
FILE: graphlit_api/count_medical_devices.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalDevices(BaseModel):
    count_medical_devices: Optional["CountMedicalDevicesCountMedicalDevices"] = Field(
        alias="countMedicalDevices"
    )


class CountMedicalDevicesCountMedicalDevices(BaseModel):
    count: Optional[Any]


CountMedicalDevices.model_rebuild()



================================================
FILE: graphlit_api/count_medical_drug_classes.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalDrugClasses(BaseModel):
    count_medical_drug_classes: Optional[
        "CountMedicalDrugClassesCountMedicalDrugClasses"
    ] = Field(alias="countMedicalDrugClasses")


class CountMedicalDrugClassesCountMedicalDrugClasses(BaseModel):
    count: Optional[Any]


CountMedicalDrugClasses.model_rebuild()



================================================
FILE: graphlit_api/count_medical_drugs.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalDrugs(BaseModel):
    count_medical_drugs: Optional["CountMedicalDrugsCountMedicalDrugs"] = Field(
        alias="countMedicalDrugs"
    )


class CountMedicalDrugsCountMedicalDrugs(BaseModel):
    count: Optional[Any]


CountMedicalDrugs.model_rebuild()



================================================
FILE: graphlit_api/count_medical_guidelines.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalGuidelines(BaseModel):
    count_medical_guidelines: Optional[
        "CountMedicalGuidelinesCountMedicalGuidelines"
    ] = Field(alias="countMedicalGuidelines")


class CountMedicalGuidelinesCountMedicalGuidelines(BaseModel):
    count: Optional[Any]


CountMedicalGuidelines.model_rebuild()



================================================
FILE: graphlit_api/count_medical_indications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalIndications(BaseModel):
    count_medical_indications: Optional[
        "CountMedicalIndicationsCountMedicalIndications"
    ] = Field(alias="countMedicalIndications")


class CountMedicalIndicationsCountMedicalIndications(BaseModel):
    count: Optional[Any]


CountMedicalIndications.model_rebuild()



================================================
FILE: graphlit_api/count_medical_procedures.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalProcedures(BaseModel):
    count_medical_procedures: Optional[
        "CountMedicalProceduresCountMedicalProcedures"
    ] = Field(alias="countMedicalProcedures")


class CountMedicalProceduresCountMedicalProcedures(BaseModel):
    count: Optional[Any]


CountMedicalProcedures.model_rebuild()



================================================
FILE: graphlit_api/count_medical_studies.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalStudies(BaseModel):
    count_medical_studies: Optional["CountMedicalStudiesCountMedicalStudies"] = Field(
        alias="countMedicalStudies"
    )


class CountMedicalStudiesCountMedicalStudies(BaseModel):
    count: Optional[Any]


CountMedicalStudies.model_rebuild()



================================================
FILE: graphlit_api/count_medical_tests.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalTests(BaseModel):
    count_medical_tests: Optional["CountMedicalTestsCountMedicalTests"] = Field(
        alias="countMedicalTests"
    )


class CountMedicalTestsCountMedicalTests(BaseModel):
    count: Optional[Any]


CountMedicalTests.model_rebuild()



================================================
FILE: graphlit_api/count_medical_therapies.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountMedicalTherapies(BaseModel):
    count_medical_therapies: Optional["CountMedicalTherapiesCountMedicalTherapies"] = (
        Field(alias="countMedicalTherapies")
    )


class CountMedicalTherapiesCountMedicalTherapies(BaseModel):
    count: Optional[Any]


CountMedicalTherapies.model_rebuild()



================================================
FILE: graphlit_api/count_organizations.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountOrganizations(BaseModel):
    count_organizations: Optional["CountOrganizationsCountOrganizations"] = Field(
        alias="countOrganizations"
    )


class CountOrganizationsCountOrganizations(BaseModel):
    count: Optional[Any]


CountOrganizations.model_rebuild()



================================================
FILE: graphlit_api/count_persons.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountPersons(BaseModel):
    count_persons: Optional["CountPersonsCountPersons"] = Field(alias="countPersons")


class CountPersonsCountPersons(BaseModel):
    count: Optional[Any]


CountPersons.model_rebuild()



================================================
FILE: graphlit_api/count_places.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountPlaces(BaseModel):
    count_places: Optional["CountPlacesCountPlaces"] = Field(alias="countPlaces")


class CountPlacesCountPlaces(BaseModel):
    count: Optional[Any]


CountPlaces.model_rebuild()



================================================
FILE: graphlit_api/count_products.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountProducts(BaseModel):
    count_products: Optional["CountProductsCountProducts"] = Field(
        alias="countProducts"
    )


class CountProductsCountProducts(BaseModel):
    count: Optional[Any]


CountProducts.model_rebuild()



================================================
FILE: graphlit_api/count_repos.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountRepos(BaseModel):
    count_repos: Optional["CountReposCountRepos"] = Field(alias="countRepos")


class CountReposCountRepos(BaseModel):
    count: Optional[Any]


CountRepos.model_rebuild()



================================================
FILE: graphlit_api/count_softwares.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountSoftwares(BaseModel):
    count_softwares: Optional["CountSoftwaresCountSoftwares"] = Field(
        alias="countSoftwares"
    )


class CountSoftwaresCountSoftwares(BaseModel):
    count: Optional[Any]


CountSoftwares.model_rebuild()



================================================
FILE: graphlit_api/count_specifications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountSpecifications(BaseModel):
    count_specifications: Optional["CountSpecificationsCountSpecifications"] = Field(
        alias="countSpecifications"
    )


class CountSpecificationsCountSpecifications(BaseModel):
    count: Optional[Any]


CountSpecifications.model_rebuild()



================================================
FILE: graphlit_api/count_users.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountUsers(BaseModel):
    count_users: Optional["CountUsersCountUsers"] = Field(alias="countUsers")


class CountUsersCountUsers(BaseModel):
    count: Optional[Any]


CountUsers.model_rebuild()



================================================
FILE: graphlit_api/count_workflows.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class CountWorkflows(BaseModel):
    count_workflows: Optional["CountWorkflowsCountWorkflows"] = Field(
        alias="countWorkflows"
    )


class CountWorkflowsCountWorkflows(BaseModel):
    count: Optional[Any]


CountWorkflows.model_rebuild()



================================================
FILE: graphlit_api/create_alert.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import AlertTypes, EntityState


class CreateAlert(BaseModel):
    create_alert: Optional["CreateAlertCreateAlert"] = Field(alias="createAlert")


class CreateAlertCreateAlert(BaseModel):
    id: str
    name: str
    state: EntityState
    type: AlertTypes


CreateAlert.model_rebuild()



================================================
FILE: graphlit_api/create_category.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateCategory(BaseModel):
    create_category: Optional["CreateCategoryCreateCategory"] = Field(
        alias="createCategory"
    )


class CreateCategoryCreateCategory(BaseModel):
    id: str
    name: str


CreateCategory.model_rebuild()



================================================
FILE: graphlit_api/create_collection.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import CollectionTypes, EntityState


class CreateCollection(BaseModel):
    create_collection: Optional["CreateCollectionCreateCollection"] = Field(
        alias="createCollection"
    )


class CreateCollectionCreateCollection(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[CollectionTypes]


CreateCollection.model_rebuild()



================================================
FILE: graphlit_api/create_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import ConversationTypes, EntityState


class CreateConversation(BaseModel):
    create_conversation: Optional["CreateConversationCreateConversation"] = Field(
        alias="createConversation"
    )


class CreateConversationCreateConversation(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ConversationTypes]


CreateConversation.model_rebuild()



================================================
FILE: graphlit_api/create_event.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateEvent(BaseModel):
    create_event: Optional["CreateEventCreateEvent"] = Field(alias="createEvent")


class CreateEventCreateEvent(BaseModel):
    id: str
    name: str


CreateEvent.model_rebuild()



================================================
FILE: graphlit_api/create_feed.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState, FeedTypes


class CreateFeed(BaseModel):
    create_feed: Optional["CreateFeedCreateFeed"] = Field(alias="createFeed")


class CreateFeedCreateFeed(BaseModel):
    id: str
    name: str
    state: EntityState
    type: FeedTypes


CreateFeed.model_rebuild()



================================================
FILE: graphlit_api/create_label.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateLabel(BaseModel):
    create_label: Optional["CreateLabelCreateLabel"] = Field(alias="createLabel")


class CreateLabelCreateLabel(BaseModel):
    id: str
    name: str


CreateLabel.model_rebuild()



================================================
FILE: graphlit_api/create_medical_condition.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalCondition(BaseModel):
    create_medical_condition: Optional[
        "CreateMedicalConditionCreateMedicalCondition"
    ] = Field(alias="createMedicalCondition")


class CreateMedicalConditionCreateMedicalCondition(BaseModel):
    id: str
    name: str


CreateMedicalCondition.model_rebuild()



================================================
FILE: graphlit_api/create_medical_contraindication.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalContraindication(BaseModel):
    create_medical_contraindication: Optional[
        "CreateMedicalContraindicationCreateMedicalContraindication"
    ] = Field(alias="createMedicalContraindication")


class CreateMedicalContraindicationCreateMedicalContraindication(BaseModel):
    id: str
    name: str


CreateMedicalContraindication.model_rebuild()



================================================
FILE: graphlit_api/create_medical_device.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalDevice(BaseModel):
    create_medical_device: Optional["CreateMedicalDeviceCreateMedicalDevice"] = Field(
        alias="createMedicalDevice"
    )


class CreateMedicalDeviceCreateMedicalDevice(BaseModel):
    id: str
    name: str


CreateMedicalDevice.model_rebuild()



================================================
FILE: graphlit_api/create_medical_drug.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalDrug(BaseModel):
    create_medical_drug: Optional["CreateMedicalDrugCreateMedicalDrug"] = Field(
        alias="createMedicalDrug"
    )


class CreateMedicalDrugCreateMedicalDrug(BaseModel):
    id: str
    name: str


CreateMedicalDrug.model_rebuild()



================================================
FILE: graphlit_api/create_medical_drug_class.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalDrugClass(BaseModel):
    create_medical_drug_class: Optional[
        "CreateMedicalDrugClassCreateMedicalDrugClass"
    ] = Field(alias="createMedicalDrugClass")


class CreateMedicalDrugClassCreateMedicalDrugClass(BaseModel):
    id: str
    name: str


CreateMedicalDrugClass.model_rebuild()



================================================
FILE: graphlit_api/create_medical_guideline.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalGuideline(BaseModel):
    create_medical_guideline: Optional[
        "CreateMedicalGuidelineCreateMedicalGuideline"
    ] = Field(alias="createMedicalGuideline")


class CreateMedicalGuidelineCreateMedicalGuideline(BaseModel):
    id: str
    name: str


CreateMedicalGuideline.model_rebuild()



================================================
FILE: graphlit_api/create_medical_indication.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalIndication(BaseModel):
    create_medical_indication: Optional[
        "CreateMedicalIndicationCreateMedicalIndication"
    ] = Field(alias="createMedicalIndication")


class CreateMedicalIndicationCreateMedicalIndication(BaseModel):
    id: str
    name: str


CreateMedicalIndication.model_rebuild()



================================================
FILE: graphlit_api/create_medical_procedure.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalProcedure(BaseModel):
    create_medical_procedure: Optional[
        "CreateMedicalProcedureCreateMedicalProcedure"
    ] = Field(alias="createMedicalProcedure")


class CreateMedicalProcedureCreateMedicalProcedure(BaseModel):
    id: str
    name: str


CreateMedicalProcedure.model_rebuild()



================================================
FILE: graphlit_api/create_medical_study.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalStudy(BaseModel):
    create_medical_study: Optional["CreateMedicalStudyCreateMedicalStudy"] = Field(
        alias="createMedicalStudy"
    )


class CreateMedicalStudyCreateMedicalStudy(BaseModel):
    id: str
    name: str


CreateMedicalStudy.model_rebuild()



================================================
FILE: graphlit_api/create_medical_test.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalTest(BaseModel):
    create_medical_test: Optional["CreateMedicalTestCreateMedicalTest"] = Field(
        alias="createMedicalTest"
    )


class CreateMedicalTestCreateMedicalTest(BaseModel):
    id: str
    name: str


CreateMedicalTest.model_rebuild()



================================================
FILE: graphlit_api/create_medical_therapy.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateMedicalTherapy(BaseModel):
    create_medical_therapy: Optional["CreateMedicalTherapyCreateMedicalTherapy"] = (
        Field(alias="createMedicalTherapy")
    )


class CreateMedicalTherapyCreateMedicalTherapy(BaseModel):
    id: str
    name: str


CreateMedicalTherapy.model_rebuild()



================================================
FILE: graphlit_api/create_observation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class CreateObservation(BaseModel):
    create_observation: Optional["CreateObservationCreateObservation"] = Field(
        alias="createObservation"
    )


class CreateObservationCreateObservation(BaseModel):
    id: str
    state: EntityState


CreateObservation.model_rebuild()



================================================
FILE: graphlit_api/create_organization.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateOrganization(BaseModel):
    create_organization: Optional["CreateOrganizationCreateOrganization"] = Field(
        alias="createOrganization"
    )


class CreateOrganizationCreateOrganization(BaseModel):
    id: str
    name: str


CreateOrganization.model_rebuild()



================================================
FILE: graphlit_api/create_person.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreatePerson(BaseModel):
    create_person: Optional["CreatePersonCreatePerson"] = Field(alias="createPerson")


class CreatePersonCreatePerson(BaseModel):
    id: str
    name: str


CreatePerson.model_rebuild()



================================================
FILE: graphlit_api/create_place.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreatePlace(BaseModel):
    create_place: Optional["CreatePlaceCreatePlace"] = Field(alias="createPlace")


class CreatePlaceCreatePlace(BaseModel):
    id: str
    name: str


CreatePlace.model_rebuild()



================================================
FILE: graphlit_api/create_product.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateProduct(BaseModel):
    create_product: Optional["CreateProductCreateProduct"] = Field(
        alias="createProduct"
    )


class CreateProductCreateProduct(BaseModel):
    id: str
    name: str


CreateProduct.model_rebuild()



================================================
FILE: graphlit_api/create_repo.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateRepo(BaseModel):
    create_repo: Optional["CreateRepoCreateRepo"] = Field(alias="createRepo")


class CreateRepoCreateRepo(BaseModel):
    id: str
    name: str


CreateRepo.model_rebuild()



================================================
FILE: graphlit_api/create_software.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class CreateSoftware(BaseModel):
    create_software: Optional["CreateSoftwareCreateSoftware"] = Field(
        alias="createSoftware"
    )


class CreateSoftwareCreateSoftware(BaseModel):
    id: str
    name: str


CreateSoftware.model_rebuild()



================================================
FILE: graphlit_api/create_specification.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState, ModelServiceTypes, SpecificationTypes


class CreateSpecification(BaseModel):
    create_specification: Optional["CreateSpecificationCreateSpecification"] = Field(
        alias="createSpecification"
    )


class CreateSpecificationCreateSpecification(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[SpecificationTypes]
    service_type: Optional[ModelServiceTypes] = Field(alias="serviceType")


CreateSpecification.model_rebuild()



================================================
FILE: graphlit_api/create_user.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState, UserTypes


class CreateUser(BaseModel):
    create_user: Optional["CreateUserCreateUser"] = Field(alias="createUser")


class CreateUserCreateUser(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[UserTypes]
    identifier: str


CreateUser.model_rebuild()



================================================
FILE: graphlit_api/create_workflow.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AssemblyAIModels,
    AzureDocumentIntelligenceModels,
    AzureDocumentIntelligenceVersions,
    ContentClassificationServiceTypes,
    ContentIndexingServiceTypes,
    ContentTypes,
    DeepgramModels,
    EntityEnrichmentServiceTypes,
    EntityExtractionServiceTypes,
    EntityState,
    FilePreparationServiceTypes,
    FileTypes,
    IntegrationServiceTypes,
    LinkTypes,
    ObservableTypes,
    RegexSourceTypes,
    StoragePolicyTypes,
    SummarizationTypes,
)


class CreateWorkflow(BaseModel):
    create_workflow: Optional["CreateWorkflowCreateWorkflow"] = Field(
        alias="createWorkflow"
    )


class CreateWorkflowCreateWorkflow(BaseModel):
    id: str
    name: str
    state: EntityState
    ingestion: Optional["CreateWorkflowCreateWorkflowIngestion"]
    indexing: Optional["CreateWorkflowCreateWorkflowIndexing"]
    preparation: Optional["CreateWorkflowCreateWorkflowPreparation"]
    extraction: Optional["CreateWorkflowCreateWorkflowExtraction"]
    classification: Optional["CreateWorkflowCreateWorkflowClassification"]
    enrichment: Optional["CreateWorkflowCreateWorkflowEnrichment"]
    storage: Optional["CreateWorkflowCreateWorkflowStorage"]
    actions: Optional[List[Optional["CreateWorkflowCreateWorkflowActions"]]]


class CreateWorkflowCreateWorkflowIngestion(BaseModel):
    if_: Optional["CreateWorkflowCreateWorkflowIngestionIf"] = Field(alias="if")
    collections: Optional[
        List[Optional["CreateWorkflowCreateWorkflowIngestionCollections"]]
    ]
    observations: Optional[
        List[Optional["CreateWorkflowCreateWorkflowIngestionObservations"]]
    ]
    enable_email_collections: Optional[bool] = Field(alias="enableEmailCollections")


class CreateWorkflowCreateWorkflowIngestionIf(BaseModel):
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")


class CreateWorkflowCreateWorkflowIngestionCollections(BaseModel):
    id: str


class CreateWorkflowCreateWorkflowIngestionObservations(BaseModel):
    type: ObservableTypes
    observable: "CreateWorkflowCreateWorkflowIngestionObservationsObservable"


class CreateWorkflowCreateWorkflowIngestionObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class CreateWorkflowCreateWorkflowIndexing(BaseModel):
    jobs: Optional[List[Optional["CreateWorkflowCreateWorkflowIndexingJobs"]]]


class CreateWorkflowCreateWorkflowIndexingJobs(BaseModel):
    connector: Optional["CreateWorkflowCreateWorkflowIndexingJobsConnector"]


class CreateWorkflowCreateWorkflowIndexingJobsConnector(BaseModel):
    type: Optional[ContentIndexingServiceTypes]
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")


class CreateWorkflowCreateWorkflowPreparation(BaseModel):
    enable_unblocked_capture: Optional[bool] = Field(alias="enableUnblockedCapture")
    disable_smart_capture: Optional[bool] = Field(alias="disableSmartCapture")
    summarizations: Optional[
        List[Optional["CreateWorkflowCreateWorkflowPreparationSummarizations"]]
    ]
    jobs: Optional[List[Optional["CreateWorkflowCreateWorkflowPreparationJobs"]]]


class CreateWorkflowCreateWorkflowPreparationSummarizations(BaseModel):
    type: SummarizationTypes
    specification: Optional[
        "CreateWorkflowCreateWorkflowPreparationSummarizationsSpecification"
    ]
    tokens: Optional[int]
    items: Optional[int]
    prompt: Optional[str]


class CreateWorkflowCreateWorkflowPreparationSummarizationsSpecification(BaseModel):
    id: str


class CreateWorkflowCreateWorkflowPreparationJobs(BaseModel):
    connector: Optional["CreateWorkflowCreateWorkflowPreparationJobsConnector"]


class CreateWorkflowCreateWorkflowPreparationJobsConnector(BaseModel):
    type: FilePreparationServiceTypes
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    azure_document: Optional[
        "CreateWorkflowCreateWorkflowPreparationJobsConnectorAzureDocument"
    ] = Field(alias="azureDocument")
    deepgram: Optional["CreateWorkflowCreateWorkflowPreparationJobsConnectorDeepgram"]
    assembly_ai: Optional[
        "CreateWorkflowCreateWorkflowPreparationJobsConnectorAssemblyAi"
    ] = Field(alias="assemblyAI")
    page: Optional["CreateWorkflowCreateWorkflowPreparationJobsConnectorPage"]
    document: Optional["CreateWorkflowCreateWorkflowPreparationJobsConnectorDocument"]
    email: Optional["CreateWorkflowCreateWorkflowPreparationJobsConnectorEmail"]
    model_document: Optional[
        "CreateWorkflowCreateWorkflowPreparationJobsConnectorModelDocument"
    ] = Field(alias="modelDocument")
    mistral: Optional["CreateWorkflowCreateWorkflowPreparationJobsConnectorMistral"]


class CreateWorkflowCreateWorkflowPreparationJobsConnectorAzureDocument(BaseModel):
    version: Optional[AzureDocumentIntelligenceVersions]
    model: Optional[AzureDocumentIntelligenceModels]
    endpoint: Optional[Any]
    key: Optional[str]


class CreateWorkflowCreateWorkflowPreparationJobsConnectorDeepgram(BaseModel):
    model: Optional[DeepgramModels]
    key: Optional[str]
    enable_redaction: Optional[bool] = Field(alias="enableRedaction")
    enable_speaker_diarization: Optional[bool] = Field(alias="enableSpeakerDiarization")
    detect_language: Optional[bool] = Field(alias="detectLanguage")
    language: Optional[str]


class CreateWorkflowCreateWorkflowPreparationJobsConnectorAssemblyAi(BaseModel):
    model: Optional[AssemblyAIModels]
    key: Optional[str]
    enable_redaction: Optional[bool] = Field(alias="enableRedaction")
    enable_speaker_diarization: Optional[bool] = Field(alias="enableSpeakerDiarization")
    detect_language: Optional[bool] = Field(alias="detectLanguage")
    language: Optional[str]


class CreateWorkflowCreateWorkflowPreparationJobsConnectorPage(BaseModel):
    enable_screenshot: Optional[bool] = Field(alias="enableScreenshot")


class CreateWorkflowCreateWorkflowPreparationJobsConnectorDocument(BaseModel):
    include_images: Optional[bool] = Field(alias="includeImages")


class CreateWorkflowCreateWorkflowPreparationJobsConnectorEmail(BaseModel):
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class CreateWorkflowCreateWorkflowPreparationJobsConnectorModelDocument(BaseModel):
    specification: Optional[
        "CreateWorkflowCreateWorkflowPreparationJobsConnectorModelDocumentSpecification"
    ]


class CreateWorkflowCreateWorkflowPreparationJobsConnectorModelDocumentSpecification(
    BaseModel
):
    id: str


class CreateWorkflowCreateWorkflowPreparationJobsConnectorMistral(BaseModel):
    key: Optional[str]


class CreateWorkflowCreateWorkflowExtraction(BaseModel):
    jobs: Optional[List[Optional["CreateWorkflowCreateWorkflowExtractionJobs"]]]


class CreateWorkflowCreateWorkflowExtractionJobs(BaseModel):
    connector: Optional["CreateWorkflowCreateWorkflowExtractionJobsConnector"]


class CreateWorkflowCreateWorkflowExtractionJobsConnector(BaseModel):
    type: EntityExtractionServiceTypes
    content_types: Optional[List[ContentTypes]] = Field(alias="contentTypes")
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    extracted_types: Optional[List[ObservableTypes]] = Field(alias="extractedTypes")
    extracted_count: Optional[int] = Field(alias="extractedCount")
    azure_text: Optional[
        "CreateWorkflowCreateWorkflowExtractionJobsConnectorAzureText"
    ] = Field(alias="azureText")
    azure_image: Optional[
        "CreateWorkflowCreateWorkflowExtractionJobsConnectorAzureImage"
    ] = Field(alias="azureImage")
    model_image: Optional[
        "CreateWorkflowCreateWorkflowExtractionJobsConnectorModelImage"
    ] = Field(alias="modelImage")
    model_text: Optional[
        "CreateWorkflowCreateWorkflowExtractionJobsConnectorModelText"
    ] = Field(alias="modelText")


class CreateWorkflowCreateWorkflowExtractionJobsConnectorAzureText(BaseModel):
    confidence_threshold: Optional[float] = Field(alias="confidenceThreshold")
    enable_pii: Optional[bool] = Field(alias="enablePII")


class CreateWorkflowCreateWorkflowExtractionJobsConnectorAzureImage(BaseModel):
    confidence_threshold: Optional[float] = Field(alias="confidenceThreshold")


class CreateWorkflowCreateWorkflowExtractionJobsConnectorModelImage(BaseModel):
    specification: Optional[
        "CreateWorkflowCreateWorkflowExtractionJobsConnectorModelImageSpecification"
    ]


class CreateWorkflowCreateWorkflowExtractionJobsConnectorModelImageSpecification(
    BaseModel
):
    id: str


class CreateWorkflowCreateWorkflowExtractionJobsConnectorModelText(BaseModel):
    specification: Optional[
        "CreateWorkflowCreateWorkflowExtractionJobsConnectorModelTextSpecification"
    ]


class CreateWorkflowCreateWorkflowExtractionJobsConnectorModelTextSpecification(
    BaseModel
):
    id: str


class CreateWorkflowCreateWorkflowClassification(BaseModel):
    jobs: Optional[List[Optional["CreateWorkflowCreateWorkflowClassificationJobs"]]]


class CreateWorkflowCreateWorkflowClassificationJobs(BaseModel):
    connector: Optional["CreateWorkflowCreateWorkflowClassificationJobsConnector"]


class CreateWorkflowCreateWorkflowClassificationJobsConnector(BaseModel):
    type: ContentClassificationServiceTypes
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")
    model: Optional["CreateWorkflowCreateWorkflowClassificationJobsConnectorModel"]
    regex: Optional["CreateWorkflowCreateWorkflowClassificationJobsConnectorRegex"]


class CreateWorkflowCreateWorkflowClassificationJobsConnectorModel(BaseModel):
    specification: Optional[
        "CreateWorkflowCreateWorkflowClassificationJobsConnectorModelSpecification"
    ]
    rules: Optional[
        List[
            Optional[
                "CreateWorkflowCreateWorkflowClassificationJobsConnectorModelRules"
            ]
        ]
    ]


class CreateWorkflowCreateWorkflowClassificationJobsConnectorModelSpecification(
    BaseModel
):
    id: str


class CreateWorkflowCreateWorkflowClassificationJobsConnectorModelRules(BaseModel):
    then: Optional[str]
    if_: Optional[str] = Field(alias="if")


class CreateWorkflowCreateWorkflowClassificationJobsConnectorRegex(BaseModel):
    rules: Optional[
        List[
            Optional[
                "CreateWorkflowCreateWorkflowClassificationJobsConnectorRegexRules"
            ]
        ]
    ]


class CreateWorkflowCreateWorkflowClassificationJobsConnectorRegexRules(BaseModel):
    then: Optional[str]
    type: Optional[RegexSourceTypes]
    path: Optional[str]
    matches: Optional[str]


class CreateWorkflowCreateWorkflowEnrichment(BaseModel):
    link: Optional["CreateWorkflowCreateWorkflowEnrichmentLink"]
    jobs: Optional[List[Optional["CreateWorkflowCreateWorkflowEnrichmentJobs"]]]


class CreateWorkflowCreateWorkflowEnrichmentLink(BaseModel):
    enable_crawling: Optional[bool] = Field(alias="enableCrawling")
    allowed_domains: Optional[List[str]] = Field(alias="allowedDomains")
    excluded_domains: Optional[List[str]] = Field(alias="excludedDomains")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")
    allowed_links: Optional[List[LinkTypes]] = Field(alias="allowedLinks")
    excluded_links: Optional[List[LinkTypes]] = Field(alias="excludedLinks")
    allowed_files: Optional[List[FileTypes]] = Field(alias="allowedFiles")
    excluded_files: Optional[List[FileTypes]] = Field(alias="excludedFiles")
    allow_content_domain: Optional[bool] = Field(alias="allowContentDomain")
    maximum_links: Optional[int] = Field(alias="maximumLinks")


class CreateWorkflowCreateWorkflowEnrichmentJobs(BaseModel):
    connector: Optional["CreateWorkflowCreateWorkflowEnrichmentJobsConnector"]


class CreateWorkflowCreateWorkflowEnrichmentJobsConnector(BaseModel):
    type: Optional[EntityEnrichmentServiceTypes]
    enriched_types: Optional[List[Optional[ObservableTypes]]] = Field(
        alias="enrichedTypes"
    )
    fhir: Optional["CreateWorkflowCreateWorkflowEnrichmentJobsConnectorFhir"]
    diffbot: Optional["CreateWorkflowCreateWorkflowEnrichmentJobsConnectorDiffbot"]


class CreateWorkflowCreateWorkflowEnrichmentJobsConnectorFhir(BaseModel):
    endpoint: Optional[Any]


class CreateWorkflowCreateWorkflowEnrichmentJobsConnectorDiffbot(BaseModel):
    key: Optional[Any]


class CreateWorkflowCreateWorkflowStorage(BaseModel):
    policy: Optional["CreateWorkflowCreateWorkflowStoragePolicy"]


class CreateWorkflowCreateWorkflowStoragePolicy(BaseModel):
    type: Optional[StoragePolicyTypes]
    allow_duplicates: Optional[bool] = Field(alias="allowDuplicates")


class CreateWorkflowCreateWorkflowActions(BaseModel):
    connector: Optional["CreateWorkflowCreateWorkflowActionsConnector"]


class CreateWorkflowCreateWorkflowActionsConnector(BaseModel):
    type: IntegrationServiceTypes
    uri: Optional[str]
    slack: Optional["CreateWorkflowCreateWorkflowActionsConnectorSlack"]
    email: Optional["CreateWorkflowCreateWorkflowActionsConnectorEmail"]
    twitter: Optional["CreateWorkflowCreateWorkflowActionsConnectorTwitter"]


class CreateWorkflowCreateWorkflowActionsConnectorSlack(BaseModel):
    token: str
    channel: str


class CreateWorkflowCreateWorkflowActionsConnectorEmail(BaseModel):
    from_: str = Field(alias="from")
    subject: str
    to: List[str]


class CreateWorkflowCreateWorkflowActionsConnectorTwitter(BaseModel):
    consumer_key: str = Field(alias="consumerKey")
    consumer_secret: str = Field(alias="consumerSecret")
    access_token_key: str = Field(alias="accessTokenKey")
    access_token_secret: str = Field(alias="accessTokenSecret")


CreateWorkflow.model_rebuild()
CreateWorkflowCreateWorkflow.model_rebuild()
CreateWorkflowCreateWorkflowIngestion.model_rebuild()
CreateWorkflowCreateWorkflowIngestionObservations.model_rebuild()
CreateWorkflowCreateWorkflowIndexing.model_rebuild()
CreateWorkflowCreateWorkflowIndexingJobs.model_rebuild()
CreateWorkflowCreateWorkflowPreparation.model_rebuild()
CreateWorkflowCreateWorkflowPreparationSummarizations.model_rebuild()
CreateWorkflowCreateWorkflowPreparationJobs.model_rebuild()
CreateWorkflowCreateWorkflowPreparationJobsConnector.model_rebuild()
CreateWorkflowCreateWorkflowPreparationJobsConnectorModelDocument.model_rebuild()
CreateWorkflowCreateWorkflowExtraction.model_rebuild()
CreateWorkflowCreateWorkflowExtractionJobs.model_rebuild()
CreateWorkflowCreateWorkflowExtractionJobsConnector.model_rebuild()
CreateWorkflowCreateWorkflowExtractionJobsConnectorModelImage.model_rebuild()
CreateWorkflowCreateWorkflowExtractionJobsConnectorModelText.model_rebuild()
CreateWorkflowCreateWorkflowClassification.model_rebuild()
CreateWorkflowCreateWorkflowClassificationJobs.model_rebuild()
CreateWorkflowCreateWorkflowClassificationJobsConnector.model_rebuild()
CreateWorkflowCreateWorkflowClassificationJobsConnectorModel.model_rebuild()
CreateWorkflowCreateWorkflowClassificationJobsConnectorRegex.model_rebuild()
CreateWorkflowCreateWorkflowEnrichment.model_rebuild()
CreateWorkflowCreateWorkflowEnrichmentJobs.model_rebuild()
CreateWorkflowCreateWorkflowEnrichmentJobsConnector.model_rebuild()
CreateWorkflowCreateWorkflowStorage.model_rebuild()
CreateWorkflowCreateWorkflowActions.model_rebuild()
CreateWorkflowCreateWorkflowActionsConnector.model_rebuild()



================================================
FILE: graphlit_api/delete_alert.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAlert(BaseModel):
    delete_alert: Optional["DeleteAlertDeleteAlert"] = Field(alias="deleteAlert")


class DeleteAlertDeleteAlert(BaseModel):
    id: str
    state: EntityState


DeleteAlert.model_rebuild()



================================================
FILE: graphlit_api/delete_alerts.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAlerts(BaseModel):
    delete_alerts: Optional[List[Optional["DeleteAlertsDeleteAlerts"]]] = Field(
        alias="deleteAlerts"
    )


class DeleteAlertsDeleteAlerts(BaseModel):
    id: str
    state: EntityState


DeleteAlerts.model_rebuild()



================================================
FILE: graphlit_api/delete_all_alerts.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllAlerts(BaseModel):
    delete_all_alerts: Optional[List[Optional["DeleteAllAlertsDeleteAllAlerts"]]] = (
        Field(alias="deleteAllAlerts")
    )


class DeleteAllAlertsDeleteAllAlerts(BaseModel):
    id: str
    state: EntityState


DeleteAllAlerts.model_rebuild()



================================================
FILE: graphlit_api/delete_all_categories.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllCategories(BaseModel):
    delete_all_categories: Optional[
        List[Optional["DeleteAllCategoriesDeleteAllCategories"]]
    ] = Field(alias="deleteAllCategories")


class DeleteAllCategoriesDeleteAllCategories(BaseModel):
    id: str
    state: EntityState


DeleteAllCategories.model_rebuild()



================================================
FILE: graphlit_api/delete_all_collections.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllCollections(BaseModel):
    delete_all_collections: Optional[
        List[Optional["DeleteAllCollectionsDeleteAllCollections"]]
    ] = Field(alias="deleteAllCollections")


class DeleteAllCollectionsDeleteAllCollections(BaseModel):
    id: str
    state: EntityState


DeleteAllCollections.model_rebuild()



================================================
FILE: graphlit_api/delete_all_contents.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllContents(BaseModel):
    delete_all_contents: Optional[
        List[Optional["DeleteAllContentsDeleteAllContents"]]
    ] = Field(alias="deleteAllContents")


class DeleteAllContentsDeleteAllContents(BaseModel):
    id: str
    state: EntityState


DeleteAllContents.model_rebuild()



================================================
FILE: graphlit_api/delete_all_conversations.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllConversations(BaseModel):
    delete_all_conversations: Optional[
        List[Optional["DeleteAllConversationsDeleteAllConversations"]]
    ] = Field(alias="deleteAllConversations")


class DeleteAllConversationsDeleteAllConversations(BaseModel):
    id: str
    state: EntityState


DeleteAllConversations.model_rebuild()



================================================
FILE: graphlit_api/delete_all_events.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllEvents(BaseModel):
    delete_all_events: Optional[List[Optional["DeleteAllEventsDeleteAllEvents"]]] = (
        Field(alias="deleteAllEvents")
    )


class DeleteAllEventsDeleteAllEvents(BaseModel):
    id: str
    state: EntityState


DeleteAllEvents.model_rebuild()



================================================
FILE: graphlit_api/delete_all_feeds.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllFeeds(BaseModel):
    delete_all_feeds: Optional[List[Optional["DeleteAllFeedsDeleteAllFeeds"]]] = Field(
        alias="deleteAllFeeds"
    )


class DeleteAllFeedsDeleteAllFeeds(BaseModel):
    id: str
    state: EntityState


DeleteAllFeeds.model_rebuild()



================================================
FILE: graphlit_api/delete_all_labels.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllLabels(BaseModel):
    delete_all_labels: Optional[List[Optional["DeleteAllLabelsDeleteAllLabels"]]] = (
        Field(alias="deleteAllLabels")
    )


class DeleteAllLabelsDeleteAllLabels(BaseModel):
    id: str
    state: EntityState


DeleteAllLabels.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_conditions.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalConditions(BaseModel):
    delete_all_medical_conditions: Optional[
        List[Optional["DeleteAllMedicalConditionsDeleteAllMedicalConditions"]]
    ] = Field(alias="deleteAllMedicalConditions")


class DeleteAllMedicalConditionsDeleteAllMedicalConditions(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalConditions.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_contraindications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalContraindications(BaseModel):
    delete_all_medical_contraindications: Optional[
        List[
            Optional[
                "DeleteAllMedicalContraindicationsDeleteAllMedicalContraindications"
            ]
        ]
    ] = Field(alias="deleteAllMedicalContraindications")


class DeleteAllMedicalContraindicationsDeleteAllMedicalContraindications(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalContraindications.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_devices.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalDevices(BaseModel):
    delete_all_medical_devices: Optional[
        List[Optional["DeleteAllMedicalDevicesDeleteAllMedicalDevices"]]
    ] = Field(alias="deleteAllMedicalDevices")


class DeleteAllMedicalDevicesDeleteAllMedicalDevices(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalDevices.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_drug_classes.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalDrugClasses(BaseModel):
    delete_all_medical_drug_classes: Optional[
        List[Optional["DeleteAllMedicalDrugClassesDeleteAllMedicalDrugClasses"]]
    ] = Field(alias="deleteAllMedicalDrugClasses")


class DeleteAllMedicalDrugClassesDeleteAllMedicalDrugClasses(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalDrugClasses.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_drugs.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalDrugs(BaseModel):
    delete_all_medical_drugs: Optional[
        List[Optional["DeleteAllMedicalDrugsDeleteAllMedicalDrugs"]]
    ] = Field(alias="deleteAllMedicalDrugs")


class DeleteAllMedicalDrugsDeleteAllMedicalDrugs(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalDrugs.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_guidelines.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalGuidelines(BaseModel):
    delete_all_medical_guidelines: Optional[
        List[Optional["DeleteAllMedicalGuidelinesDeleteAllMedicalGuidelines"]]
    ] = Field(alias="deleteAllMedicalGuidelines")


class DeleteAllMedicalGuidelinesDeleteAllMedicalGuidelines(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalGuidelines.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_indications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalIndications(BaseModel):
    delete_all_medical_indications: Optional[
        List[Optional["DeleteAllMedicalIndicationsDeleteAllMedicalIndications"]]
    ] = Field(alias="deleteAllMedicalIndications")


class DeleteAllMedicalIndicationsDeleteAllMedicalIndications(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalIndications.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_procedures.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalProcedures(BaseModel):
    delete_all_medical_procedures: Optional[
        List[Optional["DeleteAllMedicalProceduresDeleteAllMedicalProcedures"]]
    ] = Field(alias="deleteAllMedicalProcedures")


class DeleteAllMedicalProceduresDeleteAllMedicalProcedures(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalProcedures.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_studies.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalStudies(BaseModel):
    delete_all_medical_studies: Optional[
        List[Optional["DeleteAllMedicalStudiesDeleteAllMedicalStudies"]]
    ] = Field(alias="deleteAllMedicalStudies")


class DeleteAllMedicalStudiesDeleteAllMedicalStudies(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalStudies.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_tests.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalTests(BaseModel):
    delete_all_medical_tests: Optional[
        List[Optional["DeleteAllMedicalTestsDeleteAllMedicalTests"]]
    ] = Field(alias="deleteAllMedicalTests")


class DeleteAllMedicalTestsDeleteAllMedicalTests(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalTests.model_rebuild()



================================================
FILE: graphlit_api/delete_all_medical_therapies.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllMedicalTherapies(BaseModel):
    delete_all_medical_therapies: Optional[
        List[Optional["DeleteAllMedicalTherapiesDeleteAllMedicalTherapies"]]
    ] = Field(alias="deleteAllMedicalTherapies")


class DeleteAllMedicalTherapiesDeleteAllMedicalTherapies(BaseModel):
    id: str
    state: EntityState


DeleteAllMedicalTherapies.model_rebuild()



================================================
FILE: graphlit_api/delete_all_organizations.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllOrganizations(BaseModel):
    delete_all_organizations: Optional[
        List[Optional["DeleteAllOrganizationsDeleteAllOrganizations"]]
    ] = Field(alias="deleteAllOrganizations")


class DeleteAllOrganizationsDeleteAllOrganizations(BaseModel):
    id: str
    state: EntityState


DeleteAllOrganizations.model_rebuild()



================================================
FILE: graphlit_api/delete_all_persons.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllPersons(BaseModel):
    delete_all_persons: Optional[List[Optional["DeleteAllPersonsDeleteAllPersons"]]] = (
        Field(alias="deleteAllPersons")
    )


class DeleteAllPersonsDeleteAllPersons(BaseModel):
    id: str
    state: EntityState


DeleteAllPersons.model_rebuild()



================================================
FILE: graphlit_api/delete_all_places.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllPlaces(BaseModel):
    delete_all_places: Optional[List[Optional["DeleteAllPlacesDeleteAllPlaces"]]] = (
        Field(alias="deleteAllPlaces")
    )


class DeleteAllPlacesDeleteAllPlaces(BaseModel):
    id: str
    state: EntityState


DeleteAllPlaces.model_rebuild()



================================================
FILE: graphlit_api/delete_all_products.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllProducts(BaseModel):
    delete_all_products: Optional[
        List[Optional["DeleteAllProductsDeleteAllProducts"]]
    ] = Field(alias="deleteAllProducts")


class DeleteAllProductsDeleteAllProducts(BaseModel):
    id: str
    state: EntityState


DeleteAllProducts.model_rebuild()



================================================
FILE: graphlit_api/delete_all_repos.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllRepos(BaseModel):
    delete_all_repos: Optional[List[Optional["DeleteAllReposDeleteAllRepos"]]] = Field(
        alias="deleteAllRepos"
    )


class DeleteAllReposDeleteAllRepos(BaseModel):
    id: str
    state: EntityState


DeleteAllRepos.model_rebuild()



================================================
FILE: graphlit_api/delete_all_softwares.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllSoftwares(BaseModel):
    delete_all_softwares: Optional[
        List[Optional["DeleteAllSoftwaresDeleteAllSoftwares"]]
    ] = Field(alias="deleteAllSoftwares")


class DeleteAllSoftwaresDeleteAllSoftwares(BaseModel):
    id: str
    state: EntityState


DeleteAllSoftwares.model_rebuild()



================================================
FILE: graphlit_api/delete_all_specifications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllSpecifications(BaseModel):
    delete_all_specifications: Optional[
        List[Optional["DeleteAllSpecificationsDeleteAllSpecifications"]]
    ] = Field(alias="deleteAllSpecifications")


class DeleteAllSpecificationsDeleteAllSpecifications(BaseModel):
    id: str
    state: EntityState


DeleteAllSpecifications.model_rebuild()



================================================
FILE: graphlit_api/delete_all_workflows.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteAllWorkflows(BaseModel):
    delete_all_workflows: Optional[
        List[Optional["DeleteAllWorkflowsDeleteAllWorkflows"]]
    ] = Field(alias="deleteAllWorkflows")


class DeleteAllWorkflowsDeleteAllWorkflows(BaseModel):
    id: str
    state: EntityState


DeleteAllWorkflows.model_rebuild()



================================================
FILE: graphlit_api/delete_categories.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteCategories(BaseModel):
    delete_categories: Optional[List[Optional["DeleteCategoriesDeleteCategories"]]] = (
        Field(alias="deleteCategories")
    )


class DeleteCategoriesDeleteCategories(BaseModel):
    id: str
    state: EntityState


DeleteCategories.model_rebuild()



================================================
FILE: graphlit_api/delete_category.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteCategory(BaseModel):
    delete_category: Optional["DeleteCategoryDeleteCategory"] = Field(
        alias="deleteCategory"
    )


class DeleteCategoryDeleteCategory(BaseModel):
    id: str
    state: EntityState


DeleteCategory.model_rebuild()



================================================
FILE: graphlit_api/delete_collection.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteCollection(BaseModel):
    delete_collection: Optional["DeleteCollectionDeleteCollection"] = Field(
        alias="deleteCollection"
    )


class DeleteCollectionDeleteCollection(BaseModel):
    id: str
    state: EntityState


DeleteCollection.model_rebuild()



================================================
FILE: graphlit_api/delete_collections.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteCollections(BaseModel):
    delete_collections: Optional[
        List[Optional["DeleteCollectionsDeleteCollections"]]
    ] = Field(alias="deleteCollections")


class DeleteCollectionsDeleteCollections(BaseModel):
    id: str
    state: EntityState


DeleteCollections.model_rebuild()



================================================
FILE: graphlit_api/delete_content.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteContent(BaseModel):
    delete_content: Optional["DeleteContentDeleteContent"] = Field(
        alias="deleteContent"
    )


class DeleteContentDeleteContent(BaseModel):
    id: str
    state: EntityState


DeleteContent.model_rebuild()



================================================
FILE: graphlit_api/delete_contents.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteContents(BaseModel):
    delete_contents: Optional[List[Optional["DeleteContentsDeleteContents"]]] = Field(
        alias="deleteContents"
    )


class DeleteContentsDeleteContents(BaseModel):
    id: str
    state: EntityState


DeleteContents.model_rebuild()



================================================
FILE: graphlit_api/delete_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteConversation(BaseModel):
    delete_conversation: Optional["DeleteConversationDeleteConversation"] = Field(
        alias="deleteConversation"
    )


class DeleteConversationDeleteConversation(BaseModel):
    id: str
    state: EntityState


DeleteConversation.model_rebuild()



================================================
FILE: graphlit_api/delete_conversations.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteConversations(BaseModel):
    delete_conversations: Optional[
        List[Optional["DeleteConversationsDeleteConversations"]]
    ] = Field(alias="deleteConversations")


class DeleteConversationsDeleteConversations(BaseModel):
    id: str
    state: EntityState


DeleteConversations.model_rebuild()



================================================
FILE: graphlit_api/delete_event.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteEvent(BaseModel):
    delete_event: Optional["DeleteEventDeleteEvent"] = Field(alias="deleteEvent")


class DeleteEventDeleteEvent(BaseModel):
    id: str
    state: EntityState


DeleteEvent.model_rebuild()



================================================
FILE: graphlit_api/delete_events.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteEvents(BaseModel):
    delete_events: Optional[List[Optional["DeleteEventsDeleteEvents"]]] = Field(
        alias="deleteEvents"
    )


class DeleteEventsDeleteEvents(BaseModel):
    id: str
    state: EntityState


DeleteEvents.model_rebuild()



================================================
FILE: graphlit_api/delete_feed.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteFeed(BaseModel):
    delete_feed: Optional["DeleteFeedDeleteFeed"] = Field(alias="deleteFeed")


class DeleteFeedDeleteFeed(BaseModel):
    id: str
    state: EntityState


DeleteFeed.model_rebuild()



================================================
FILE: graphlit_api/delete_feeds.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteFeeds(BaseModel):
    delete_feeds: Optional[List[Optional["DeleteFeedsDeleteFeeds"]]] = Field(
        alias="deleteFeeds"
    )


class DeleteFeedsDeleteFeeds(BaseModel):
    id: str
    state: EntityState


DeleteFeeds.model_rebuild()



================================================
FILE: graphlit_api/delete_label.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteLabel(BaseModel):
    delete_label: Optional["DeleteLabelDeleteLabel"] = Field(alias="deleteLabel")


class DeleteLabelDeleteLabel(BaseModel):
    id: str
    state: EntityState


DeleteLabel.model_rebuild()



================================================
FILE: graphlit_api/delete_labels.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteLabels(BaseModel):
    delete_labels: Optional[List[Optional["DeleteLabelsDeleteLabels"]]] = Field(
        alias="deleteLabels"
    )


class DeleteLabelsDeleteLabels(BaseModel):
    id: str
    state: EntityState


DeleteLabels.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_condition.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalCondition(BaseModel):
    delete_medical_condition: Optional[
        "DeleteMedicalConditionDeleteMedicalCondition"
    ] = Field(alias="deleteMedicalCondition")


class DeleteMedicalConditionDeleteMedicalCondition(BaseModel):
    id: str
    state: EntityState


DeleteMedicalCondition.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_conditions.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalConditions(BaseModel):
    delete_medical_conditions: Optional[
        List[Optional["DeleteMedicalConditionsDeleteMedicalConditions"]]
    ] = Field(alias="deleteMedicalConditions")


class DeleteMedicalConditionsDeleteMedicalConditions(BaseModel):
    id: str
    state: EntityState


DeleteMedicalConditions.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_contraindication.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalContraindication(BaseModel):
    delete_medical_contraindication: Optional[
        "DeleteMedicalContraindicationDeleteMedicalContraindication"
    ] = Field(alias="deleteMedicalContraindication")


class DeleteMedicalContraindicationDeleteMedicalContraindication(BaseModel):
    id: str
    state: EntityState


DeleteMedicalContraindication.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_contraindications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalContraindications(BaseModel):
    delete_medical_contraindications: Optional[
        List[Optional["DeleteMedicalContraindicationsDeleteMedicalContraindications"]]
    ] = Field(alias="deleteMedicalContraindications")


class DeleteMedicalContraindicationsDeleteMedicalContraindications(BaseModel):
    id: str
    state: EntityState


DeleteMedicalContraindications.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_device.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalDevice(BaseModel):
    delete_medical_device: Optional["DeleteMedicalDeviceDeleteMedicalDevice"] = Field(
        alias="deleteMedicalDevice"
    )


class DeleteMedicalDeviceDeleteMedicalDevice(BaseModel):
    id: str
    state: EntityState


DeleteMedicalDevice.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_devices.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalDevices(BaseModel):
    delete_medical_devices: Optional[
        List[Optional["DeleteMedicalDevicesDeleteMedicalDevices"]]
    ] = Field(alias="deleteMedicalDevices")


class DeleteMedicalDevicesDeleteMedicalDevices(BaseModel):
    id: str
    state: EntityState


DeleteMedicalDevices.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_drug.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalDrug(BaseModel):
    delete_medical_drug: Optional["DeleteMedicalDrugDeleteMedicalDrug"] = Field(
        alias="deleteMedicalDrug"
    )


class DeleteMedicalDrugDeleteMedicalDrug(BaseModel):
    id: str
    state: EntityState


DeleteMedicalDrug.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_drug_class.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalDrugClass(BaseModel):
    delete_medical_drug_class: Optional[
        "DeleteMedicalDrugClassDeleteMedicalDrugClass"
    ] = Field(alias="deleteMedicalDrugClass")


class DeleteMedicalDrugClassDeleteMedicalDrugClass(BaseModel):
    id: str
    state: EntityState


DeleteMedicalDrugClass.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_drug_classes.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalDrugClasses(BaseModel):
    delete_medical_drug_classes: Optional[
        List[Optional["DeleteMedicalDrugClassesDeleteMedicalDrugClasses"]]
    ] = Field(alias="deleteMedicalDrugClasses")


class DeleteMedicalDrugClassesDeleteMedicalDrugClasses(BaseModel):
    id: str
    state: EntityState


DeleteMedicalDrugClasses.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_drugs.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalDrugs(BaseModel):
    delete_medical_drugs: Optional[
        List[Optional["DeleteMedicalDrugsDeleteMedicalDrugs"]]
    ] = Field(alias="deleteMedicalDrugs")


class DeleteMedicalDrugsDeleteMedicalDrugs(BaseModel):
    id: str
    state: EntityState


DeleteMedicalDrugs.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_guideline.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalGuideline(BaseModel):
    delete_medical_guideline: Optional[
        "DeleteMedicalGuidelineDeleteMedicalGuideline"
    ] = Field(alias="deleteMedicalGuideline")


class DeleteMedicalGuidelineDeleteMedicalGuideline(BaseModel):
    id: str
    state: EntityState


DeleteMedicalGuideline.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_guidelines.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalGuidelines(BaseModel):
    delete_medical_guidelines: Optional[
        List[Optional["DeleteMedicalGuidelinesDeleteMedicalGuidelines"]]
    ] = Field(alias="deleteMedicalGuidelines")


class DeleteMedicalGuidelinesDeleteMedicalGuidelines(BaseModel):
    id: str
    state: EntityState


DeleteMedicalGuidelines.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_indication.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalIndication(BaseModel):
    delete_medical_indication: Optional[
        "DeleteMedicalIndicationDeleteMedicalIndication"
    ] = Field(alias="deleteMedicalIndication")


class DeleteMedicalIndicationDeleteMedicalIndication(BaseModel):
    id: str
    state: EntityState


DeleteMedicalIndication.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_indications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalIndications(BaseModel):
    delete_medical_indications: Optional[
        List[Optional["DeleteMedicalIndicationsDeleteMedicalIndications"]]
    ] = Field(alias="deleteMedicalIndications")


class DeleteMedicalIndicationsDeleteMedicalIndications(BaseModel):
    id: str
    state: EntityState


DeleteMedicalIndications.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_procedure.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalProcedure(BaseModel):
    delete_medical_procedure: Optional[
        "DeleteMedicalProcedureDeleteMedicalProcedure"
    ] = Field(alias="deleteMedicalProcedure")


class DeleteMedicalProcedureDeleteMedicalProcedure(BaseModel):
    id: str
    state: EntityState


DeleteMedicalProcedure.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_procedures.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalProcedures(BaseModel):
    delete_medical_procedures: Optional[
        List[Optional["DeleteMedicalProceduresDeleteMedicalProcedures"]]
    ] = Field(alias="deleteMedicalProcedures")


class DeleteMedicalProceduresDeleteMedicalProcedures(BaseModel):
    id: str
    state: EntityState


DeleteMedicalProcedures.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_studies.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalStudies(BaseModel):
    delete_medical_studies: Optional[
        List[Optional["DeleteMedicalStudiesDeleteMedicalStudies"]]
    ] = Field(alias="deleteMedicalStudies")


class DeleteMedicalStudiesDeleteMedicalStudies(BaseModel):
    id: str
    state: EntityState


DeleteMedicalStudies.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_study.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalStudy(BaseModel):
    delete_medical_study: Optional["DeleteMedicalStudyDeleteMedicalStudy"] = Field(
        alias="deleteMedicalStudy"
    )


class DeleteMedicalStudyDeleteMedicalStudy(BaseModel):
    id: str
    state: EntityState


DeleteMedicalStudy.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_test.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalTest(BaseModel):
    delete_medical_test: Optional["DeleteMedicalTestDeleteMedicalTest"] = Field(
        alias="deleteMedicalTest"
    )


class DeleteMedicalTestDeleteMedicalTest(BaseModel):
    id: str
    state: EntityState


DeleteMedicalTest.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_tests.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalTests(BaseModel):
    delete_medical_tests: Optional[
        List[Optional["DeleteMedicalTestsDeleteMedicalTests"]]
    ] = Field(alias="deleteMedicalTests")


class DeleteMedicalTestsDeleteMedicalTests(BaseModel):
    id: str
    state: EntityState


DeleteMedicalTests.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_therapies.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalTherapies(BaseModel):
    delete_medical_therapies: Optional[
        List[Optional["DeleteMedicalTherapiesDeleteMedicalTherapies"]]
    ] = Field(alias="deleteMedicalTherapies")


class DeleteMedicalTherapiesDeleteMedicalTherapies(BaseModel):
    id: str
    state: EntityState


DeleteMedicalTherapies.model_rebuild()



================================================
FILE: graphlit_api/delete_medical_therapy.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteMedicalTherapy(BaseModel):
    delete_medical_therapy: Optional["DeleteMedicalTherapyDeleteMedicalTherapy"] = (
        Field(alias="deleteMedicalTherapy")
    )


class DeleteMedicalTherapyDeleteMedicalTherapy(BaseModel):
    id: str
    state: EntityState


DeleteMedicalTherapy.model_rebuild()



================================================
FILE: graphlit_api/delete_observation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteObservation(BaseModel):
    delete_observation: Optional["DeleteObservationDeleteObservation"] = Field(
        alias="deleteObservation"
    )


class DeleteObservationDeleteObservation(BaseModel):
    id: str
    state: EntityState


DeleteObservation.model_rebuild()



================================================
FILE: graphlit_api/delete_organization.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteOrganization(BaseModel):
    delete_organization: Optional["DeleteOrganizationDeleteOrganization"] = Field(
        alias="deleteOrganization"
    )


class DeleteOrganizationDeleteOrganization(BaseModel):
    id: str
    state: EntityState


DeleteOrganization.model_rebuild()



================================================
FILE: graphlit_api/delete_organizations.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteOrganizations(BaseModel):
    delete_organizations: Optional[
        List[Optional["DeleteOrganizationsDeleteOrganizations"]]
    ] = Field(alias="deleteOrganizations")


class DeleteOrganizationsDeleteOrganizations(BaseModel):
    id: str
    state: EntityState


DeleteOrganizations.model_rebuild()



================================================
FILE: graphlit_api/delete_person.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeletePerson(BaseModel):
    delete_person: Optional["DeletePersonDeletePerson"] = Field(alias="deletePerson")


class DeletePersonDeletePerson(BaseModel):
    id: str
    state: EntityState


DeletePerson.model_rebuild()



================================================
FILE: graphlit_api/delete_persons.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeletePersons(BaseModel):
    delete_persons: Optional[List[Optional["DeletePersonsDeletePersons"]]] = Field(
        alias="deletePersons"
    )


class DeletePersonsDeletePersons(BaseModel):
    id: str
    state: EntityState


DeletePersons.model_rebuild()



================================================
FILE: graphlit_api/delete_place.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeletePlace(BaseModel):
    delete_place: Optional["DeletePlaceDeletePlace"] = Field(alias="deletePlace")


class DeletePlaceDeletePlace(BaseModel):
    id: str
    state: EntityState


DeletePlace.model_rebuild()



================================================
FILE: graphlit_api/delete_places.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeletePlaces(BaseModel):
    delete_places: Optional[List[Optional["DeletePlacesDeletePlaces"]]] = Field(
        alias="deletePlaces"
    )


class DeletePlacesDeletePlaces(BaseModel):
    id: str
    state: EntityState


DeletePlaces.model_rebuild()



================================================
FILE: graphlit_api/delete_product.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteProduct(BaseModel):
    delete_product: Optional["DeleteProductDeleteProduct"] = Field(
        alias="deleteProduct"
    )


class DeleteProductDeleteProduct(BaseModel):
    id: str
    state: EntityState


DeleteProduct.model_rebuild()



================================================
FILE: graphlit_api/delete_products.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteProducts(BaseModel):
    delete_products: Optional[List[Optional["DeleteProductsDeleteProducts"]]] = Field(
        alias="deleteProducts"
    )


class DeleteProductsDeleteProducts(BaseModel):
    id: str
    state: EntityState


DeleteProducts.model_rebuild()



================================================
FILE: graphlit_api/delete_repo.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteRepo(BaseModel):
    delete_repo: Optional["DeleteRepoDeleteRepo"] = Field(alias="deleteRepo")


class DeleteRepoDeleteRepo(BaseModel):
    id: str
    state: EntityState


DeleteRepo.model_rebuild()



================================================
FILE: graphlit_api/delete_repos.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteRepos(BaseModel):
    delete_repos: Optional[List[Optional["DeleteReposDeleteRepos"]]] = Field(
        alias="deleteRepos"
    )


class DeleteReposDeleteRepos(BaseModel):
    id: str
    state: EntityState


DeleteRepos.model_rebuild()



================================================
FILE: graphlit_api/delete_software.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteSoftware(BaseModel):
    delete_software: Optional["DeleteSoftwareDeleteSoftware"] = Field(
        alias="deleteSoftware"
    )


class DeleteSoftwareDeleteSoftware(BaseModel):
    id: str
    state: EntityState


DeleteSoftware.model_rebuild()



================================================
FILE: graphlit_api/delete_softwares.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteSoftwares(BaseModel):
    delete_softwares: Optional[List[Optional["DeleteSoftwaresDeleteSoftwares"]]] = (
        Field(alias="deleteSoftwares")
    )


class DeleteSoftwaresDeleteSoftwares(BaseModel):
    id: str
    state: EntityState


DeleteSoftwares.model_rebuild()



================================================
FILE: graphlit_api/delete_specification.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteSpecification(BaseModel):
    delete_specification: Optional["DeleteSpecificationDeleteSpecification"] = Field(
        alias="deleteSpecification"
    )


class DeleteSpecificationDeleteSpecification(BaseModel):
    id: str
    state: EntityState


DeleteSpecification.model_rebuild()



================================================
FILE: graphlit_api/delete_specifications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteSpecifications(BaseModel):
    delete_specifications: Optional[
        List[Optional["DeleteSpecificationsDeleteSpecifications"]]
    ] = Field(alias="deleteSpecifications")


class DeleteSpecificationsDeleteSpecifications(BaseModel):
    id: str
    state: EntityState


DeleteSpecifications.model_rebuild()



================================================
FILE: graphlit_api/delete_user.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteUser(BaseModel):
    delete_user: Optional["DeleteUserDeleteUser"] = Field(alias="deleteUser")


class DeleteUserDeleteUser(BaseModel):
    id: str
    state: EntityState


DeleteUser.model_rebuild()



================================================
FILE: graphlit_api/delete_workflow.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteWorkflow(BaseModel):
    delete_workflow: Optional["DeleteWorkflowDeleteWorkflow"] = Field(
        alias="deleteWorkflow"
    )


class DeleteWorkflowDeleteWorkflow(BaseModel):
    id: str
    state: EntityState


DeleteWorkflow.model_rebuild()



================================================
FILE: graphlit_api/delete_workflows.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DeleteWorkflows(BaseModel):
    delete_workflows: Optional[List[Optional["DeleteWorkflowsDeleteWorkflows"]]] = (
        Field(alias="deleteWorkflows")
    )


class DeleteWorkflowsDeleteWorkflows(BaseModel):
    id: str
    state: EntityState


DeleteWorkflows.model_rebuild()



================================================
FILE: graphlit_api/describe_encoded_image.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    OrientationTypes,
)


class DescribeEncodedImage(BaseModel):
    describe_encoded_image: Optional["DescribeEncodedImageDescribeEncodedImage"] = (
        Field(alias="describeEncodedImage")
    )


class DescribeEncodedImageDescribeEncodedImage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[Optional["DescribeEncodedImageDescribeEncodedImageCitations"]]
    ]
    tool_calls: Optional[
        List[Optional["DescribeEncodedImageDescribeEncodedImageToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class DescribeEncodedImageDescribeEncodedImageCitations(BaseModel):
    content: Optional["DescribeEncodedImageDescribeEncodedImageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class DescribeEncodedImageDescribeEncodedImageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["DescribeEncodedImageDescribeEncodedImageCitationsContentVideo"]
    audio: Optional["DescribeEncodedImageDescribeEncodedImageCitationsContentAudio"]
    image: Optional["DescribeEncodedImageDescribeEncodedImageCitationsContentImage"]
    document: Optional[
        "DescribeEncodedImageDescribeEncodedImageCitationsContentDocument"
    ]


class DescribeEncodedImageDescribeEncodedImageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class DescribeEncodedImageDescribeEncodedImageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class DescribeEncodedImageDescribeEncodedImageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class DescribeEncodedImageDescribeEncodedImageCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class DescribeEncodedImageDescribeEncodedImageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


DescribeEncodedImage.model_rebuild()
DescribeEncodedImageDescribeEncodedImage.model_rebuild()
DescribeEncodedImageDescribeEncodedImageCitations.model_rebuild()
DescribeEncodedImageDescribeEncodedImageCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/describe_image.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    OrientationTypes,
)


class DescribeImage(BaseModel):
    describe_image: Optional["DescribeImageDescribeImage"] = Field(
        alias="describeImage"
    )


class DescribeImageDescribeImage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[List[Optional["DescribeImageDescribeImageCitations"]]]
    tool_calls: Optional[List[Optional["DescribeImageDescribeImageToolCalls"]]] = Field(
        alias="toolCalls"
    )
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class DescribeImageDescribeImageCitations(BaseModel):
    content: Optional["DescribeImageDescribeImageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class DescribeImageDescribeImageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["DescribeImageDescribeImageCitationsContentVideo"]
    audio: Optional["DescribeImageDescribeImageCitationsContentAudio"]
    image: Optional["DescribeImageDescribeImageCitationsContentImage"]
    document: Optional["DescribeImageDescribeImageCitationsContentDocument"]


class DescribeImageDescribeImageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class DescribeImageDescribeImageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class DescribeImageDescribeImageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class DescribeImageDescribeImageCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class DescribeImageDescribeImageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


DescribeImage.model_rebuild()
DescribeImageDescribeImage.model_rebuild()
DescribeImageDescribeImageCitations.model_rebuild()
DescribeImageDescribeImageCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/disable_alert.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DisableAlert(BaseModel):
    disable_alert: Optional["DisableAlertDisableAlert"] = Field(alias="disableAlert")


class DisableAlertDisableAlert(BaseModel):
    id: str
    state: EntityState


DisableAlert.model_rebuild()



================================================
FILE: graphlit_api/disable_feed.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DisableFeed(BaseModel):
    disable_feed: Optional["DisableFeedDisableFeed"] = Field(alias="disableFeed")


class DisableFeedDisableFeed(BaseModel):
    id: str
    state: EntityState


DisableFeed.model_rebuild()



================================================
FILE: graphlit_api/disable_user.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class DisableUser(BaseModel):
    disable_user: Optional["DisableUserDisableUser"] = Field(alias="disableUser")


class DisableUserDisableUser(BaseModel):
    id: str
    state: EntityState


DisableUser.model_rebuild()



================================================
FILE: graphlit_api/enable_alert.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class EnableAlert(BaseModel):
    enable_alert: Optional["EnableAlertEnableAlert"] = Field(alias="enableAlert")


class EnableAlertEnableAlert(BaseModel):
    id: str
    state: EntityState


EnableAlert.model_rebuild()



================================================
FILE: graphlit_api/enable_feed.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class EnableFeed(BaseModel):
    enable_feed: Optional["EnableFeedEnableFeed"] = Field(alias="enableFeed")


class EnableFeedEnableFeed(BaseModel):
    id: str
    state: EntityState


EnableFeed.model_rebuild()



================================================
FILE: graphlit_api/enable_user.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class EnableUser(BaseModel):
    enable_user: Optional["EnableUserEnableUser"] = Field(alias="enableUser")


class EnableUserEnableUser(BaseModel):
    id: str
    state: EntityState


EnableUser.model_rebuild()



================================================
FILE: graphlit_api/enums.py
================================================
# Generated by ariadne-codegen
# Source: https://data-scus.graphlit.io/api/v1/graphql

from enum import Enum


class OpenAIModels(str, Enum):
    GPT35_TURBO = "GPT35_TURBO"
    GPT35_TURBO_0613 = "GPT35_TURBO_0613"
    GPT35_TURBO_16K = "GPT35_TURBO_16K"
    GPT35_TURBO_16K_0613 = "GPT35_TURBO_16K_0613"
    GPT35_TURBO_16K_1106 = "GPT35_TURBO_16K_1106"
    GPT35_TURBO_16K_0125 = "GPT35_TURBO_16K_0125"
    GPT4 = "GPT4"
    GPT4_0613 = "GPT4_0613"
    GPT4_TURBO_VISION_128K = "GPT4_TURBO_VISION_128K"
    GPT4_TURBO_VISION_128K_1106 = "GPT4_TURBO_VISION_128K_1106"
    GPT4_32K = "GPT4_32K"
    GPT4_32K_0613 = "GPT4_32K_0613"
    GPT4_TURBO_128K = "GPT4_TURBO_128K"
    GPT4_TURBO_128K_1106 = "GPT4_TURBO_128K_1106"
    GPT4_TURBO_128K_0125 = "GPT4_TURBO_128K_0125"
    GPT4_TURBO_128K_20240409 = "GPT4_TURBO_128K_20240409"
    GPT4O_128K_20240513 = "GPT4O_128K_20240513"
    GPT4O_128K_20240806 = "GPT4O_128K_20240806"
    GPT4O_128K_20241120 = "GPT4O_128K_20241120"
    GPT4O_128K = "GPT4O_128K"
    GPT4O_MINI_128K_20240718 = "GPT4O_MINI_128K_20240718"
    GPT4O_MINI_128K = "GPT4O_MINI_128K"
    GPT4O_CHAT_128K = "GPT4O_CHAT_128K"
    GPT41_NANO_1024K = "GPT41_NANO_1024K"
    GPT41_NANO_1024K_20250414 = "GPT41_NANO_1024K_20250414"
    GPT41_MINI_1024K = "GPT41_MINI_1024K"
    GPT41_MINI_1024K_20250414 = "GPT41_MINI_1024K_20250414"
    GPT41_1024K = "GPT41_1024K"
    GPT41_1024K_20250414 = "GPT41_1024K_20250414"
    GPT45_PREVIEW_128K = "GPT45_PREVIEW_128K"
    GPT45_PREVIEW_128K_20250227 = "GPT45_PREVIEW_128K_20250227"
    O1_MINI_128K = "O1_MINI_128K"
    O1_MINI_128K_20240912 = "O1_MINI_128K_20240912"
    O1_PREVIEW_128K = "O1_PREVIEW_128K"
    O1_PREVIEW_128K_20240912 = "O1_PREVIEW_128K_20240912"
    O1_200K = "O1_200K"
    O1_200K_20241217 = "O1_200K_20241217"
    O3_MINI_200K = "O3_MINI_200K"
    O3_MINI_200K_20250131 = "O3_MINI_200K_20250131"
    O3_200K = "O3_200K"
    O3_200K_20250416 = "O3_200K_20250416"
    O4_MINI_200K = "O4_MINI_200K"
    O4_MINI_200K_20250416 = "O4_MINI_200K_20250416"
    ADA_002 = "ADA_002"
    EMBEDDING_3_SMALL = "EMBEDDING_3_SMALL"
    EMBEDDING_3_LARGE = "EMBEDDING_3_LARGE"
    CUSTOM = "CUSTOM"


class ConversationStrategyTypes(str, Enum):
    WINDOWED = "WINDOWED"
    SUMMARIZED = "SUMMARIZED"


class AzureOpenAIModels(str, Enum):
    GPT35_TURBO_16K = "GPT35_TURBO_16K"
    GPT4 = "GPT4"
    GPT4_TURBO_128K = "GPT4_TURBO_128K"
    CUSTOM = "CUSTOM"


class EntityEnrichmentServiceTypes(str, Enum):
    DIFFBOT = "DIFFBOT"
    WIKIPEDIA = "WIKIPEDIA"
    CRUNCHBASE = "CRUNCHBASE"
    FHIR = "FHIR"


class SummarizationTypes(str, Enum):
    SUMMARY = "SUMMARY"
    KEYWORDS = "KEYWORDS"
    BULLETS = "BULLETS"
    HEADLINES = "HEADLINES"
    POSTS = "POSTS"
    CHAPTERS = "CHAPTERS"
    QUESTIONS = "QUESTIONS"
    CUSTOM = "CUSTOM"


class EntityState(str, Enum):
    INITIALIZED = "INITIALIZED"
    RESTARTED = "RESTARTED"
    CREATED = "CREATED"
    INGESTED = "INGESTED"
    INDEXED = "INDEXED"
    PREPARED = "PREPARED"
    SANITIZED = "SANITIZED"
    EXTRACTED = "EXTRACTED"
    ENRICHED = "ENRICHED"
    CLASSIFIED = "CLASSIFIED"
    CHANGED = "CHANGED"
    ARCHIVED = "ARCHIVED"
    APPROVED = "APPROVED"
    REJECTED = "REJECTED"
    PENDING = "PENDING"
    QUEUED = "QUEUED"
    OPENED = "OPENED"
    CLOSED = "CLOSED"
    FINISHED = "FINISHED"
    PAUSED = "PAUSED"
    RUNNING = "RUNNING"
    SUBSCRIBED = "SUBSCRIBED"
    ERRORED = "ERRORED"
    ENABLED = "ENABLED"
    DISABLED = "DISABLED"
    DELETED = "DELETED"


class ContentFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"
    ORIGINAL_DATE = "ORIGINAL_DATE"
    OBSERVABLE = "OBSERVABLE"
    CONTENT_TYPE = "CONTENT_TYPE"
    FILE_TYPE = "FILE_TYPE"
    FORMAT = "FORMAT"
    FORMAT_NAME = "FORMAT_NAME"
    FILE_EXTENSION = "FILE_EXTENSION"
    FILE_SIZE = "FILE_SIZE"
    DEVICE_TYPE = "DEVICE_TYPE"
    IMAGE_MAKE = "IMAGE_MAKE"
    IMAGE_MODEL = "IMAGE_MODEL"
    IMAGE_SOFTWARE = "IMAGE_SOFTWARE"
    AUDIO_AUTHOR = "AUDIO_AUTHOR"
    AUDIO_SERIES = "AUDIO_SERIES"
    AUDIO_PUBLISHER = "AUDIO_PUBLISHER"
    VIDEO_MAKE = "VIDEO_MAKE"
    VIDEO_MODEL = "VIDEO_MODEL"
    VIDEO_SOFTWARE = "VIDEO_SOFTWARE"
    DOCUMENT_AUTHOR = "DOCUMENT_AUTHOR"
    DOCUMENT_PUBLISHER = "DOCUMENT_PUBLISHER"
    DOCUMENT_IS_ENCRYPTED = "DOCUMENT_IS_ENCRYPTED"
    DOCUMENT_HAS_DIGITAL_SIGNATURE = "DOCUMENT_HAS_DIGITAL_SIGNATURE"
    EMAIL_PRIORITY = "EMAIL_PRIORITY"
    EMAIL_SENSITIVITY = "EMAIL_SENSITIVITY"
    ISSUE_PROJECT = "ISSUE_PROJECT"
    ISSUE_TEAM = "ISSUE_TEAM"
    ISSUE_PRIORITY = "ISSUE_PRIORITY"
    ISSUE_STATUS = "ISSUE_STATUS"
    ISSUE_TYPE = "ISSUE_TYPE"


class MedicalDrugClassFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class ConversationSearchTypes(str, Enum):
    NONE = "NONE"
    VECTOR = "VECTOR"
    HYBRID = "HYBRID"


class H3ResolutionTypes(str, Enum):
    R0 = "R0"
    R1 = "R1"
    R2 = "R2"
    R3 = "R3"
    R4 = "R4"
    R5 = "R5"
    R6 = "R6"
    R7 = "R7"
    R8 = "R8"
    R9 = "R9"
    R10 = "R10"
    R11 = "R11"
    R12 = "R12"
    R13 = "R13"
    R14 = "R14"
    R15 = "R15"


class AssemblyAIModels(str, Enum):
    BEST = "BEST"
    NANO = "NANO"


class ContentTypes(str, Enum):
    FILE = "FILE"
    PAGE = "PAGE"
    MESSAGE = "MESSAGE"
    TEXT = "TEXT"
    POST = "POST"
    EMAIL = "EMAIL"
    EVENT = "EVENT"
    ISSUE = "ISSUE"
    MEMORY = "MEMORY"


class CerebrasModels(str, Enum):
    LLAMA_3_3_70B = "LLAMA_3_3_70B"
    LLAMA_3_1_8B = "LLAMA_3_1_8B"
    CUSTOM = "CUSTOM"


class TextTypes(str, Enum):
    PLAIN = "PLAIN"
    MARKDOWN = "MARKDOWN"
    HTML = "HTML"


class OperationTypes(str, Enum):
    QUERY = "QUERY"
    MUTATION = "MUTATION"


class ContentIndexingServiceTypes(str, Enum):
    AZURE_AI_LANGUAGE = "AZURE_AI_LANGUAGE"


class OrganizationFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class OpenAIImageModels(str, Enum):
    GPT_IMAGE_1 = "GPT_IMAGE_1"
    CUSTOM = "CUSTOM"


class LabelFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class SiteTypes(str, Enum):
    WATCH = "WATCH"
    SWEEP = "SWEEP"
    STORAGE = "STORAGE"


class ModelServiceTypes(str, Enum):
    GOOGLE = "GOOGLE"
    ANTHROPIC = "ANTHROPIC"
    AZURE_AI = "AZURE_AI"
    AZURE_OPEN_AI = "AZURE_OPEN_AI"
    OPEN_AI = "OPEN_AI"
    REPLICATE = "REPLICATE"
    GROQ = "GROQ"
    CEREBRAS = "CEREBRAS"
    MISTRAL = "MISTRAL"
    COHERE = "COHERE"
    DEEPSEEK = "DEEPSEEK"
    JINA = "JINA"
    VOYAGE = "VOYAGE"
    BEDROCK = "BEDROCK"


class MedicalStudyFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class CollectionTypes(str, Enum):
    COLLECTION = "COLLECTION"
    THREAD = "THREAD"


class MedicalDeviceFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class AlertTypes(str, Enum):
    PROMPT = "PROMPT"


class RetrievalStrategyTypes(str, Enum):
    CONTENT = "CONTENT"
    CHUNK = "CHUNK"
    SECTION = "SECTION"


class SearchQueryTypes(str, Enum):
    SIMPLE = "SIMPLE"
    FULL = "FULL"


class IntegrationServiceTypes(str, Enum):
    SLACK = "SLACK"
    WEB_HOOK = "WEB_HOOK"
    EMAIL = "EMAIL"
    TWITTER = "TWITTER"


class LinkTypes(str, Enum):
    DROPBOX = "DROPBOX"
    TYPE_FORM = "TYPE_FORM"
    AIRTABLE = "AIRTABLE"
    MICROSOFT_TEAMS = "MICROSOFT_TEAMS"
    DISCORD = "DISCORD"
    APPLE = "APPLE"
    SLACK = "SLACK"
    ANGEL_LIST = "ANGEL_LIST"
    CRUNCHBASE = "CRUNCHBASE"
    LINKED_IN = "LINKED_IN"
    DIFFBOT = "DIFFBOT"
    REDDIT = "REDDIT"
    GOOGLE = "GOOGLE"
    IFTTT = "IFTTT"
    FACEBOOK = "FACEBOOK"
    WIKIPEDIA = "WIKIPEDIA"
    WIKIMEDIA = "WIKIMEDIA"
    WIKIDATA = "WIKIDATA"
    INSTAGRAM = "INSTAGRAM"
    TWITCH = "TWITCH"
    POCKET_CASTS = "POCKET_CASTS"
    SPOTIFY = "SPOTIFY"
    TUNE_IN = "TUNE_IN"
    STITCHER = "STITCHER"
    ANCHOR_FM = "ANCHOR_FM"
    TRANSISTOR_FM = "TRANSISTOR_FM"
    I_TUNES = "I_TUNES"
    PANDORA = "PANDORA"
    SOUND_CLOUD = "SOUND_CLOUD"
    BANDCAMP = "BANDCAMP"
    TIK_TOK = "TIK_TOK"
    YOU_TUBE = "YOU_TUBE"
    TWITTER = "TWITTER"
    X = "X"
    MEDIUM = "MEDIUM"
    NOTION = "NOTION"
    LINEAR = "LINEAR"
    GIT_HUB = "GIT_HUB"
    GIT_HUB_PAGES = "GIT_HUB_PAGES"
    RSS = "RSS"
    EMAIL = "EMAIL"
    MEDIA = "MEDIA"
    WEB = "WEB"
    FILE = "FILE"


class PlaceFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class MailImportance(str, Enum):
    NORMAL = "NORMAL"
    LOW = "LOW"
    HIGH = "HIGH"


class MedicalProcedureFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class SdkTypes(str, Enum):
    DOTNET = "DOTNET"
    PYTHON = "PYTHON"
    NODE_JS = "NODE_JS"


class TwitterListingTypes(str, Enum):
    POSTS = "POSTS"
    MENTIONS = "MENTIONS"
    RECENT_SEARCH = "RECENT_SEARCH"


class ApplyPolicy(str, Enum):
    BEFORE_RESOLVER = "BEFORE_RESOLVER"
    AFTER_RESOLVER = "AFTER_RESOLVER"
    VALIDATION = "VALIDATION"


class SpecificationTypes(str, Enum):
    COMPLETION = "COMPLETION"
    TEXT_EMBEDDING = "TEXT_EMBEDDING"
    IMAGE_EMBEDDING = "IMAGE_EMBEDDING"
    EXTRACTION = "EXTRACTION"
    CLASSIFICATION = "CLASSIFICATION"
    PREPARATION = "PREPARATION"


class PersonFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class FeedServiceTypes(str, Enum):
    GOOGLE_BLOB = "GOOGLE_BLOB"
    S3_BLOB = "S3_BLOB"
    AZURE_BLOB = "AZURE_BLOB"
    AZURE_FILE = "AZURE_FILE"
    SHARE_POINT = "SHARE_POINT"
    ONE_DRIVE = "ONE_DRIVE"
    GOOGLE_DRIVE = "GOOGLE_DRIVE"
    DROPBOX = "DROPBOX"
    BOX = "BOX"
    GOOGLE_EMAIL = "GOOGLE_EMAIL"
    MICROSOFT_EMAIL = "MICROSOFT_EMAIL"
    ATLASSIAN_JIRA = "ATLASSIAN_JIRA"
    TRELLO = "TRELLO"
    LINEAR = "LINEAR"
    GIT_HUB_ISSUES = "GIT_HUB_ISSUES"
    GIT_HUB = "GIT_HUB"
    INTERCOM_ARTICLES = "INTERCOM_ARTICLES"
    ZENDESK_ARTICLES = "ZENDESK_ARTICLES"
    INTERCOM_TICKETS = "INTERCOM_TICKETS"
    ZENDESK_TICKETS = "ZENDESK_TICKETS"


class MedicalDrugFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class StoragePolicyTypes(str, Enum):
    ARCHIVE = "ARCHIVE"
    MINIMIZE = "MINIMIZE"


class MedicalTherapyFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class RerankingModelServiceTypes(str, Enum):
    COHERE = "COHERE"
    JINA = "JINA"
    VOYAGE = "VOYAGE"


class EntityTypes(str, Enum):
    ACTIVITY = "ACTIVITY"
    ALERT = "ALERT"
    CATEGORY = "CATEGORY"
    COLLECTION = "COLLECTION"
    CONNECTOR = "CONNECTOR"
    CONTENT = "CONTENT"
    CONVERSATION = "CONVERSATION"
    EVENT = "EVENT"
    FEED = "FEED"
    JOB = "JOB"
    LABEL = "LABEL"
    METADATA = "METADATA"
    MEDICAL_STUDY = "MEDICAL_STUDY"
    MEDICAL_CONDITION = "MEDICAL_CONDITION"
    MEDICAL_GUIDELINE = "MEDICAL_GUIDELINE"
    MEDICAL_DRUG = "MEDICAL_DRUG"
    MEDICAL_DRUG_CLASS = "MEDICAL_DRUG_CLASS"
    MEDICAL_INDICATION = "MEDICAL_INDICATION"
    MEDICAL_CONTRAINDICATION = "MEDICAL_CONTRAINDICATION"
    MEDICAL_TEST = "MEDICAL_TEST"
    MEDICAL_DEVICE = "MEDICAL_DEVICE"
    MEDICAL_THERAPY = "MEDICAL_THERAPY"
    MEDICAL_PROCEDURE = "MEDICAL_PROCEDURE"
    OBSERVATION = "OBSERVATION"
    ORGANIZATION = "ORGANIZATION"
    PERSON = "PERSON"
    PLACE = "PLACE"
    PRODUCT = "PRODUCT"
    PROJECT = "PROJECT"
    RENDITION = "RENDITION"
    REPO = "REPO"
    SITE = "SITE"
    SOFTWARE = "SOFTWARE"
    SPECIFICATION = "SPECIFICATION"
    USER = "USER"
    WORKFLOW = "WORKFLOW"


class ModelTypes(str, Enum):
    COMPLETION = "COMPLETION"
    TEXT_EMBEDDING = "TEXT_EMBEDDING"
    IMAGE_EMBEDDING = "IMAGE_EMBEDDING"
    MULTIMODAL_EMBEDDING = "MULTIMODAL_EMBEDDING"
    RERANKING = "RERANKING"


class AzureDocumentIntelligenceModels(str, Enum):
    READ_OCR = "READ_OCR"
    LAYOUT = "LAYOUT"
    INVOICE = "INVOICE"
    RECEIPT = "RECEIPT"
    IDENTIFICATION_DOCUMENT = "IDENTIFICATION_DOCUMENT"
    US_HEALTH_INSURANCE_CARD = "US_HEALTH_INSURANCE_CARD"
    US_TAX_FORM = "US_TAX_FORM"
    US_TAX_FORM_W2 = "US_TAX_FORM_W2"
    US_TAX_FORM1098 = "US_TAX_FORM1098"
    US_TAX_FORM1098_E = "US_TAX_FORM1098_E"
    US_TAX_FORM1098_T = "US_TAX_FORM1098_T"
    US_TAX_FORM1099 = "US_TAX_FORM1099"
    US_MARRIAGE_CERTIFICATE = "US_MARRIAGE_CERTIFICATE"
    US_MORTGAGE1003 = "US_MORTGAGE1003"
    US_MORTGAGE1008 = "US_MORTGAGE1008"
    US_MORTGAGE_DISCLOSURE = "US_MORTGAGE_DISCLOSURE"
    CREDIT_CARD = "CREDIT_CARD"
    US_PAY_STUB = "US_PAY_STUB"
    US_BANK_CHECK = "US_BANK_CHECK"
    US_BANK_STATEMENT = "US_BANK_STATEMENT"


class SearchTypes(str, Enum):
    KEYWORD = "KEYWORD"
    VECTOR = "VECTOR"
    HYBRID = "HYBRID"


class NotionTypes(str, Enum):
    PAGE = "PAGE"
    DATABASE = "DATABASE"


class OrderDirectionTypes(str, Enum):
    ASCENDING = "ASCENDING"
    DESCENDING = "DESCENDING"


class MedicalTestFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class CategoryFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class ImageProjectionTypes(str, Enum):
    EQUIRECTANGULAR = "EQUIRECTANGULAR"
    CYLINDRICAL = "CYLINDRICAL"


class PolicyTimeTypes(str, Enum):
    RELATIVE_TIME = "RELATIVE_TIME"
    ABSOLUTE_TIME = "ABSOLUTE_TIME"


class ElevenLabsModels(str, Enum):
    MULTILINGUAL_V1 = "MULTILINGUAL_V1"
    MULTILINGUAL_V2 = "MULTILINGUAL_V2"
    ENGLISH_V1 = "ENGLISH_V1"
    FLASH_V2 = "FLASH_V2"
    FLASH_V2_5 = "FLASH_V2_5"
    TURBO_V2 = "TURBO_V2"
    TURBO_V2_5 = "TURBO_V2_5"


class OccurrenceTypes(str, Enum):
    IMAGE = "IMAGE"
    TIME = "TIME"
    TEXT = "TEXT"


class BedrockModels(str, Enum):
    LLAMA_4_MAVERICK_17B = "LLAMA_4_MAVERICK_17B"
    LLAMA_4_SCOUT_17B = "LLAMA_4_SCOUT_17B"
    CLAUDE_3_7_SONNET = "CLAUDE_3_7_SONNET"
    NOVA_PREMIER = "NOVA_PREMIER"
    NOVA_PRO = "NOVA_PRO"
    CUSTOM = "CUSTOM"


class ContentSourceTypes(str, Enum):
    FRAME = "FRAME"
    DOCUMENT = "DOCUMENT"
    TRANSCRIPT = "TRANSCRIPT"


class MedicalIndicationFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class YouTubeTypes(str, Enum):
    VIDEO = "VIDEO"
    VIDEOS = "VIDEOS"
    PLAYLIST = "PLAYLIST"
    CHANNEL = "CHANNEL"


class OrientationTypes(str, Enum):
    TOP_LEFT = "TOP_LEFT"
    TOP_RIGHT = "TOP_RIGHT"
    BOTTOM_RIGHT = "BOTTOM_RIGHT"
    BOTTOM_LEFT = "BOTTOM_LEFT"
    LEFT_TOP = "LEFT_TOP"
    RIGHT_TOP = "RIGHT_TOP"
    RIGHT_BOTTOM = "RIGHT_BOTTOM"
    LEFT_BOTTOM = "LEFT_BOTTOM"


class TrelloTypes(str, Enum):
    CARD = "CARD"
    BOARD = "BOARD"


class EmailListingTypes(str, Enum):
    PAST = "PAST"
    NEW = "NEW"


class TimeIntervalTypes(str, Enum):
    MINUTE = "MINUTE"
    HOUR = "HOUR"
    DAY = "DAY"
    WEEK = "WEEK"
    MONTH = "MONTH"
    QUARTER = "QUARTER"
    YEAR = "YEAR"


class EventFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class DeviceTypes(str, Enum):
    DRONE = "DRONE"
    ROBOT = "ROBOT"
    MOBILE = "MOBILE"
    CAMERA = "CAMERA"
    STREAM = "STREAM"
    SCREEN = "SCREEN"
    GEOSPATIAL = "GEOSPATIAL"
    UNKNOWN = "UNKNOWN"


class EnvironmentTypes(str, Enum):
    DEVELOPMENT = "DEVELOPMENT"
    PRODUCTION = "PRODUCTION"


class MailPriority(str, Enum):
    NORMAL = "NORMAL"
    LOW = "LOW"
    HIGH = "HIGH"


class SharePointAuthenticationTypes(str, Enum):
    APPLICATION = "APPLICATION"
    USER = "USER"


class FeedConnectorTypes(str, Enum):
    GOOGLE = "GOOGLE"
    AMAZON = "AMAZON"
    AZURE = "AZURE"
    SHARE_POINT = "SHARE_POINT"
    ONE_DRIVE = "ONE_DRIVE"
    GOOGLE_DRIVE = "GOOGLE_DRIVE"
    DROPBOX = "DROPBOX"
    BOX = "BOX"
    GOOGLE_EMAIL = "GOOGLE_EMAIL"
    MICROSOFT_EMAIL = "MICROSOFT_EMAIL"
    ATLASSIAN = "ATLASSIAN"
    LINEAR = "LINEAR"
    GIT_HUB = "GIT_HUB"
    INTERCOM = "INTERCOM"
    ZENDESK = "ZENDESK"


class ProductFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class FileTypes(str, Enum):
    VIDEO = "VIDEO"
    AUDIO = "AUDIO"
    IMAGE = "IMAGE"
    ANIMATION = "ANIMATION"
    DOCUMENT = "DOCUMENT"
    EMAIL = "EMAIL"
    CODE = "CODE"
    DATA = "DATA"
    PACKAGE = "PACKAGE"
    SHAPE = "SHAPE"
    POINT_CLOUD = "POINT_CLOUD"
    GEOMETRY = "GEOMETRY"
    DRAWING = "DRAWING"
    MANIFEST = "MANIFEST"
    UNKNOWN = "UNKNOWN"


class VoyageModels(str, Enum):
    VOYAGE = "VOYAGE"
    VOYAGE_3_0_LARGE = "VOYAGE_3_0_LARGE"
    VOYAGE_3_0 = "VOYAGE_3_0"
    VOYAGE_LITE_3_0 = "VOYAGE_LITE_3_0"
    VOYAGE_CODE_3_0 = "VOYAGE_CODE_3_0"
    VOYAGE_FINANCE_2_0 = "VOYAGE_FINANCE_2_0"
    VOYAGE_MULTILINGUAL_2_0 = "VOYAGE_MULTILINGUAL_2_0"
    VOYAGE_LAW_2_0 = "VOYAGE_LAW_2_0"
    VOYAGE_CODE_2_0 = "VOYAGE_CODE_2_0"
    CUSTOM = "CUSTOM"


class GroqModels(str, Enum):
    LLAMA_4_MAVERICK_17B = "LLAMA_4_MAVERICK_17B"
    LLAMA_4_SCOUT_17B = "LLAMA_4_SCOUT_17B"
    DEEPSEEK_R1_LLAMA_70B_PREVIEW = "DEEPSEEK_R1_LLAMA_70B_PREVIEW"
    MIXTRAL_8X7B_INSTRUCT = "MIXTRAL_8X7B_INSTRUCT"
    LLAMA_3_3_70B = "LLAMA_3_3_70B"
    LLAMA_3_2_90B_VISION_PREVIEW = "LLAMA_3_2_90B_VISION_PREVIEW"
    LLAMA_3_2_11B_VISION_PREVIEW = "LLAMA_3_2_11B_VISION_PREVIEW"
    LLAMA_3_2_3B_PREVIEW = "LLAMA_3_2_3B_PREVIEW"
    LLAMA_3_2_1B_PREVIEW = "LLAMA_3_2_1B_PREVIEW"
    LLAMA_3_1_8B = "LLAMA_3_1_8B"
    LLAMA_3_70B = "LLAMA_3_70B"
    LLAMA_3_8B = "LLAMA_3_8B"
    CUSTOM = "CUSTOM"


class PromptStrategyTypes(str, Enum):
    OPTIMIZE_SEARCH = "OPTIMIZE_SEARCH"
    REWRITE = "REWRITE"
    NONE = "NONE"


class GoogleDriveAuthenticationTypes(str, Enum):
    SERVICE_ACCOUNT = "SERVICE_ACCOUNT"
    USER = "USER"


class AzureDocumentIntelligenceVersions(str, Enum):
    V2023_07_31 = "V2023_07_31"
    V2024_02_29_PREVIEW = "V2024_02_29_PREVIEW"
    V2024_07_31_PREVIEW = "V2024_07_31_PREVIEW"
    V2024_11_30 = "V2024_11_30"


class MailSensitivity(str, Enum):
    NONE = "NONE"
    NORMAL = "NORMAL"
    PERSONAL = "PERSONAL"
    PRIVATE = "PRIVATE"
    COMPANY_CONFIDENTIAL = "COMPANY_CONFIDENTIAL"


class DeepseekModels(str, Enum):
    REASONER = "REASONER"
    CHAT = "CHAT"
    CODER = "CODER"
    CUSTOM = "CUSTOM"


class SearchServiceTypes(str, Enum):
    TAVILY = "TAVILY"
    EXA = "EXA"
    PODSCAN = "PODSCAN"


class MedicalContraindicationFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class RepoFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class GraphStrategyTypes(str, Enum):
    EXTRACT_ENTITIES_FILTER = "EXTRACT_ENTITIES_FILTER"
    EXTRACT_ENTITIES_GRAPH = "EXTRACT_ENTITIES_GRAPH"
    NONE = "NONE"


class JinaModels(str, Enum):
    CLIP_IMAGE = "CLIP_IMAGE"
    EMBED = "EMBED"
    EMBED_3_0 = "EMBED_3_0"
    CUSTOM = "CUSTOM"


class UnitTypes(str, Enum):
    KILOMETER = "KILOMETER"
    METER = "METER"
    CENTIMETER = "CENTIMETER"
    MILLIMETER = "MILLIMETER"
    MICROMETER = "MICROMETER"
    NANOMETER = "NANOMETER"
    ANGSTROM = "ANGSTROM"
    DECIMETER = "DECIMETER"
    DECAMETER = "DECAMETER"
    HECTOMETER = "HECTOMETER"
    GIGAMETER = "GIGAMETER"
    ASTRONOMICAL_UNIT = "ASTRONOMICAL_UNIT"
    LIGHT_YEAR = "LIGHT_YEAR"
    PARSEC = "PARSEC"
    MILE = "MILE"
    YARD = "YARD"
    FOOT = "FOOT"
    INCH = "INCH"
    MIL = "MIL"
    MICRO_INCH = "MICRO_INCH"
    CUSTOM = "CUSTOM"
    UNITLESS = "UNITLESS"


class ConversationTypes(str, Enum):
    CONTENT = "CONTENT"


class MedicalConditionFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class SoftwareFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class ResourceConnectorTypes(str, Enum):
    AMAZON = "AMAZON"
    AZURE = "AZURE"
    GOOGLE = "GOOGLE"


class ReplicateModels(str, Enum):
    MISTRAL_7B = "MISTRAL_7B"
    MISTRAL_7B_INSTRUCT = "MISTRAL_7B_INSTRUCT"
    LLAMA_2_7B = "LLAMA_2_7B"
    LLAMA_2_13B = "LLAMA_2_13B"
    LLAMA_2_70B = "LLAMA_2_70B"
    LLAMA_2_7B_CHAT = "LLAMA_2_7B_CHAT"
    LLAMA_2_13B_CHAT = "LLAMA_2_13B_CHAT"
    LLAMA_2_70B_CHAT = "LLAMA_2_70B_CHAT"
    CUSTOM = "CUSTOM"


class FilePreparationServiceTypes(str, Enum):
    AZURE_DOCUMENT_INTELLIGENCE = "AZURE_DOCUMENT_INTELLIGENCE"
    DEEPGRAM = "DEEPGRAM"
    DOCUMENT = "DOCUMENT"
    EMAIL = "EMAIL"
    PAGE = "PAGE"
    MODEL_DOCUMENT = "MODEL_DOCUMENT"
    ASSEMBLY_AI = "ASSEMBLY_AI"
    MISTRAL_DOCUMENT = "MISTRAL_DOCUMENT"


class RegexSourceTypes(str, Enum):
    MARKDOWN = "MARKDOWN"
    METADATA = "METADATA"


class FacetValueTypes(str, Enum):
    VALUE = "VALUE"
    RANGE = "RANGE"
    OBJECT = "OBJECT"


class BillableMetrics(str, Enum):
    BYTES = "BYTES"
    TOKENS = "TOKENS"
    LENGTH = "LENGTH"
    TIME = "TIME"
    UNITS = "UNITS"
    COST = "COST"
    REQUESTS = "REQUESTS"
    CREDITS = "CREDITS"


class CohereModels(str, Enum):
    EMBED_ENGLISH_3_0 = "EMBED_ENGLISH_3_0"
    EMBED_MULTILINGUAL_3_0 = "EMBED_MULTILINGUAL_3_0"
    COMMAND_R = "COMMAND_R"
    COMMAND_R_202403 = "COMMAND_R_202403"
    COMMAND_R_202408 = "COMMAND_R_202408"
    COMMAND_R_PLUS = "COMMAND_R_PLUS"
    COMMAND_R_PLUS_202404 = "COMMAND_R_PLUS_202404"
    COMMAND_R_PLUS_202408 = "COMMAND_R_PLUS_202408"
    COMMAND_R7_B_202412 = "COMMAND_R7_B_202412"
    COMMAND_A = "COMMAND_A"
    COMMAND_A_202503 = "COMMAND_A_202503"
    CUSTOM = "CUSTOM"


class TimedPolicyRecurrenceTypes(str, Enum):
    ONCE = "ONCE"
    REPEAT = "REPEAT"


class MedicalGuidelineFacetTypes(str, Enum):
    CREATION_DATE = "CREATION_DATE"


class DeepgramModels(str, Enum):
    NOVA3 = "NOVA3"
    NOVA2 = "NOVA2"
    NOVA2_MEETING = "NOVA2_MEETING"
    NOVA2_PHONECALL = "NOVA2_PHONECALL"
    NOVA2_VOICEMAIL = "NOVA2_VOICEMAIL"
    NOVA2_FINANCE = "NOVA2_FINANCE"
    NOVA2_CONVERSATIONAL_AI = "NOVA2_CONVERSATIONAL_AI"
    NOVA2_VIDEO = "NOVA2_VIDEO"
    NOVA2_MEDICAL = "NOVA2_MEDICAL"
    NOVA2_DRIVETHRU = "NOVA2_DRIVETHRU"
    NOVA2_AUTOMOTIVE = "NOVA2_AUTOMOTIVE"
    WHISPER_TINY = "WHISPER_TINY"
    WHISPER_SMALL = "WHISPER_SMALL"
    WHISPER_BASE = "WHISPER_BASE"
    WHISPER_MEDIUM = "WHISPER_MEDIUM"
    WHISPER_LARGE = "WHISPER_LARGE"


class OpenAIReasoningEffortLevels(str, Enum):
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"


class FeedTypes(str, Enum):
    INTERCOM = "INTERCOM"
    ZENDESK = "ZENDESK"
    NOTION = "NOTION"
    TWITTER = "TWITTER"
    SLACK = "SLACK"
    MICROSOFT_TEAMS = "MICROSOFT_TEAMS"
    DISCORD = "DISCORD"
    REDDIT = "REDDIT"
    WEB = "WEB"
    RSS = "RSS"
    SITE = "SITE"
    YOU_TUBE = "YOU_TUBE"
    EMAIL = "EMAIL"
    ISSUE = "ISSUE"
    SEARCH = "SEARCH"


class AnthropicModels(str, Enum):
    CLAUDE_2 = "CLAUDE_2"
    CLAUDE_2_0 = "CLAUDE_2_0"
    CLAUDE_2_1 = "CLAUDE_2_1"
    CLAUDE_INSTANT_1 = "CLAUDE_INSTANT_1"
    CLAUDE_INSTANT_1_2 = "CLAUDE_INSTANT_1_2"
    CLAUDE_3_OPUS = "CLAUDE_3_OPUS"
    CLAUDE_3_OPUS_20240229 = "CLAUDE_3_OPUS_20240229"
    CLAUDE_3_SONNET = "CLAUDE_3_SONNET"
    CLAUDE_3_SONNET_20240229 = "CLAUDE_3_SONNET_20240229"
    CLAUDE_3_HAIKU = "CLAUDE_3_HAIKU"
    CLAUDE_3_HAIKU_20240307 = "CLAUDE_3_HAIKU_20240307"
    CLAUDE_3_5_SONNET = "CLAUDE_3_5_SONNET"
    CLAUDE_3_5_SONNET_20241022 = "CLAUDE_3_5_SONNET_20241022"
    CLAUDE_3_5_SONNET_20240620 = "CLAUDE_3_5_SONNET_20240620"
    CLAUDE_3_5_HAIKU = "CLAUDE_3_5_HAIKU"
    CLAUDE_3_5_HAIKU_20241022 = "CLAUDE_3_5_HAIKU_20241022"
    CLAUDE_3_7_SONNET = "CLAUDE_3_7_SONNET"
    CLAUDE_3_7_SONNET_20250219 = "CLAUDE_3_7_SONNET_20250219"
    CLAUDE_4_SONNET = "CLAUDE_4_SONNET"
    CLAUDE_4_SONNET_20250514 = "CLAUDE_4_SONNET_20250514"
    CLAUDE_4_OPUS = "CLAUDE_4_OPUS"
    CLAUDE_4_OPUS_20250514 = "CLAUDE_4_OPUS_20250514"
    CUSTOM = "CUSTOM"


class OpenAIVisionDetailLevels(str, Enum):
    HIGH = "HIGH"
    LOW = "LOW"


class FeedListingTypes(str, Enum):
    PAST = "PAST"
    NEW = "NEW"


class MetadataTypes(str, Enum):
    CONTENT = "CONTENT"


class ObservableTypes(str, Enum):
    CATEGORY = "CATEGORY"
    LABEL = "LABEL"
    EVENT = "EVENT"
    ORGANIZATION = "ORGANIZATION"
    PERSON = "PERSON"
    PLACE = "PLACE"
    PRODUCT = "PRODUCT"
    REPO = "REPO"
    SOFTWARE = "SOFTWARE"
    MEDICAL_STUDY = "MEDICAL_STUDY"
    MEDICAL_CONDITION = "MEDICAL_CONDITION"
    MEDICAL_GUIDELINE = "MEDICAL_GUIDELINE"
    MEDICAL_DRUG = "MEDICAL_DRUG"
    MEDICAL_DRUG_CLASS = "MEDICAL_DRUG_CLASS"
    MEDICAL_INDICATION = "MEDICAL_INDICATION"
    MEDICAL_CONTRAINDICATION = "MEDICAL_CONTRAINDICATION"
    MEDICAL_TEST = "MEDICAL_TEST"
    MEDICAL_DEVICE = "MEDICAL_DEVICE"
    MEDICAL_THERAPY = "MEDICAL_THERAPY"
    MEDICAL_PROCEDURE = "MEDICAL_PROCEDURE"


class GoogleModels(str, Enum):
    GEMINI_2_5_PRO_PREVIEW = "GEMINI_2_5_PRO_PREVIEW"
    GEMINI_2_5_PRO_EXPERIMENTAL = "GEMINI_2_5_PRO_EXPERIMENTAL"
    GEMINI_2_5_FLASH_PREVIEW = "GEMINI_2_5_FLASH_PREVIEW"
    GEMINI_2_0_PRO_EXPERIMENTAL = "GEMINI_2_0_PRO_EXPERIMENTAL"
    GEMINI_2_0_FLASH_THINKING_EXPERIMENTAL = "GEMINI_2_0_FLASH_THINKING_EXPERIMENTAL"
    GEMINI_2_0_FLASH_EXPERIMENTAL = "GEMINI_2_0_FLASH_EXPERIMENTAL"
    GEMINI_2_0_FLASH = "GEMINI_2_0_FLASH"
    GEMINI_2_0_FLASH_001 = "GEMINI_2_0_FLASH_001"
    GEMINI_1_5_FLASH_8B = "GEMINI_1_5_FLASH_8B"
    GEMINI_1_5_FLASH_8B_001 = "GEMINI_1_5_FLASH_8B_001"
    GEMINI_1_5_FLASH = "GEMINI_1_5_FLASH"
    GEMINI_1_5_FLASH_001 = "GEMINI_1_5_FLASH_001"
    GEMINI_1_5_PRO = "GEMINI_1_5_PRO"
    GEMINI_1_5_PRO_001 = "GEMINI_1_5_PRO_001"
    GEMINI_1_5_FLASH_002 = "GEMINI_1_5_FLASH_002"
    GEMINI_1_5_PRO_002 = "GEMINI_1_5_PRO_002"
    EMBEDDING_004 = "EMBEDDING_004"
    CUSTOM = "CUSTOM"


class UserTypes(str, Enum):
    HUMAN = "HUMAN"
    AGENT = "AGENT"


class EntityExtractionServiceTypes(str, Enum):
    MODEL_TEXT = "MODEL_TEXT"
    MODEL_IMAGE = "MODEL_IMAGE"
    OPEN_AI_IMAGE = "OPEN_AI_IMAGE"
    AZURE_COGNITIVE_SERVICES_IMAGE = "AZURE_COGNITIVE_SERVICES_IMAGE"
    AZURE_COGNITIVE_SERVICES_TEXT = "AZURE_COGNITIVE_SERVICES_TEXT"


class ContentPublishingFormats(str, Enum):
    PNG = "PNG"
    JPEG = "JPEG"
    WEBP = "WEBP"
    MP3 = "MP3"
    TEXT = "TEXT"
    MARKDOWN = "MARKDOWN"
    HTML = "HTML"


class RenditionTypes(str, Enum):
    CONTENT = "CONTENT"


class MistralModels(str, Enum):
    MIXTRAL_8X7B_INSTRUCT = "MIXTRAL_8X7B_INSTRUCT"
    MISTRAL_NEMO = "MISTRAL_NEMO"
    MISTRAL_SMALL = "MISTRAL_SMALL"
    MISTRAL_MEDIUM = "MISTRAL_MEDIUM"
    MISTRAL_LARGE = "MISTRAL_LARGE"
    PIXTRAL_12B_2409 = "PIXTRAL_12B_2409"
    PIXTRAL_LARGE = "PIXTRAL_LARGE"
    MISTRAL_EMBED = "MISTRAL_EMBED"
    CUSTOM = "CUSTOM"


class ConversationRoleTypes(str, Enum):
    SYSTEM = "SYSTEM"
    ASSISTANT = "ASSISTANT"
    USER = "USER"
    TOOL = "TOOL"


class ConnectorTypes(str, Enum):
    INTEGRATION = "INTEGRATION"
    AUTHENTICATION = "AUTHENTICATION"


class TextRoles(str, Enum):
    PAGE_HEADER = "PAGE_HEADER"
    PAGE_FOOTER = "PAGE_FOOTER"
    PAGE_NUMBER = "PAGE_NUMBER"
    TITLE = "TITLE"
    SECTION_HEADING = "SECTION_HEADING"
    FOOTNOTE = "FOOTNOTE"
    CODE = "CODE"
    LIST_ITEM = "LIST_ITEM"
    HEADING1 = "HEADING1"
    HEADING2 = "HEADING2"
    HEADING3 = "HEADING3"
    HEADING4 = "HEADING4"
    HEADING5 = "HEADING5"
    HEADING6 = "HEADING6"
    TABLE_COLUMN_HEADER = "TABLE_COLUMN_HEADER"
    TABLE_ROW_HEADER = "TABLE_ROW_HEADER"
    TABLE_CORNER_HEADER = "TABLE_CORNER_HEADER"
    TABLE_CELL = "TABLE_CELL"
    TABLE_CAPTION = "TABLE_CAPTION"
    TABLE_HEADER = "TABLE_HEADER"
    TABLE = "TABLE"
    IMAGE = "IMAGE"
    IMAGE_CAPTION = "IMAGE_CAPTION"
    FIGURE = "FIGURE"
    FIGURE_CAPTION = "FIGURE_CAPTION"
    BUTTON = "BUTTON"
    DIAGRAM = "DIAGRAM"
    DIAGRAM_CAPTION = "DIAGRAM_CAPTION"
    WATERMARK = "WATERMARK"
    EQUATION = "EQUATION"
    PARAGRAPH = "PARAGRAPH"
    CHECKBOX = "CHECKBOX"
    RADIO_BUTTON = "RADIO_BUTTON"
    COLUMN_HEADER = "COLUMN_HEADER"
    ROW_HEADER = "ROW_HEADER"
    CORNER_HEADER = "CORNER_HEADER"


class ContentPublishingServiceTypes(str, Enum):
    ELEVEN_LABS_AUDIO = "ELEVEN_LABS_AUDIO"
    OPEN_AI_IMAGE = "OPEN_AI_IMAGE"
    TEXT = "TEXT"


class OrderByTypes(str, Enum):
    NAME = "NAME"
    CREATION_DATE = "CREATION_DATE"
    ORIGINAL_DATE = "ORIGINAL_DATE"
    RELEVANCE = "RELEVANCE"


class ContentClassificationServiceTypes(str, Enum):
    REGEX = "REGEX"
    MODEL = "MODEL"


class AuthenticationServiceTypes(str, Enum):
    AUTH0 = "AUTH0"
    MICROSOFT_GRAPH = "MICROSOFT_GRAPH"
    CLERK = "CLERK"
    GOOGLE = "GOOGLE"


class RevisionStrategyTypes(str, Enum):
    REVISE = "REVISE"
    CUSTOM = "CUSTOM"
    NONE = "NONE"



================================================
FILE: graphlit_api/exceptions.py
================================================
# Generated by ariadne-codegen

from typing import Any, Dict, List, Optional, Union

import httpx


class GraphQLClientError(Exception):
    """Base exception."""


class GraphQLClientHttpError(GraphQLClientError):
    def __init__(self, status_code: int, response: httpx.Response) -> None:
        self.status_code = status_code
        self.response = response

    def __str__(self) -> str:
        return f"HTTP status code: {self.status_code}\n{self.response.text}"


class GraphQLClientInvalidResponseError(GraphQLClientError):
    def __init__(self, response: httpx.Response) -> None:
        self.response = response

    def __str__(self) -> str:
        return "Invalid response format."


class GraphQLClientGraphQLError(GraphQLClientError):
    def __init__(
        self,
        message: str,
        locations: Optional[List[Dict[str, int]]] = None,
        path: Optional[List[str]] = None,
        extensions: Optional[Dict[str, object]] = None,
        orginal: Optional[Dict[str, object]] = None,
    ):
        self.message = message
        self.locations = locations
        self.path = path
        self.extensions = extensions
        self.orginal = orginal

    def __str__(self) -> str:
        return self.message

    @classmethod
    def from_dict(cls, error: Dict[str, Any]) -> "GraphQLClientGraphQLError":
        return cls(
            message=error["message"],
            locations=error.get("locations"),
            path=error.get("path"),
            extensions=error.get("extensions"),
            orginal=error,
        )


class GraphQLClientGraphQLMultiError(GraphQLClientError):
    def __init__(
        self,
        errors: List[GraphQLClientGraphQLError],
        data: Optional[Dict[str, Any]] = None,
    ):
        self.errors = errors
        self.data = data

    def __str__(self) -> str:
        return "; ".join(str(e) for e in self.errors)

    @classmethod
    def from_errors_dicts(
        cls, errors_dicts: List[Dict[str, Any]], data: Optional[Dict[str, Any]] = None
    ) -> "GraphQLClientGraphQLMultiError":
        return cls(
            errors=[GraphQLClientGraphQLError.from_dict(e) for e in errors_dicts],
            data=data,
        )


class GraphQLClientInvalidMessageFormat(GraphQLClientError):
    def __init__(self, message: Union[str, bytes]) -> None:
        self.message = message

    def __str__(self) -> str:
        return "Invalid message format."



================================================
FILE: graphlit_api/extract_contents.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class ExtractContents(BaseModel):
    extract_contents: Optional[List[Optional["ExtractContentsExtractContents"]]] = (
        Field(alias="extractContents")
    )


class ExtractContentsExtractContents(BaseModel):
    specification: Optional["ExtractContentsExtractContentsSpecification"]
    content: Optional["ExtractContentsExtractContentsContent"]
    name: str
    value: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    error: Optional[str]


class ExtractContentsExtractContentsSpecification(BaseModel):
    id: str


class ExtractContentsExtractContentsContent(BaseModel):
    id: str


ExtractContents.model_rebuild()
ExtractContentsExtractContents.model_rebuild()



================================================
FILE: graphlit_api/extract_text.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class ExtractText(BaseModel):
    extract_text: Optional[List[Optional["ExtractTextExtractText"]]] = Field(
        alias="extractText"
    )


class ExtractTextExtractText(BaseModel):
    specification: Optional["ExtractTextExtractTextSpecification"]
    content: Optional["ExtractTextExtractTextContent"]
    name: str
    value: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    error: Optional[str]


class ExtractTextExtractTextSpecification(BaseModel):
    id: str


class ExtractTextExtractTextContent(BaseModel):
    id: str


ExtractText.model_rebuild()
ExtractTextExtractText.model_rebuild()



================================================
FILE: graphlit_api/feed_exists.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class FeedExists(BaseModel):
    feed_exists: Optional["FeedExistsFeedExists"] = Field(alias="feedExists")


class FeedExistsFeedExists(BaseModel):
    result: Optional[bool]


FeedExists.model_rebuild()



================================================
FILE: graphlit_api/format_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentFacetTypes,
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    EntityTypes,
    FacetValueTypes,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    ObservableTypes,
    OrientationTypes,
)


class FormatConversation(BaseModel):
    format_conversation: Optional["FormatConversationFormatConversation"] = Field(
        alias="formatConversation"
    )


class FormatConversationFormatConversation(BaseModel):
    conversation: Optional["FormatConversationFormatConversationConversation"]
    message: Optional["FormatConversationFormatConversationMessage"]
    message_count: Optional[int] = Field(alias="messageCount")
    facets: Optional[List[Optional["FormatConversationFormatConversationFacets"]]]
    graph: Optional["FormatConversationFormatConversationGraph"]
    details: Optional["FormatConversationFormatConversationDetails"]


class FormatConversationFormatConversationConversation(BaseModel):
    id: str


class FormatConversationFormatConversationMessage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[Optional["FormatConversationFormatConversationMessageCitations"]]
    ]
    tool_calls: Optional[
        List[Optional["FormatConversationFormatConversationMessageToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class FormatConversationFormatConversationMessageCitations(BaseModel):
    content: Optional["FormatConversationFormatConversationMessageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class FormatConversationFormatConversationMessageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["FormatConversationFormatConversationMessageCitationsContentVideo"]
    audio: Optional["FormatConversationFormatConversationMessageCitationsContentAudio"]
    image: Optional["FormatConversationFormatConversationMessageCitationsContentImage"]
    document: Optional[
        "FormatConversationFormatConversationMessageCitationsContentDocument"
    ]


class FormatConversationFormatConversationMessageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class FormatConversationFormatConversationMessageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class FormatConversationFormatConversationMessageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class FormatConversationFormatConversationMessageCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class FormatConversationFormatConversationMessageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


class FormatConversationFormatConversationFacets(BaseModel):
    type: Optional[FacetValueTypes]
    value: Optional[str]
    range: Optional["FormatConversationFormatConversationFacetsRange"]
    count: Optional[Any]
    facet: Optional[ContentFacetTypes]
    observable: Optional["FormatConversationFormatConversationFacetsObservable"]


class FormatConversationFormatConversationFacetsRange(BaseModel):
    from_: Optional[str] = Field(alias="from")
    to: Optional[str]


class FormatConversationFormatConversationFacetsObservable(BaseModel):
    type: Optional[ObservableTypes]
    observable: Optional[
        "FormatConversationFormatConversationFacetsObservableObservable"
    ]


class FormatConversationFormatConversationFacetsObservableObservable(BaseModel):
    id: str
    name: Optional[str]


class FormatConversationFormatConversationGraph(BaseModel):
    nodes: Optional[List[Optional["FormatConversationFormatConversationGraphNodes"]]]
    edges: Optional[List[Optional["FormatConversationFormatConversationGraphEdges"]]]


class FormatConversationFormatConversationGraphNodes(BaseModel):
    id: str
    name: str
    type: EntityTypes
    metadata: Optional[str]


class FormatConversationFormatConversationGraphEdges(BaseModel):
    from_: str = Field(alias="from")
    to: str
    relation: Optional[str]


class FormatConversationFormatConversationDetails(BaseModel):
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    supports_tool_calling: Optional[bool] = Field(alias="supportsToolCalling")
    source_count: Optional[int] = Field(alias="sourceCount")
    observable_count: Optional[int] = Field(alias="observableCount")
    tool_count: Optional[int] = Field(alias="toolCount")
    rendered_source_count: Optional[int] = Field(alias="renderedSourceCount")
    rendered_observable_count: Optional[int] = Field(alias="renderedObservableCount")
    rendered_tool_count: Optional[int] = Field(alias="renderedToolCount")
    ranked_source_count: Optional[int] = Field(alias="rankedSourceCount")
    ranked_observable_count: Optional[int] = Field(alias="rankedObservableCount")
    ranked_tool_count: Optional[int] = Field(alias="rankedToolCount")
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    sources: Optional[str]
    formatted_sources: Optional[str] = Field(alias="formattedSources")
    formatted_observables: Optional[str] = Field(alias="formattedObservables")
    formatted_instructions: Optional[str] = Field(alias="formattedInstructions")
    formatted_tools: Optional[str] = Field(alias="formattedTools")
    specification: Optional[str]
    messages: Optional[
        List[Optional["FormatConversationFormatConversationDetailsMessages"]]
    ]


class FormatConversationFormatConversationDetailsMessages(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[Optional["FormatConversationFormatConversationDetailsMessagesCitations"]]
    ]
    tool_calls: Optional[
        List[Optional["FormatConversationFormatConversationDetailsMessagesToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class FormatConversationFormatConversationDetailsMessagesCitations(BaseModel):
    content: Optional[
        "FormatConversationFormatConversationDetailsMessagesCitationsContent"
    ]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class FormatConversationFormatConversationDetailsMessagesCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional[
        "FormatConversationFormatConversationDetailsMessagesCitationsContentVideo"
    ]
    audio: Optional[
        "FormatConversationFormatConversationDetailsMessagesCitationsContentAudio"
    ]
    image: Optional[
        "FormatConversationFormatConversationDetailsMessagesCitationsContentImage"
    ]
    document: Optional[
        "FormatConversationFormatConversationDetailsMessagesCitationsContentDocument"
    ]


class FormatConversationFormatConversationDetailsMessagesCitationsContentVideo(
    BaseModel
):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class FormatConversationFormatConversationDetailsMessagesCitationsContentAudio(
    BaseModel
):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class FormatConversationFormatConversationDetailsMessagesCitationsContentImage(
    BaseModel
):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class FormatConversationFormatConversationDetailsMessagesCitationsContentDocument(
    BaseModel
):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class FormatConversationFormatConversationDetailsMessagesToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


FormatConversation.model_rebuild()
FormatConversationFormatConversation.model_rebuild()
FormatConversationFormatConversationMessage.model_rebuild()
FormatConversationFormatConversationMessageCitations.model_rebuild()
FormatConversationFormatConversationMessageCitationsContent.model_rebuild()
FormatConversationFormatConversationFacets.model_rebuild()
FormatConversationFormatConversationFacetsObservable.model_rebuild()
FormatConversationFormatConversationGraph.model_rebuild()
FormatConversationFormatConversationDetails.model_rebuild()
FormatConversationFormatConversationDetailsMessages.model_rebuild()
FormatConversationFormatConversationDetailsMessagesCitations.model_rebuild()
FormatConversationFormatConversationDetailsMessagesCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/get_alert.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AlertTypes,
    ContentPublishingServiceTypes,
    ContentTypes,
    ElevenLabsModels,
    EntityState,
    FileTypes,
    IntegrationServiceTypes,
    ObservableTypes,
    OpenAIImageModels,
)


class GetAlert(BaseModel):
    alert: Optional["GetAlertAlert"]


class GetAlertAlert(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "GetAlertAlertOwner"
    state: EntityState
    correlation_id: Optional[str] = Field(alias="correlationId")
    type: AlertTypes
    summary_prompt: Optional[str] = Field(alias="summaryPrompt")
    publish_prompt: str = Field(alias="publishPrompt")
    filter: Optional["GetAlertAlertFilter"]
    integration: "GetAlertAlertIntegration"
    publishing: "GetAlertAlertPublishing"
    summary_specification: Optional["GetAlertAlertSummarySpecification"] = Field(
        alias="summarySpecification"
    )
    publish_specification: Optional["GetAlertAlertPublishSpecification"] = Field(
        alias="publishSpecification"
    )
    last_alert_date: Optional[Any] = Field(alias="lastAlertDate")


class GetAlertAlertOwner(BaseModel):
    id: str


class GetAlertAlertFilter(BaseModel):
    date_range: Optional["GetAlertAlertFilterDateRange"] = Field(alias="dateRange")
    in_last: Optional[Any] = Field(alias="inLast")
    creation_date_range: Optional["GetAlertAlertFilterCreationDateRange"] = Field(
        alias="creationDateRange"
    )
    created_in_last: Optional[Any] = Field(alias="createdInLast")
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[Optional[FileTypes]]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    similar_contents: Optional[List["GetAlertAlertFilterSimilarContents"]] = Field(
        alias="similarContents"
    )
    contents: Optional[List["GetAlertAlertFilterContents"]]
    feeds: Optional[List["GetAlertAlertFilterFeeds"]]
    workflows: Optional[List["GetAlertAlertFilterWorkflows"]]
    collections: Optional[List["GetAlertAlertFilterCollections"]]
    users: Optional[List["GetAlertAlertFilterUsers"]]
    observations: Optional[List["GetAlertAlertFilterObservations"]]
    or_: Optional[List["GetAlertAlertFilterOr"]] = Field(alias="or")
    and_: Optional[List["GetAlertAlertFilterAnd"]] = Field(alias="and")


class GetAlertAlertFilterDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class GetAlertAlertFilterCreationDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class GetAlertAlertFilterSimilarContents(BaseModel):
    id: str


class GetAlertAlertFilterContents(BaseModel):
    id: str


class GetAlertAlertFilterFeeds(BaseModel):
    id: str


class GetAlertAlertFilterWorkflows(BaseModel):
    id: str


class GetAlertAlertFilterCollections(BaseModel):
    id: str


class GetAlertAlertFilterUsers(BaseModel):
    id: str


class GetAlertAlertFilterObservations(BaseModel):
    type: ObservableTypes
    observable: "GetAlertAlertFilterObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class GetAlertAlertFilterObservationsObservable(BaseModel):
    id: str


class GetAlertAlertFilterOr(BaseModel):
    feeds: Optional[List["GetAlertAlertFilterOrFeeds"]]
    workflows: Optional[List["GetAlertAlertFilterOrWorkflows"]]
    collections: Optional[List["GetAlertAlertFilterOrCollections"]]
    users: Optional[List["GetAlertAlertFilterOrUsers"]]
    observations: Optional[List["GetAlertAlertFilterOrObservations"]]


class GetAlertAlertFilterOrFeeds(BaseModel):
    id: str


class GetAlertAlertFilterOrWorkflows(BaseModel):
    id: str


class GetAlertAlertFilterOrCollections(BaseModel):
    id: str


class GetAlertAlertFilterOrUsers(BaseModel):
    id: str


class GetAlertAlertFilterOrObservations(BaseModel):
    type: ObservableTypes
    observable: "GetAlertAlertFilterOrObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class GetAlertAlertFilterOrObservationsObservable(BaseModel):
    id: str


class GetAlertAlertFilterAnd(BaseModel):
    feeds: Optional[List["GetAlertAlertFilterAndFeeds"]]
    workflows: Optional[List["GetAlertAlertFilterAndWorkflows"]]
    collections: Optional[List["GetAlertAlertFilterAndCollections"]]
    users: Optional[List["GetAlertAlertFilterAndUsers"]]
    observations: Optional[List["GetAlertAlertFilterAndObservations"]]


class GetAlertAlertFilterAndFeeds(BaseModel):
    id: str


class GetAlertAlertFilterAndWorkflows(BaseModel):
    id: str


class GetAlertAlertFilterAndCollections(BaseModel):
    id: str


class GetAlertAlertFilterAndUsers(BaseModel):
    id: str


class GetAlertAlertFilterAndObservations(BaseModel):
    type: ObservableTypes
    observable: "GetAlertAlertFilterAndObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class GetAlertAlertFilterAndObservationsObservable(BaseModel):
    id: str


class GetAlertAlertIntegration(BaseModel):
    type: IntegrationServiceTypes
    uri: Optional[str]
    slack: Optional["GetAlertAlertIntegrationSlack"]
    email: Optional["GetAlertAlertIntegrationEmail"]
    twitter: Optional["GetAlertAlertIntegrationTwitter"]


class GetAlertAlertIntegrationSlack(BaseModel):
    token: str
    channel: str


class GetAlertAlertIntegrationEmail(BaseModel):
    from_: str = Field(alias="from")
    subject: str
    to: List[str]


class GetAlertAlertIntegrationTwitter(BaseModel):
    consumer_key: str = Field(alias="consumerKey")
    consumer_secret: str = Field(alias="consumerSecret")
    access_token_key: str = Field(alias="accessTokenKey")
    access_token_secret: str = Field(alias="accessTokenSecret")


class GetAlertAlertPublishing(BaseModel):
    type: ContentPublishingServiceTypes
    eleven_labs: Optional["GetAlertAlertPublishingElevenLabs"] = Field(
        alias="elevenLabs"
    )
    open_ai_image: Optional["GetAlertAlertPublishingOpenAiImage"] = Field(
        alias="openAIImage"
    )


class GetAlertAlertPublishingElevenLabs(BaseModel):
    model: Optional[ElevenLabsModels]
    voice: Optional[str]


class GetAlertAlertPublishingOpenAiImage(BaseModel):
    model: Optional[OpenAIImageModels]
    count: Optional[int]
    seed: Optional["GetAlertAlertPublishingOpenAiImageSeed"]


class GetAlertAlertPublishingOpenAiImageSeed(BaseModel):
    id: str


class GetAlertAlertSummarySpecification(BaseModel):
    id: str


class GetAlertAlertPublishSpecification(BaseModel):
    id: str


GetAlert.model_rebuild()
GetAlertAlert.model_rebuild()
GetAlertAlertFilter.model_rebuild()
GetAlertAlertFilterObservations.model_rebuild()
GetAlertAlertFilterOr.model_rebuild()
GetAlertAlertFilterOrObservations.model_rebuild()
GetAlertAlertFilterAnd.model_rebuild()
GetAlertAlertFilterAndObservations.model_rebuild()
GetAlertAlertIntegration.model_rebuild()
GetAlertAlertPublishing.model_rebuild()
GetAlertAlertPublishingOpenAiImage.model_rebuild()



================================================
FILE: graphlit_api/get_category.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class GetCategory(BaseModel):
    category: Optional["GetCategoryCategory"]


class GetCategoryCategory(BaseModel):
    id: str
    name: str
    description: Optional[str]
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]


GetCategory.model_rebuild()



================================================
FILE: graphlit_api/get_collection.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import CollectionTypes, EntityState


class GetCollection(BaseModel):
    collection: Optional["GetCollectionCollection"]


class GetCollectionCollection(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "GetCollectionCollectionOwner"
    state: EntityState
    type: Optional[CollectionTypes]
    contents: Optional[List[Optional["GetCollectionCollectionContents"]]]


class GetCollectionCollectionOwner(BaseModel):
    id: str


class GetCollectionCollectionContents(BaseModel):
    id: str
    name: str


GetCollection.model_rebuild()
GetCollectionCollection.model_rebuild()



================================================
FILE: graphlit_api/get_content.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    LinkTypes,
    MailImportance,
    MailPriority,
    MailSensitivity,
    ObservableTypes,
    OccurrenceTypes,
    OrientationTypes,
    TextRoles,
)


class GetContent(BaseModel):
    content: Optional["GetContentContent"]


class GetContentContent(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    owner: "GetContentContentOwner"
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    finished_date: Optional[Any] = Field(alias="finishedDate")
    workflow_duration: Optional[Any] = Field(alias="workflowDuration")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    markdown: Optional[str]
    address: Optional["GetContentContentAddress"]
    location: Optional["GetContentContentLocation"]
    c_4_id: Optional[str] = Field(alias="c4id")
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["GetContentContentVideo"]
    audio: Optional["GetContentContentAudio"]
    image: Optional["GetContentContentImage"]
    document: Optional["GetContentContentDocument"]
    email: Optional["GetContentContentEmail"]
    issue: Optional["GetContentContentIssue"]
    package: Optional["GetContentContentPackage"]
    language: Optional["GetContentContentLanguage"]
    parent: Optional["GetContentContentParent"]
    children: Optional[List[Optional["GetContentContentChildren"]]]
    feed: Optional["GetContentContentFeed"]
    collections: Optional[List[Optional["GetContentContentCollections"]]]
    links: Optional[List["GetContentContentLinks"]]
    observations: Optional[List[Optional["GetContentContentObservations"]]]
    workflow: Optional["GetContentContentWorkflow"]
    pages: Optional[List["GetContentContentPages"]]
    segments: Optional[List["GetContentContentSegments"]]
    frames: Optional[List["GetContentContentFrames"]]
    error: Optional[str]


class GetContentContentOwner(BaseModel):
    id: str


class GetContentContentAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


class GetContentContentLocation(BaseModel):
    latitude: Optional[float]
    longitude: Optional[float]


class GetContentContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class GetContentContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class GetContentContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class GetContentContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class GetContentContentEmail(BaseModel):
    identifier: Optional[str]
    thread_identifier: Optional[str] = Field(alias="threadIdentifier")
    subject: Optional[str]
    labels: Optional[List[Optional[str]]]
    sensitivity: Optional[MailSensitivity]
    priority: Optional[MailPriority]
    importance: Optional[MailImportance]
    from_: Optional[List[Optional["GetContentContentEmailFrom"]]] = Field(alias="from")
    to: Optional[List[Optional["GetContentContentEmailTo"]]]
    cc: Optional[List[Optional["GetContentContentEmailCc"]]]
    bcc: Optional[List[Optional["GetContentContentEmailBcc"]]]


class GetContentContentEmailFrom(BaseModel):
    name: Optional[str]
    email: Optional[str]
    given_name: Optional[str] = Field(alias="givenName")
    family_name: Optional[str] = Field(alias="familyName")


class GetContentContentEmailTo(BaseModel):
    name: Optional[str]
    email: Optional[str]
    given_name: Optional[str] = Field(alias="givenName")
    family_name: Optional[str] = Field(alias="familyName")


class GetContentContentEmailCc(BaseModel):
    name: Optional[str]
    email: Optional[str]
    given_name: Optional[str] = Field(alias="givenName")
    family_name: Optional[str] = Field(alias="familyName")


class GetContentContentEmailBcc(BaseModel):
    name: Optional[str]
    email: Optional[str]
    given_name: Optional[str] = Field(alias="givenName")
    family_name: Optional[str] = Field(alias="familyName")


class GetContentContentIssue(BaseModel):
    identifier: Optional[str]
    title: Optional[str]
    project: Optional[str]
    team: Optional[str]
    status: Optional[str]
    priority: Optional[str]
    type: Optional[str]
    labels: Optional[List[Optional[str]]]


class GetContentContentPackage(BaseModel):
    file_count: Optional[int] = Field(alias="fileCount")
    folder_count: Optional[int] = Field(alias="folderCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")


class GetContentContentLanguage(BaseModel):
    languages: Optional[List[Optional[str]]]


class GetContentContentParent(BaseModel):
    id: str
    name: str


class GetContentContentChildren(BaseModel):
    id: str
    name: str


class GetContentContentFeed(BaseModel):
    id: str
    name: str


class GetContentContentCollections(BaseModel):
    id: str
    name: str


class GetContentContentLinks(BaseModel):
    uri: Optional[Any]
    link_type: Optional[LinkTypes] = Field(alias="linkType")


class GetContentContentObservations(BaseModel):
    id: str
    type: ObservableTypes
    observable: "GetContentContentObservationsObservable"
    related: Optional["GetContentContentObservationsRelated"]
    related_type: Optional[ObservableTypes] = Field(alias="relatedType")
    relation: Optional[str]
    occurrences: Optional[List[Optional["GetContentContentObservationsOccurrences"]]]
    state: EntityState


class GetContentContentObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class GetContentContentObservationsRelated(BaseModel):
    id: str
    name: Optional[str]


class GetContentContentObservationsOccurrences(BaseModel):
    type: Optional[OccurrenceTypes]
    confidence: Optional[float]
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_index: Optional[int] = Field(alias="pageIndex")
    bounding_box: Optional["GetContentContentObservationsOccurrencesBoundingBox"] = (
        Field(alias="boundingBox")
    )


class GetContentContentObservationsOccurrencesBoundingBox(BaseModel):
    left: Optional[float]
    top: Optional[float]
    width: Optional[float]
    height: Optional[float]


class GetContentContentWorkflow(BaseModel):
    id: str
    name: str


class GetContentContentPages(BaseModel):
    index: Optional[int]
    text: Optional[str]
    relevance: Optional[float]
    images: Optional[List[Optional["GetContentContentPagesImages"]]]
    chunks: Optional[List[Optional["GetContentContentPagesChunks"]]]


class GetContentContentPagesImages(BaseModel):
    id: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    data: Optional[str]
    left: Optional[int]
    right: Optional[int]
    top: Optional[int]
    bottom: Optional[int]


class GetContentContentPagesChunks(BaseModel):
    index: Optional[int]
    page_index: Optional[int] = Field(alias="pageIndex")
    row_index: Optional[int] = Field(alias="rowIndex")
    column_index: Optional[int] = Field(alias="columnIndex")
    confidence: Optional[float]
    text: Optional[str]
    role: Optional[TextRoles]
    language: Optional[str]
    relevance: Optional[float]


class GetContentContentSegments(BaseModel):
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    text: Optional[str]
    relevance: Optional[float]


class GetContentContentFrames(BaseModel):
    index: Optional[int]
    description: Optional[str]
    text: Optional[str]
    relevance: Optional[float]


GetContent.model_rebuild()
GetContentContent.model_rebuild()
GetContentContentEmail.model_rebuild()
GetContentContentObservations.model_rebuild()
GetContentContentObservationsOccurrences.model_rebuild()
GetContentContentPages.model_rebuild()



================================================
FILE: graphlit_api/get_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    ConversationTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    ObservableTypes,
    OrientationTypes,
)


class GetConversation(BaseModel):
    conversation: Optional["GetConversationConversation"]


class GetConversationConversation(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "GetConversationConversationOwner"
    state: EntityState
    correlation_id: Optional[str] = Field(alias="correlationId")
    type: Optional[ConversationTypes]
    messages: Optional[List[Optional["GetConversationConversationMessages"]]]
    specification: Optional["GetConversationConversationSpecification"]
    fallbacks: Optional[List[Optional["GetConversationConversationFallbacks"]]]
    filter: Optional["GetConversationConversationFilter"]
    augmented_filter: Optional["GetConversationConversationAugmentedFilter"] = Field(
        alias="augmentedFilter"
    )


class GetConversationConversationOwner(BaseModel):
    id: str


class GetConversationConversationMessages(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[List[Optional["GetConversationConversationMessagesCitations"]]]
    tool_calls: Optional[
        List[Optional["GetConversationConversationMessagesToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class GetConversationConversationMessagesCitations(BaseModel):
    content: Optional["GetConversationConversationMessagesCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class GetConversationConversationMessagesCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["GetConversationConversationMessagesCitationsContentVideo"]
    audio: Optional["GetConversationConversationMessagesCitationsContentAudio"]
    image: Optional["GetConversationConversationMessagesCitationsContentImage"]
    document: Optional["GetConversationConversationMessagesCitationsContentDocument"]


class GetConversationConversationMessagesCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class GetConversationConversationMessagesCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class GetConversationConversationMessagesCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class GetConversationConversationMessagesCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class GetConversationConversationMessagesToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


class GetConversationConversationSpecification(BaseModel):
    id: str
    name: str


class GetConversationConversationFallbacks(BaseModel):
    id: str
    name: str


class GetConversationConversationFilter(BaseModel):
    date_range: Optional["GetConversationConversationFilterDateRange"] = Field(
        alias="dateRange"
    )
    in_last: Optional[Any] = Field(alias="inLast")
    creation_date_range: Optional[
        "GetConversationConversationFilterCreationDateRange"
    ] = Field(alias="creationDateRange")
    created_in_last: Optional[Any] = Field(alias="createdInLast")
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[Optional[FileTypes]]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    similar_contents: Optional[
        List["GetConversationConversationFilterSimilarContents"]
    ] = Field(alias="similarContents")
    contents: Optional[List["GetConversationConversationFilterContents"]]
    feeds: Optional[List["GetConversationConversationFilterFeeds"]]
    workflows: Optional[List["GetConversationConversationFilterWorkflows"]]
    collections: Optional[List["GetConversationConversationFilterCollections"]]
    users: Optional[List["GetConversationConversationFilterUsers"]]
    observations: Optional[List["GetConversationConversationFilterObservations"]]
    or_: Optional[List["GetConversationConversationFilterOr"]] = Field(alias="or")
    and_: Optional[List["GetConversationConversationFilterAnd"]] = Field(alias="and")


class GetConversationConversationFilterDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class GetConversationConversationFilterCreationDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class GetConversationConversationFilterSimilarContents(BaseModel):
    id: str


class GetConversationConversationFilterContents(BaseModel):
    id: str


class GetConversationConversationFilterFeeds(BaseModel):
    id: str


class GetConversationConversationFilterWorkflows(BaseModel):
    id: str


class GetConversationConversationFilterCollections(BaseModel):
    id: str


class GetConversationConversationFilterUsers(BaseModel):
    id: str


class GetConversationConversationFilterObservations(BaseModel):
    type: ObservableTypes
    observable: "GetConversationConversationFilterObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class GetConversationConversationFilterObservationsObservable(BaseModel):
    id: str


class GetConversationConversationFilterOr(BaseModel):
    feeds: Optional[List["GetConversationConversationFilterOrFeeds"]]
    workflows: Optional[List["GetConversationConversationFilterOrWorkflows"]]
    collections: Optional[List["GetConversationConversationFilterOrCollections"]]
    users: Optional[List["GetConversationConversationFilterOrUsers"]]
    observations: Optional[List["GetConversationConversationFilterOrObservations"]]


class GetConversationConversationFilterOrFeeds(BaseModel):
    id: str


class GetConversationConversationFilterOrWorkflows(BaseModel):
    id: str


class GetConversationConversationFilterOrCollections(BaseModel):
    id: str


class GetConversationConversationFilterOrUsers(BaseModel):
    id: str


class GetConversationConversationFilterOrObservations(BaseModel):
    type: ObservableTypes
    observable: "GetConversationConversationFilterOrObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class GetConversationConversationFilterOrObservationsObservable(BaseModel):
    id: str


class GetConversationConversationFilterAnd(BaseModel):
    feeds: Optional[List["GetConversationConversationFilterAndFeeds"]]
    workflows: Optional[List["GetConversationConversationFilterAndWorkflows"]]
    collections: Optional[List["GetConversationConversationFilterAndCollections"]]
    users: Optional[List["GetConversationConversationFilterAndUsers"]]
    observations: Optional[List["GetConversationConversationFilterAndObservations"]]


class GetConversationConversationFilterAndFeeds(BaseModel):
    id: str


class GetConversationConversationFilterAndWorkflows(BaseModel):
    id: str


class GetConversationConversationFilterAndCollections(BaseModel):
    id: str


class GetConversationConversationFilterAndUsers(BaseModel):
    id: str


class GetConversationConversationFilterAndObservations(BaseModel):
    type: ObservableTypes
    observable: "GetConversationConversationFilterAndObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class GetConversationConversationFilterAndObservationsObservable(BaseModel):
    id: str


class GetConversationConversationAugmentedFilter(BaseModel):
    date_range: Optional["GetConversationConversationAugmentedFilterDateRange"] = Field(
        alias="dateRange"
    )
    in_last: Optional[Any] = Field(alias="inLast")
    creation_date_range: Optional[
        "GetConversationConversationAugmentedFilterCreationDateRange"
    ] = Field(alias="creationDateRange")
    created_in_last: Optional[Any] = Field(alias="createdInLast")
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[Optional[FileTypes]]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    similar_contents: Optional[
        List["GetConversationConversationAugmentedFilterSimilarContents"]
    ] = Field(alias="similarContents")
    contents: Optional[List["GetConversationConversationAugmentedFilterContents"]]
    feeds: Optional[List["GetConversationConversationAugmentedFilterFeeds"]]
    workflows: Optional[List["GetConversationConversationAugmentedFilterWorkflows"]]
    collections: Optional[List["GetConversationConversationAugmentedFilterCollections"]]
    users: Optional[List["GetConversationConversationAugmentedFilterUsers"]]
    observations: Optional[
        List["GetConversationConversationAugmentedFilterObservations"]
    ]
    or_: Optional[List["GetConversationConversationAugmentedFilterOr"]] = Field(
        alias="or"
    )
    and_: Optional[List["GetConversationConversationAugmentedFilterAnd"]] = Field(
        alias="and"
    )


class GetConversationConversationAugmentedFilterDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class GetConversationConversationAugmentedFilterCreationDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class GetConversationConversationAugmentedFilterSimilarContents(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterContents(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterFeeds(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterWorkflows(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterCollections(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterUsers(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterObservations(BaseModel):
    type: ObservableTypes
    observable: "GetConversationConversationAugmentedFilterObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class GetConversationConversationAugmentedFilterObservationsObservable(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterOr(BaseModel):
    feeds: Optional[List["GetConversationConversationAugmentedFilterOrFeeds"]]
    workflows: Optional[List["GetConversationConversationAugmentedFilterOrWorkflows"]]
    collections: Optional[
        List["GetConversationConversationAugmentedFilterOrCollections"]
    ]
    users: Optional[List["GetConversationConversationAugmentedFilterOrUsers"]]
    observations: Optional[
        List["GetConversationConversationAugmentedFilterOrObservations"]
    ]


class GetConversationConversationAugmentedFilterOrFeeds(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterOrWorkflows(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterOrCollections(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterOrUsers(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterOrObservations(BaseModel):
    type: ObservableTypes
    observable: "GetConversationConversationAugmentedFilterOrObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class GetConversationConversationAugmentedFilterOrObservationsObservable(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterAnd(BaseModel):
    feeds: Optional[List["GetConversationConversationAugmentedFilterAndFeeds"]]
    workflows: Optional[List["GetConversationConversationAugmentedFilterAndWorkflows"]]
    collections: Optional[
        List["GetConversationConversationAugmentedFilterAndCollections"]
    ]
    users: Optional[List["GetConversationConversationAugmentedFilterAndUsers"]]
    observations: Optional[
        List["GetConversationConversationAugmentedFilterAndObservations"]
    ]


class GetConversationConversationAugmentedFilterAndFeeds(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterAndWorkflows(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterAndCollections(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterAndUsers(BaseModel):
    id: str


class GetConversationConversationAugmentedFilterAndObservations(BaseModel):
    type: ObservableTypes
    observable: "GetConversationConversationAugmentedFilterAndObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class GetConversationConversationAugmentedFilterAndObservationsObservable(BaseModel):
    id: str


GetConversation.model_rebuild()
GetConversationConversation.model_rebuild()
GetConversationConversationMessages.model_rebuild()
GetConversationConversationMessagesCitations.model_rebuild()
GetConversationConversationMessagesCitationsContent.model_rebuild()
GetConversationConversationFilter.model_rebuild()
GetConversationConversationFilterObservations.model_rebuild()
GetConversationConversationFilterOr.model_rebuild()
GetConversationConversationFilterOrObservations.model_rebuild()
GetConversationConversationFilterAnd.model_rebuild()
GetConversationConversationFilterAndObservations.model_rebuild()
GetConversationConversationAugmentedFilter.model_rebuild()
GetConversationConversationAugmentedFilterObservations.model_rebuild()
GetConversationConversationAugmentedFilterOr.model_rebuild()
GetConversationConversationAugmentedFilterOrObservations.model_rebuild()
GetConversationConversationAugmentedFilterAnd.model_rebuild()
GetConversationConversationAugmentedFilterAndObservations.model_rebuild()



================================================
FILE: graphlit_api/get_event.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetEvent(BaseModel):
    event: Optional["GetEventEvent"]


class GetEventEvent(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["GetEventEventAddress"]
    start_date: Optional[Any] = Field(alias="startDate")
    end_date: Optional[Any] = Field(alias="endDate")
    availability_start_date: Optional[Any] = Field(alias="availabilityStartDate")
    availability_end_date: Optional[Any] = Field(alias="availabilityEndDate")
    price: Optional[Any]
    min_price: Optional[Any] = Field(alias="minPrice")
    max_price: Optional[Any] = Field(alias="maxPrice")
    price_currency: Optional[str] = Field(alias="priceCurrency")
    is_accessible_for_free: Optional[bool] = Field(alias="isAccessibleForFree")
    typical_age_range: Optional[str] = Field(alias="typicalAgeRange")


class GetEventEventAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


GetEvent.model_rebuild()
GetEventEvent.model_rebuild()



================================================
FILE: graphlit_api/get_feed.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    EmailListingTypes,
    EntityState,
    FeedListingTypes,
    FeedServiceTypes,
    FeedTypes,
    GoogleDriveAuthenticationTypes,
    NotionTypes,
    SearchServiceTypes,
    SharePointAuthenticationTypes,
    SiteTypes,
    TimedPolicyRecurrenceTypes,
    TrelloTypes,
    TwitterListingTypes,
    YouTubeTypes,
)


class GetFeed(BaseModel):
    feed: Optional["GetFeedFeed"]


class GetFeedFeed(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "GetFeedFeedOwner"
    state: EntityState
    correlation_id: Optional[str] = Field(alias="correlationId")
    type: FeedTypes
    site: Optional["GetFeedFeedSite"]
    email: Optional["GetFeedFeedEmail"]
    issue: Optional["GetFeedFeedIssue"]
    rss: Optional["GetFeedFeedRss"]
    web: Optional["GetFeedFeedWeb"]
    search: Optional["GetFeedFeedSearch"]
    reddit: Optional["GetFeedFeedReddit"]
    notion: Optional["GetFeedFeedNotion"]
    intercom: Optional["GetFeedFeedIntercom"]
    zendesk: Optional["GetFeedFeedZendesk"]
    youtube: Optional["GetFeedFeedYoutube"]
    twitter: Optional["GetFeedFeedTwitter"]
    slack: Optional["GetFeedFeedSlack"]
    microsoft_teams: Optional["GetFeedFeedMicrosoftTeams"] = Field(
        alias="microsoftTeams"
    )
    discord: Optional["GetFeedFeedDiscord"]
    error: Optional[str]
    last_post_date: Optional[Any] = Field(alias="lastPostDate")
    last_read_date: Optional[Any] = Field(alias="lastReadDate")
    read_count: Optional[int] = Field(alias="readCount")
    workflow: Optional["GetFeedFeedWorkflow"]
    schedule_policy: Optional["GetFeedFeedSchedulePolicy"] = Field(
        alias="schedulePolicy"
    )


class GetFeedFeedOwner(BaseModel):
    id: str


class GetFeedFeedSite(BaseModel):
    site_type: SiteTypes = Field(alias="siteType")
    type: FeedServiceTypes
    is_recursive: Optional[bool] = Field(alias="isRecursive")
    s_3: Optional["GetFeedFeedSiteS3"] = Field(alias="s3")
    azure_blob: Optional["GetFeedFeedSiteAzureBlob"] = Field(alias="azureBlob")
    azure_file: Optional["GetFeedFeedSiteAzureFile"] = Field(alias="azureFile")
    google: Optional["GetFeedFeedSiteGoogle"]
    share_point: Optional["GetFeedFeedSiteSharePoint"] = Field(alias="sharePoint")
    one_drive: Optional["GetFeedFeedSiteOneDrive"] = Field(alias="oneDrive")
    google_drive: Optional["GetFeedFeedSiteGoogleDrive"] = Field(alias="googleDrive")
    dropbox: Optional["GetFeedFeedSiteDropbox"]
    box: Optional["GetFeedFeedSiteBox"]
    github: Optional["GetFeedFeedSiteGithub"]
    read_limit: Optional[int] = Field(alias="readLimit")


class GetFeedFeedSiteS3(BaseModel):
    access_key: Optional[str] = Field(alias="accessKey")
    secret_access_key: Optional[str] = Field(alias="secretAccessKey")
    bucket_name: Optional[str] = Field(alias="bucketName")
    prefix: Optional[str]
    region: Optional[str]


class GetFeedFeedSiteAzureBlob(BaseModel):
    storage_access_key: Optional[str] = Field(alias="storageAccessKey")
    account_name: Optional[str] = Field(alias="accountName")
    container_name: Optional[str] = Field(alias="containerName")
    prefix: Optional[str]


class GetFeedFeedSiteAzureFile(BaseModel):
    storage_access_key: Optional[str] = Field(alias="storageAccessKey")
    account_name: Optional[str] = Field(alias="accountName")
    share_name: Optional[str] = Field(alias="shareName")
    prefix: Optional[str]


class GetFeedFeedSiteGoogle(BaseModel):
    credentials: Optional[str]
    container_name: Optional[str] = Field(alias="containerName")
    prefix: Optional[str]


class GetFeedFeedSiteSharePoint(BaseModel):
    authentication_type: SharePointAuthenticationTypes = Field(
        alias="authenticationType"
    )
    account_name: str = Field(alias="accountName")
    library_id: str = Field(alias="libraryId")
    folder_id: Optional[str] = Field(alias="folderId")
    tenant_id: Optional[str] = Field(alias="tenantId")
    client_id: Optional[str] = Field(alias="clientId")
    client_secret: Optional[str] = Field(alias="clientSecret")
    refresh_token: Optional[str] = Field(alias="refreshToken")


class GetFeedFeedSiteOneDrive(BaseModel):
    folder_id: Optional[str] = Field(alias="folderId")
    files: Optional[List[Optional[str]]]
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")
    refresh_token: str = Field(alias="refreshToken")


class GetFeedFeedSiteGoogleDrive(BaseModel):
    authentication_type: Optional[GoogleDriveAuthenticationTypes] = Field(
        alias="authenticationType"
    )
    folder_id: Optional[str] = Field(alias="folderId")
    files: Optional[List[Optional[str]]]
    refresh_token: Optional[str] = Field(alias="refreshToken")
    client_id: Optional[str] = Field(alias="clientId")
    client_secret: Optional[str] = Field(alias="clientSecret")
    service_account_json: Optional[str] = Field(alias="serviceAccountJson")


class GetFeedFeedSiteDropbox(BaseModel):
    path: Optional[str]
    app_key: str = Field(alias="appKey")
    app_secret: str = Field(alias="appSecret")
    refresh_token: str = Field(alias="refreshToken")
    redirect_uri: str = Field(alias="redirectUri")


class GetFeedFeedSiteBox(BaseModel):
    folder_id: Optional[str] = Field(alias="folderId")
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")
    refresh_token: str = Field(alias="refreshToken")
    redirect_uri: str = Field(alias="redirectUri")


class GetFeedFeedSiteGithub(BaseModel):
    uri: Optional[Any]
    repository_owner: str = Field(alias="repositoryOwner")
    repository_name: str = Field(alias="repositoryName")
    refresh_token: Optional[str] = Field(alias="refreshToken")
    personal_access_token: Optional[str] = Field(alias="personalAccessToken")


class GetFeedFeedEmail(BaseModel):
    type: FeedServiceTypes
    include_attachments: Optional[bool] = Field(alias="includeAttachments")
    google: Optional["GetFeedFeedEmailGoogle"]
    microsoft: Optional["GetFeedFeedEmailMicrosoft"]
    read_limit: Optional[int] = Field(alias="readLimit")


class GetFeedFeedEmailGoogle(BaseModel):
    type: Optional[EmailListingTypes]
    include_spam: Optional[bool] = Field(alias="includeSpam")
    exclude_sent_items: Optional[bool] = Field(alias="excludeSentItems")
    include_deleted_items: Optional[bool] = Field(alias="includeDeletedItems")
    inbox_only: Optional[bool] = Field(alias="inboxOnly")
    refresh_token: Optional[str] = Field(alias="refreshToken")
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class GetFeedFeedEmailMicrosoft(BaseModel):
    type: Optional[EmailListingTypes]
    include_spam: Optional[bool] = Field(alias="includeSpam")
    exclude_sent_items: Optional[bool] = Field(alias="excludeSentItems")
    include_deleted_items: Optional[bool] = Field(alias="includeDeletedItems")
    inbox_only: Optional[bool] = Field(alias="inboxOnly")
    refresh_token: str = Field(alias="refreshToken")
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class GetFeedFeedIssue(BaseModel):
    type: FeedServiceTypes
    include_attachments: Optional[bool] = Field(alias="includeAttachments")
    jira: Optional["GetFeedFeedIssueJira"]
    linear: Optional["GetFeedFeedIssueLinear"]
    github: Optional["GetFeedFeedIssueGithub"]
    intercom: Optional["GetFeedFeedIssueIntercom"]
    zendesk: Optional["GetFeedFeedIssueZendesk"]
    trello: Optional["GetFeedFeedIssueTrello"]
    read_limit: Optional[int] = Field(alias="readLimit")


class GetFeedFeedIssueJira(BaseModel):
    uri: Any
    project: str
    email: str
    token: str
    offset: Optional[Any]


class GetFeedFeedIssueLinear(BaseModel):
    key: str
    project: str


class GetFeedFeedIssueGithub(BaseModel):
    uri: Optional[Any]
    repository_owner: str = Field(alias="repositoryOwner")
    repository_name: str = Field(alias="repositoryName")
    refresh_token: Optional[str] = Field(alias="refreshToken")
    personal_access_token: Optional[str] = Field(alias="personalAccessToken")


class GetFeedFeedIssueIntercom(BaseModel):
    access_token: str = Field(alias="accessToken")


class GetFeedFeedIssueZendesk(BaseModel):
    subdomain: str
    access_token: str = Field(alias="accessToken")


class GetFeedFeedIssueTrello(BaseModel):
    key: str
    token: str
    identifiers: List[str]
    type: TrelloTypes


class GetFeedFeedRss(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    uri: Any


class GetFeedFeedWeb(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    uri: Any
    include_files: Optional[bool] = Field(alias="includeFiles")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")


class GetFeedFeedSearch(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    type: Optional[SearchServiceTypes]
    text: str


class GetFeedFeedReddit(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    subreddit_name: str = Field(alias="subredditName")


class GetFeedFeedNotion(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    token: str
    identifiers: List[str]
    type: NotionTypes


class GetFeedFeedIntercom(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    access_token: str = Field(alias="accessToken")


class GetFeedFeedZendesk(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    subdomain: str
    access_token: str = Field(alias="accessToken")


class GetFeedFeedYoutube(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    type: YouTubeTypes
    video_name: Optional[str] = Field(alias="videoName")
    video_identifiers: Optional[List[str]] = Field(alias="videoIdentifiers")
    channel_identifier: Optional[str] = Field(alias="channelIdentifier")
    playlist_identifier: Optional[str] = Field(alias="playlistIdentifier")


class GetFeedFeedTwitter(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    token: str
    type: Optional[TwitterListingTypes]
    user_name: Optional[str] = Field(alias="userName")
    query: Optional[str]
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class GetFeedFeedSlack(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    type: Optional[FeedListingTypes]
    token: str
    channel: str
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class GetFeedFeedMicrosoftTeams(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    type: Optional[FeedListingTypes]
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")
    refresh_token: str = Field(alias="refreshToken")
    team_id: str = Field(alias="teamId")
    channel_id: str = Field(alias="channelId")


class GetFeedFeedDiscord(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    type: Optional[FeedListingTypes]
    token: str
    channel: str
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class GetFeedFeedWorkflow(BaseModel):
    id: str
    name: str


class GetFeedFeedSchedulePolicy(BaseModel):
    recurrence_type: Optional[TimedPolicyRecurrenceTypes] = Field(
        alias="recurrenceType"
    )
    repeat_interval: Optional[Any] = Field(alias="repeatInterval")


GetFeed.model_rebuild()
GetFeedFeed.model_rebuild()
GetFeedFeedSite.model_rebuild()
GetFeedFeedEmail.model_rebuild()
GetFeedFeedIssue.model_rebuild()



================================================
FILE: graphlit_api/get_label.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class GetLabel(BaseModel):
    label: Optional["GetLabelLabel"]


class GetLabelLabel(BaseModel):
    id: str
    name: str
    description: Optional[str]
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]


GetLabel.model_rebuild()



================================================
FILE: graphlit_api/get_medical_condition.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalCondition(BaseModel):
    medical_condition: Optional["GetMedicalConditionMedicalCondition"] = Field(
        alias="medicalCondition"
    )


class GetMedicalConditionMedicalCondition(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetMedicalCondition.model_rebuild()



================================================
FILE: graphlit_api/get_medical_contraindication.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalContraindication(BaseModel):
    medical_contraindication: Optional[
        "GetMedicalContraindicationMedicalContraindication"
    ] = Field(alias="medicalContraindication")


class GetMedicalContraindicationMedicalContraindication(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetMedicalContraindication.model_rebuild()



================================================
FILE: graphlit_api/get_medical_device.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalDevice(BaseModel):
    medical_device: Optional["GetMedicalDeviceMedicalDevice"] = Field(
        alias="medicalDevice"
    )


class GetMedicalDeviceMedicalDevice(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetMedicalDevice.model_rebuild()



================================================
FILE: graphlit_api/get_medical_drug.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalDrug(BaseModel):
    medical_drug: Optional["GetMedicalDrugMedicalDrug"] = Field(alias="medicalDrug")


class GetMedicalDrugMedicalDrug(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetMedicalDrug.model_rebuild()



================================================
FILE: graphlit_api/get_medical_drug_class.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalDrugClass(BaseModel):
    medical_drug_class: Optional["GetMedicalDrugClassMedicalDrugClass"] = Field(
        alias="medicalDrugClass"
    )


class GetMedicalDrugClassMedicalDrugClass(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetMedicalDrugClass.model_rebuild()



================================================
FILE: graphlit_api/get_medical_guideline.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalGuideline(BaseModel):
    medical_guideline: Optional["GetMedicalGuidelineMedicalGuideline"] = Field(
        alias="medicalGuideline"
    )


class GetMedicalGuidelineMedicalGuideline(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetMedicalGuideline.model_rebuild()



================================================
FILE: graphlit_api/get_medical_indication.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalIndication(BaseModel):
    medical_indication: Optional["GetMedicalIndicationMedicalIndication"] = Field(
        alias="medicalIndication"
    )


class GetMedicalIndicationMedicalIndication(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetMedicalIndication.model_rebuild()



================================================
FILE: graphlit_api/get_medical_procedure.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalProcedure(BaseModel):
    medical_procedure: Optional["GetMedicalProcedureMedicalProcedure"] = Field(
        alias="medicalProcedure"
    )


class GetMedicalProcedureMedicalProcedure(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetMedicalProcedure.model_rebuild()



================================================
FILE: graphlit_api/get_medical_study.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalStudy(BaseModel):
    medical_study: Optional["GetMedicalStudyMedicalStudy"] = Field(alias="medicalStudy")


class GetMedicalStudyMedicalStudy(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["GetMedicalStudyMedicalStudyAddress"]


class GetMedicalStudyMedicalStudyAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


GetMedicalStudy.model_rebuild()
GetMedicalStudyMedicalStudy.model_rebuild()



================================================
FILE: graphlit_api/get_medical_test.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalTest(BaseModel):
    medical_test: Optional["GetMedicalTestMedicalTest"] = Field(alias="medicalTest")


class GetMedicalTestMedicalTest(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetMedicalTest.model_rebuild()



================================================
FILE: graphlit_api/get_medical_therapy.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetMedicalTherapy(BaseModel):
    medical_therapy: Optional["GetMedicalTherapyMedicalTherapy"] = Field(
        alias="medicalTherapy"
    )


class GetMedicalTherapyMedicalTherapy(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetMedicalTherapy.model_rebuild()



================================================
FILE: graphlit_api/get_organization.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetOrganization(BaseModel):
    organization: Optional["GetOrganizationOrganization"]


class GetOrganizationOrganization(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["GetOrganizationOrganizationAddress"]
    founding_date: Optional[Any] = Field(alias="foundingDate")
    industries: Optional[List[Optional[str]]]
    revenue: Optional[Any]
    revenue_currency: Optional[str] = Field(alias="revenueCurrency")
    investment: Optional[Any]
    investment_currency: Optional[str] = Field(alias="investmentCurrency")


class GetOrganizationOrganizationAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


GetOrganization.model_rebuild()
GetOrganizationOrganization.model_rebuild()



================================================
FILE: graphlit_api/get_person.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetPerson(BaseModel):
    person: Optional["GetPersonPerson"]


class GetPersonPerson(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["GetPersonPersonAddress"]
    email: Optional[str]
    given_name: Optional[str] = Field(alias="givenName")
    family_name: Optional[str] = Field(alias="familyName")
    phone_number: Optional[str] = Field(alias="phoneNumber")
    birth_date: Optional[Any] = Field(alias="birthDate")
    title: Optional[str]
    occupation: Optional[str]
    education: Optional[str]


class GetPersonPersonAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


GetPerson.model_rebuild()
GetPersonPerson.model_rebuild()



================================================
FILE: graphlit_api/get_place.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetPlace(BaseModel):
    place: Optional["GetPlacePlace"]


class GetPlacePlace(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["GetPlacePlaceAddress"]


class GetPlacePlaceAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


GetPlace.model_rebuild()
GetPlacePlace.model_rebuild()



================================================
FILE: graphlit_api/get_product.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetProduct(BaseModel):
    product: Optional["GetProductProduct"]


class GetProductProduct(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["GetProductProductAddress"]
    manufacturer: Optional[str]
    model: Optional[str]
    brand: Optional[str]
    upc: Optional[str]
    sku: Optional[str]
    release_date: Optional[Any] = Field(alias="releaseDate")
    production_date: Optional[Any] = Field(alias="productionDate")


class GetProductProductAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


GetProduct.model_rebuild()
GetProductProduct.model_rebuild()



================================================
FILE: graphlit_api/get_project.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState, EnvironmentTypes, ResourceConnectorTypes


class GetProject(BaseModel):
    project: Optional["GetProjectProject"]


class GetProjectProject(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    modified_date: Optional[Any] = Field(alias="modifiedDate")
    state: EntityState
    environment_type: Optional[EnvironmentTypes] = Field(alias="environmentType")
    platform: Optional[ResourceConnectorTypes]
    region: Optional[str]
    credits: Optional[Any]
    last_credits_date: Optional[Any] = Field(alias="lastCreditsDate")
    workflow: Optional["GetProjectProjectWorkflow"]
    specification: Optional["GetProjectProjectSpecification"]
    embeddings: Optional["GetProjectProjectEmbeddings"]
    quota: Optional["GetProjectProjectQuota"]
    callback_uri: Optional[Any] = Field(alias="callbackUri")


class GetProjectProjectWorkflow(BaseModel):
    id: str
    name: str


class GetProjectProjectSpecification(BaseModel):
    id: str
    name: str


class GetProjectProjectEmbeddings(BaseModel):
    text_specification: Optional["GetProjectProjectEmbeddingsTextSpecification"] = (
        Field(alias="textSpecification")
    )
    image_specification: Optional["GetProjectProjectEmbeddingsImageSpecification"] = (
        Field(alias="imageSpecification")
    )


class GetProjectProjectEmbeddingsTextSpecification(BaseModel):
    id: str


class GetProjectProjectEmbeddingsImageSpecification(BaseModel):
    id: str


class GetProjectProjectQuota(BaseModel):
    storage: Optional[Any]
    contents: Optional[int]
    credits: Optional[int]
    feeds: Optional[int]
    posts: Optional[int]
    conversations: Optional[int]


GetProject.model_rebuild()
GetProjectProject.model_rebuild()
GetProjectProjectEmbeddings.model_rebuild()



================================================
FILE: graphlit_api/get_repo.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetRepo(BaseModel):
    repo: Optional["GetRepoRepo"]


class GetRepoRepo(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


GetRepo.model_rebuild()



================================================
FILE: graphlit_api/get_share_point_consent_uri.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class GetSharePointConsentUri(BaseModel):
    share_point_consent_uri: Optional["GetSharePointConsentUriSharePointConsentUri"] = (
        Field(alias="sharePointConsentUri")
    )


class GetSharePointConsentUriSharePointConsentUri(BaseModel):
    uri: Optional[Any]


GetSharePointConsentUri.model_rebuild()



================================================
FILE: graphlit_api/get_software.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class GetSoftware(BaseModel):
    software: Optional["GetSoftwareSoftware"]


class GetSoftwareSoftware(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    release_date: Optional[Any] = Field(alias="releaseDate")
    developer: Optional[str]


GetSoftware.model_rebuild()



================================================
FILE: graphlit_api/get_specification.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AnthropicModels,
    AzureOpenAIModels,
    BedrockModels,
    CerebrasModels,
    CohereModels,
    ConversationSearchTypes,
    ConversationStrategyTypes,
    DeepseekModels,
    EntityState,
    GoogleModels,
    GraphStrategyTypes,
    GroqModels,
    JinaModels,
    MistralModels,
    ModelServiceTypes,
    OpenAIModels,
    OpenAIReasoningEffortLevels,
    OpenAIVisionDetailLevels,
    PromptStrategyTypes,
    ReplicateModels,
    RerankingModelServiceTypes,
    RetrievalStrategyTypes,
    RevisionStrategyTypes,
    SpecificationTypes,
    VoyageModels,
)


class GetSpecification(BaseModel):
    specification: Optional["GetSpecificationSpecification"]


class GetSpecificationSpecification(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "GetSpecificationSpecificationOwner"
    state: EntityState
    type: Optional[SpecificationTypes]
    service_type: Optional[ModelServiceTypes] = Field(alias="serviceType")
    system_prompt: Optional[str] = Field(alias="systemPrompt")
    custom_guidance: Optional[str] = Field(alias="customGuidance")
    custom_instructions: Optional[str] = Field(alias="customInstructions")
    search_type: Optional[ConversationSearchTypes] = Field(alias="searchType")
    number_similar: Optional[int] = Field(alias="numberSimilar")
    strategy: Optional["GetSpecificationSpecificationStrategy"]
    prompt_strategy: Optional["GetSpecificationSpecificationPromptStrategy"] = Field(
        alias="promptStrategy"
    )
    retrieval_strategy: Optional["GetSpecificationSpecificationRetrievalStrategy"] = (
        Field(alias="retrievalStrategy")
    )
    reranking_strategy: Optional["GetSpecificationSpecificationRerankingStrategy"] = (
        Field(alias="rerankingStrategy")
    )
    graph_strategy: Optional["GetSpecificationSpecificationGraphStrategy"] = Field(
        alias="graphStrategy"
    )
    revision_strategy: Optional["GetSpecificationSpecificationRevisionStrategy"] = (
        Field(alias="revisionStrategy")
    )
    azure_ai: Optional["GetSpecificationSpecificationAzureAi"] = Field(alias="azureAI")
    open_ai: Optional["GetSpecificationSpecificationOpenAi"] = Field(alias="openAI")
    azure_open_ai: Optional["GetSpecificationSpecificationAzureOpenAi"] = Field(
        alias="azureOpenAI"
    )
    cohere: Optional["GetSpecificationSpecificationCohere"]
    anthropic: Optional["GetSpecificationSpecificationAnthropic"]
    google: Optional["GetSpecificationSpecificationGoogle"]
    replicate: Optional["GetSpecificationSpecificationReplicate"]
    mistral: Optional["GetSpecificationSpecificationMistral"]
    bedrock: Optional["GetSpecificationSpecificationBedrock"]
    groq: Optional["GetSpecificationSpecificationGroq"]
    cerebras: Optional["GetSpecificationSpecificationCerebras"]
    deepseek: Optional["GetSpecificationSpecificationDeepseek"]
    jina: Optional["GetSpecificationSpecificationJina"]
    voyage: Optional["GetSpecificationSpecificationVoyage"]


class GetSpecificationSpecificationOwner(BaseModel):
    id: str


class GetSpecificationSpecificationStrategy(BaseModel):
    type: Optional[ConversationStrategyTypes]
    message_limit: Optional[int] = Field(alias="messageLimit")
    embed_citations: Optional[bool] = Field(alias="embedCitations")
    flatten_citations: Optional[bool] = Field(alias="flattenCitations")
    enable_facets: Optional[bool] = Field(alias="enableFacets")
    messages_weight: Optional[float] = Field(alias="messagesWeight")
    contents_weight: Optional[float] = Field(alias="contentsWeight")


class GetSpecificationSpecificationPromptStrategy(BaseModel):
    type: PromptStrategyTypes


class GetSpecificationSpecificationRetrievalStrategy(BaseModel):
    type: RetrievalStrategyTypes
    content_limit: Optional[int] = Field(alias="contentLimit")
    disable_fallback: Optional[bool] = Field(alias="disableFallback")


class GetSpecificationSpecificationRerankingStrategy(BaseModel):
    service_type: RerankingModelServiceTypes = Field(alias="serviceType")
    threshold: Optional[float]


class GetSpecificationSpecificationGraphStrategy(BaseModel):
    type: GraphStrategyTypes
    generate_graph: Optional[bool] = Field(alias="generateGraph")
    observable_limit: Optional[int] = Field(alias="observableLimit")


class GetSpecificationSpecificationRevisionStrategy(BaseModel):
    type: RevisionStrategyTypes
    custom_revision: Optional[str] = Field(alias="customRevision")
    count: Optional[int]


class GetSpecificationSpecificationAzureAi(BaseModel):
    token_limit: int = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    key: str
    endpoint: Any
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


class GetSpecificationSpecificationOpenAi(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: OpenAIModels
    key: Optional[str]
    endpoint: Optional[Any]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")
    detail_level: Optional[OpenAIVisionDetailLevels] = Field(alias="detailLevel")
    reasoning_effort: Optional[OpenAIReasoningEffortLevels] = Field(
        alias="reasoningEffort"
    )


class GetSpecificationSpecificationAzureOpenAi(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: AzureOpenAIModels
    key: Optional[str]
    endpoint: Optional[Any]
    deployment_name: Optional[str] = Field(alias="deploymentName")
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


class GetSpecificationSpecificationCohere(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: CohereModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


class GetSpecificationSpecificationAnthropic(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: AnthropicModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]
    enable_thinking: Optional[bool] = Field(alias="enableThinking")
    thinking_token_limit: Optional[int] = Field(alias="thinkingTokenLimit")


class GetSpecificationSpecificationGoogle(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: GoogleModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")
    enable_thinking: Optional[bool] = Field(alias="enableThinking")
    thinking_token_limit: Optional[int] = Field(alias="thinkingTokenLimit")


class GetSpecificationSpecificationReplicate(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: ReplicateModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]


class GetSpecificationSpecificationMistral(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: MistralModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    endpoint: Optional[Any]
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


class GetSpecificationSpecificationBedrock(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: BedrockModels
    access_key: Optional[str] = Field(alias="accessKey")
    secret_access_key: Optional[str] = Field(alias="secretAccessKey")
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]


class GetSpecificationSpecificationGroq(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: GroqModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    endpoint: Optional[Any]
    temperature: Optional[float]
    probability: Optional[float]


class GetSpecificationSpecificationCerebras(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: CerebrasModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    endpoint: Optional[Any]
    temperature: Optional[float]
    probability: Optional[float]


class GetSpecificationSpecificationDeepseek(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: DeepseekModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]


class GetSpecificationSpecificationJina(BaseModel):
    model: JinaModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


class GetSpecificationSpecificationVoyage(BaseModel):
    model: VoyageModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


GetSpecification.model_rebuild()
GetSpecificationSpecification.model_rebuild()



================================================
FILE: graphlit_api/get_user.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AuthenticationServiceTypes,
    ConnectorTypes,
    EntityState,
    IntegrationServiceTypes,
    UserTypes,
)


class GetUser(BaseModel):
    user: Optional["GetUserUser"]


class GetUserUser(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "GetUserUserOwner"
    state: EntityState
    type: Optional[UserTypes]
    identifier: str
    connectors: Optional[List[Optional["GetUserUserConnectors"]]]


class GetUserUserOwner(BaseModel):
    id: str


class GetUserUserConnectors(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ConnectorTypes]
    authentication: Optional["GetUserUserConnectorsAuthentication"]
    integration: Optional["GetUserUserConnectorsIntegration"]


class GetUserUserConnectorsAuthentication(BaseModel):
    type: AuthenticationServiceTypes
    microsoft: Optional["GetUserUserConnectorsAuthenticationMicrosoft"]
    google: Optional["GetUserUserConnectorsAuthenticationGoogle"]


class GetUserUserConnectorsAuthenticationMicrosoft(BaseModel):
    tenant_id: str = Field(alias="tenantId")
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class GetUserUserConnectorsAuthenticationGoogle(BaseModel):
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class GetUserUserConnectorsIntegration(BaseModel):
    type: IntegrationServiceTypes
    uri: Optional[str]
    slack: Optional["GetUserUserConnectorsIntegrationSlack"]
    email: Optional["GetUserUserConnectorsIntegrationEmail"]
    twitter: Optional["GetUserUserConnectorsIntegrationTwitter"]


class GetUserUserConnectorsIntegrationSlack(BaseModel):
    token: str
    channel: str


class GetUserUserConnectorsIntegrationEmail(BaseModel):
    from_: str = Field(alias="from")
    subject: str
    to: List[str]


class GetUserUserConnectorsIntegrationTwitter(BaseModel):
    consumer_key: str = Field(alias="consumerKey")
    consumer_secret: str = Field(alias="consumerSecret")
    access_token_key: str = Field(alias="accessTokenKey")
    access_token_secret: str = Field(alias="accessTokenSecret")


GetUser.model_rebuild()
GetUserUser.model_rebuild()
GetUserUserConnectors.model_rebuild()
GetUserUserConnectorsAuthentication.model_rebuild()
GetUserUserConnectorsIntegration.model_rebuild()



================================================
FILE: graphlit_api/get_workflow.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AssemblyAIModels,
    AzureDocumentIntelligenceModels,
    AzureDocumentIntelligenceVersions,
    ContentClassificationServiceTypes,
    ContentIndexingServiceTypes,
    ContentTypes,
    DeepgramModels,
    EntityEnrichmentServiceTypes,
    EntityExtractionServiceTypes,
    EntityState,
    FilePreparationServiceTypes,
    FileTypes,
    IntegrationServiceTypes,
    LinkTypes,
    ObservableTypes,
    RegexSourceTypes,
    StoragePolicyTypes,
    SummarizationTypes,
)


class GetWorkflow(BaseModel):
    workflow: Optional["GetWorkflowWorkflow"]


class GetWorkflowWorkflow(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "GetWorkflowWorkflowOwner"
    state: EntityState
    ingestion: Optional["GetWorkflowWorkflowIngestion"]
    indexing: Optional["GetWorkflowWorkflowIndexing"]
    preparation: Optional["GetWorkflowWorkflowPreparation"]
    extraction: Optional["GetWorkflowWorkflowExtraction"]
    classification: Optional["GetWorkflowWorkflowClassification"]
    enrichment: Optional["GetWorkflowWorkflowEnrichment"]
    storage: Optional["GetWorkflowWorkflowStorage"]
    actions: Optional[List[Optional["GetWorkflowWorkflowActions"]]]


class GetWorkflowWorkflowOwner(BaseModel):
    id: str


class GetWorkflowWorkflowIngestion(BaseModel):
    if_: Optional["GetWorkflowWorkflowIngestionIf"] = Field(alias="if")
    collections: Optional[List[Optional["GetWorkflowWorkflowIngestionCollections"]]]
    observations: Optional[List[Optional["GetWorkflowWorkflowIngestionObservations"]]]
    enable_email_collections: Optional[bool] = Field(alias="enableEmailCollections")


class GetWorkflowWorkflowIngestionIf(BaseModel):
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")


class GetWorkflowWorkflowIngestionCollections(BaseModel):
    id: str


class GetWorkflowWorkflowIngestionObservations(BaseModel):
    type: ObservableTypes
    observable: "GetWorkflowWorkflowIngestionObservationsObservable"


class GetWorkflowWorkflowIngestionObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class GetWorkflowWorkflowIndexing(BaseModel):
    jobs: Optional[List[Optional["GetWorkflowWorkflowIndexingJobs"]]]


class GetWorkflowWorkflowIndexingJobs(BaseModel):
    connector: Optional["GetWorkflowWorkflowIndexingJobsConnector"]


class GetWorkflowWorkflowIndexingJobsConnector(BaseModel):
    type: Optional[ContentIndexingServiceTypes]
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")


class GetWorkflowWorkflowPreparation(BaseModel):
    enable_unblocked_capture: Optional[bool] = Field(alias="enableUnblockedCapture")
    disable_smart_capture: Optional[bool] = Field(alias="disableSmartCapture")
    summarizations: Optional[
        List[Optional["GetWorkflowWorkflowPreparationSummarizations"]]
    ]
    jobs: Optional[List[Optional["GetWorkflowWorkflowPreparationJobs"]]]


class GetWorkflowWorkflowPreparationSummarizations(BaseModel):
    type: SummarizationTypes
    specification: Optional["GetWorkflowWorkflowPreparationSummarizationsSpecification"]
    tokens: Optional[int]
    items: Optional[int]
    prompt: Optional[str]


class GetWorkflowWorkflowPreparationSummarizationsSpecification(BaseModel):
    id: str


class GetWorkflowWorkflowPreparationJobs(BaseModel):
    connector: Optional["GetWorkflowWorkflowPreparationJobsConnector"]


class GetWorkflowWorkflowPreparationJobsConnector(BaseModel):
    type: FilePreparationServiceTypes
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    azure_document: Optional[
        "GetWorkflowWorkflowPreparationJobsConnectorAzureDocument"
    ] = Field(alias="azureDocument")
    deepgram: Optional["GetWorkflowWorkflowPreparationJobsConnectorDeepgram"]
    assembly_ai: Optional["GetWorkflowWorkflowPreparationJobsConnectorAssemblyAi"] = (
        Field(alias="assemblyAI")
    )
    page: Optional["GetWorkflowWorkflowPreparationJobsConnectorPage"]
    document: Optional["GetWorkflowWorkflowPreparationJobsConnectorDocument"]
    email: Optional["GetWorkflowWorkflowPreparationJobsConnectorEmail"]
    model_document: Optional[
        "GetWorkflowWorkflowPreparationJobsConnectorModelDocument"
    ] = Field(alias="modelDocument")
    mistral: Optional["GetWorkflowWorkflowPreparationJobsConnectorMistral"]


class GetWorkflowWorkflowPreparationJobsConnectorAzureDocument(BaseModel):
    version: Optional[AzureDocumentIntelligenceVersions]
    model: Optional[AzureDocumentIntelligenceModels]
    endpoint: Optional[Any]
    key: Optional[str]


class GetWorkflowWorkflowPreparationJobsConnectorDeepgram(BaseModel):
    model: Optional[DeepgramModels]
    key: Optional[str]
    enable_redaction: Optional[bool] = Field(alias="enableRedaction")
    enable_speaker_diarization: Optional[bool] = Field(alias="enableSpeakerDiarization")
    detect_language: Optional[bool] = Field(alias="detectLanguage")
    language: Optional[str]


class GetWorkflowWorkflowPreparationJobsConnectorAssemblyAi(BaseModel):
    model: Optional[AssemblyAIModels]
    key: Optional[str]
    enable_redaction: Optional[bool] = Field(alias="enableRedaction")
    enable_speaker_diarization: Optional[bool] = Field(alias="enableSpeakerDiarization")
    detect_language: Optional[bool] = Field(alias="detectLanguage")
    language: Optional[str]


class GetWorkflowWorkflowPreparationJobsConnectorPage(BaseModel):
    enable_screenshot: Optional[bool] = Field(alias="enableScreenshot")


class GetWorkflowWorkflowPreparationJobsConnectorDocument(BaseModel):
    include_images: Optional[bool] = Field(alias="includeImages")


class GetWorkflowWorkflowPreparationJobsConnectorEmail(BaseModel):
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class GetWorkflowWorkflowPreparationJobsConnectorModelDocument(BaseModel):
    specification: Optional[
        "GetWorkflowWorkflowPreparationJobsConnectorModelDocumentSpecification"
    ]


class GetWorkflowWorkflowPreparationJobsConnectorModelDocumentSpecification(BaseModel):
    id: str


class GetWorkflowWorkflowPreparationJobsConnectorMistral(BaseModel):
    key: Optional[str]


class GetWorkflowWorkflowExtraction(BaseModel):
    jobs: Optional[List[Optional["GetWorkflowWorkflowExtractionJobs"]]]


class GetWorkflowWorkflowExtractionJobs(BaseModel):
    connector: Optional["GetWorkflowWorkflowExtractionJobsConnector"]


class GetWorkflowWorkflowExtractionJobsConnector(BaseModel):
    type: EntityExtractionServiceTypes
    content_types: Optional[List[ContentTypes]] = Field(alias="contentTypes")
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    extracted_types: Optional[List[ObservableTypes]] = Field(alias="extractedTypes")
    extracted_count: Optional[int] = Field(alias="extractedCount")
    azure_text: Optional["GetWorkflowWorkflowExtractionJobsConnectorAzureText"] = Field(
        alias="azureText"
    )
    azure_image: Optional["GetWorkflowWorkflowExtractionJobsConnectorAzureImage"] = (
        Field(alias="azureImage")
    )
    model_image: Optional["GetWorkflowWorkflowExtractionJobsConnectorModelImage"] = (
        Field(alias="modelImage")
    )
    model_text: Optional["GetWorkflowWorkflowExtractionJobsConnectorModelText"] = Field(
        alias="modelText"
    )


class GetWorkflowWorkflowExtractionJobsConnectorAzureText(BaseModel):
    confidence_threshold: Optional[float] = Field(alias="confidenceThreshold")
    enable_pii: Optional[bool] = Field(alias="enablePII")


class GetWorkflowWorkflowExtractionJobsConnectorAzureImage(BaseModel):
    confidence_threshold: Optional[float] = Field(alias="confidenceThreshold")


class GetWorkflowWorkflowExtractionJobsConnectorModelImage(BaseModel):
    specification: Optional[
        "GetWorkflowWorkflowExtractionJobsConnectorModelImageSpecification"
    ]


class GetWorkflowWorkflowExtractionJobsConnectorModelImageSpecification(BaseModel):
    id: str


class GetWorkflowWorkflowExtractionJobsConnectorModelText(BaseModel):
    specification: Optional[
        "GetWorkflowWorkflowExtractionJobsConnectorModelTextSpecification"
    ]


class GetWorkflowWorkflowExtractionJobsConnectorModelTextSpecification(BaseModel):
    id: str


class GetWorkflowWorkflowClassification(BaseModel):
    jobs: Optional[List[Optional["GetWorkflowWorkflowClassificationJobs"]]]


class GetWorkflowWorkflowClassificationJobs(BaseModel):
    connector: Optional["GetWorkflowWorkflowClassificationJobsConnector"]


class GetWorkflowWorkflowClassificationJobsConnector(BaseModel):
    type: ContentClassificationServiceTypes
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")
    model: Optional["GetWorkflowWorkflowClassificationJobsConnectorModel"]
    regex: Optional["GetWorkflowWorkflowClassificationJobsConnectorRegex"]


class GetWorkflowWorkflowClassificationJobsConnectorModel(BaseModel):
    specification: Optional[
        "GetWorkflowWorkflowClassificationJobsConnectorModelSpecification"
    ]
    rules: Optional[
        List[Optional["GetWorkflowWorkflowClassificationJobsConnectorModelRules"]]
    ]


class GetWorkflowWorkflowClassificationJobsConnectorModelSpecification(BaseModel):
    id: str


class GetWorkflowWorkflowClassificationJobsConnectorModelRules(BaseModel):
    then: Optional[str]
    if_: Optional[str] = Field(alias="if")


class GetWorkflowWorkflowClassificationJobsConnectorRegex(BaseModel):
    rules: Optional[
        List[Optional["GetWorkflowWorkflowClassificationJobsConnectorRegexRules"]]
    ]


class GetWorkflowWorkflowClassificationJobsConnectorRegexRules(BaseModel):
    then: Optional[str]
    type: Optional[RegexSourceTypes]
    path: Optional[str]
    matches: Optional[str]


class GetWorkflowWorkflowEnrichment(BaseModel):
    link: Optional["GetWorkflowWorkflowEnrichmentLink"]
    jobs: Optional[List[Optional["GetWorkflowWorkflowEnrichmentJobs"]]]


class GetWorkflowWorkflowEnrichmentLink(BaseModel):
    enable_crawling: Optional[bool] = Field(alias="enableCrawling")
    allowed_domains: Optional[List[str]] = Field(alias="allowedDomains")
    excluded_domains: Optional[List[str]] = Field(alias="excludedDomains")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")
    allowed_links: Optional[List[LinkTypes]] = Field(alias="allowedLinks")
    excluded_links: Optional[List[LinkTypes]] = Field(alias="excludedLinks")
    allowed_files: Optional[List[FileTypes]] = Field(alias="allowedFiles")
    excluded_files: Optional[List[FileTypes]] = Field(alias="excludedFiles")
    allow_content_domain: Optional[bool] = Field(alias="allowContentDomain")
    maximum_links: Optional[int] = Field(alias="maximumLinks")


class GetWorkflowWorkflowEnrichmentJobs(BaseModel):
    connector: Optional["GetWorkflowWorkflowEnrichmentJobsConnector"]


class GetWorkflowWorkflowEnrichmentJobsConnector(BaseModel):
    type: Optional[EntityEnrichmentServiceTypes]
    enriched_types: Optional[List[Optional[ObservableTypes]]] = Field(
        alias="enrichedTypes"
    )
    fhir: Optional["GetWorkflowWorkflowEnrichmentJobsConnectorFhir"]
    diffbot: Optional["GetWorkflowWorkflowEnrichmentJobsConnectorDiffbot"]


class GetWorkflowWorkflowEnrichmentJobsConnectorFhir(BaseModel):
    endpoint: Optional[Any]


class GetWorkflowWorkflowEnrichmentJobsConnectorDiffbot(BaseModel):
    key: Optional[Any]


class GetWorkflowWorkflowStorage(BaseModel):
    policy: Optional["GetWorkflowWorkflowStoragePolicy"]


class GetWorkflowWorkflowStoragePolicy(BaseModel):
    type: Optional[StoragePolicyTypes]
    allow_duplicates: Optional[bool] = Field(alias="allowDuplicates")


class GetWorkflowWorkflowActions(BaseModel):
    connector: Optional["GetWorkflowWorkflowActionsConnector"]


class GetWorkflowWorkflowActionsConnector(BaseModel):
    type: IntegrationServiceTypes
    uri: Optional[str]
    slack: Optional["GetWorkflowWorkflowActionsConnectorSlack"]
    email: Optional["GetWorkflowWorkflowActionsConnectorEmail"]
    twitter: Optional["GetWorkflowWorkflowActionsConnectorTwitter"]


class GetWorkflowWorkflowActionsConnectorSlack(BaseModel):
    token: str
    channel: str


class GetWorkflowWorkflowActionsConnectorEmail(BaseModel):
    from_: str = Field(alias="from")
    subject: str
    to: List[str]


class GetWorkflowWorkflowActionsConnectorTwitter(BaseModel):
    consumer_key: str = Field(alias="consumerKey")
    consumer_secret: str = Field(alias="consumerSecret")
    access_token_key: str = Field(alias="accessTokenKey")
    access_token_secret: str = Field(alias="accessTokenSecret")


GetWorkflow.model_rebuild()
GetWorkflowWorkflow.model_rebuild()
GetWorkflowWorkflowIngestion.model_rebuild()
GetWorkflowWorkflowIngestionObservations.model_rebuild()
GetWorkflowWorkflowIndexing.model_rebuild()
GetWorkflowWorkflowIndexingJobs.model_rebuild()
GetWorkflowWorkflowPreparation.model_rebuild()
GetWorkflowWorkflowPreparationSummarizations.model_rebuild()
GetWorkflowWorkflowPreparationJobs.model_rebuild()
GetWorkflowWorkflowPreparationJobsConnector.model_rebuild()
GetWorkflowWorkflowPreparationJobsConnectorModelDocument.model_rebuild()
GetWorkflowWorkflowExtraction.model_rebuild()
GetWorkflowWorkflowExtractionJobs.model_rebuild()
GetWorkflowWorkflowExtractionJobsConnector.model_rebuild()
GetWorkflowWorkflowExtractionJobsConnectorModelImage.model_rebuild()
GetWorkflowWorkflowExtractionJobsConnectorModelText.model_rebuild()
GetWorkflowWorkflowClassification.model_rebuild()
GetWorkflowWorkflowClassificationJobs.model_rebuild()
GetWorkflowWorkflowClassificationJobsConnector.model_rebuild()
GetWorkflowWorkflowClassificationJobsConnectorModel.model_rebuild()
GetWorkflowWorkflowClassificationJobsConnectorRegex.model_rebuild()
GetWorkflowWorkflowEnrichment.model_rebuild()
GetWorkflowWorkflowEnrichmentJobs.model_rebuild()
GetWorkflowWorkflowEnrichmentJobsConnector.model_rebuild()
GetWorkflowWorkflowStorage.model_rebuild()
GetWorkflowWorkflowActions.model_rebuild()
GetWorkflowWorkflowActionsConnector.model_rebuild()



================================================
FILE: graphlit_api/ingest_batch.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ObservableTypes,
    OccurrenceTypes,
)


class IngestBatch(BaseModel):
    ingest_batch: Optional[List[Optional["IngestBatchIngestBatch"]]] = Field(
        alias="ingestBatch"
    )


class IngestBatchIngestBatch(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    uri: Optional[Any]
    collections: Optional[List[Optional["IngestBatchIngestBatchCollections"]]]
    observations: Optional[List[Optional["IngestBatchIngestBatchObservations"]]]


class IngestBatchIngestBatchCollections(BaseModel):
    id: str
    name: str


class IngestBatchIngestBatchObservations(BaseModel):
    id: str
    type: ObservableTypes
    observable: "IngestBatchIngestBatchObservationsObservable"
    related: Optional["IngestBatchIngestBatchObservationsRelated"]
    related_type: Optional[ObservableTypes] = Field(alias="relatedType")
    relation: Optional[str]
    occurrences: Optional[
        List[Optional["IngestBatchIngestBatchObservationsOccurrences"]]
    ]
    state: EntityState


class IngestBatchIngestBatchObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class IngestBatchIngestBatchObservationsRelated(BaseModel):
    id: str
    name: Optional[str]


class IngestBatchIngestBatchObservationsOccurrences(BaseModel):
    type: Optional[OccurrenceTypes]
    confidence: Optional[float]
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_index: Optional[int] = Field(alias="pageIndex")
    bounding_box: Optional[
        "IngestBatchIngestBatchObservationsOccurrencesBoundingBox"
    ] = Field(alias="boundingBox")


class IngestBatchIngestBatchObservationsOccurrencesBoundingBox(BaseModel):
    left: Optional[float]
    top: Optional[float]
    width: Optional[float]
    height: Optional[float]


IngestBatch.model_rebuild()
IngestBatchIngestBatch.model_rebuild()
IngestBatchIngestBatchObservations.model_rebuild()
IngestBatchIngestBatchObservationsOccurrences.model_rebuild()



================================================
FILE: graphlit_api/ingest_encoded_file.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ObservableTypes,
    OccurrenceTypes,
)


class IngestEncodedFile(BaseModel):
    ingest_encoded_file: Optional["IngestEncodedFileIngestEncodedFile"] = Field(
        alias="ingestEncodedFile"
    )


class IngestEncodedFileIngestEncodedFile(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    uri: Optional[Any]
    collections: Optional[
        List[Optional["IngestEncodedFileIngestEncodedFileCollections"]]
    ]
    observations: Optional[
        List[Optional["IngestEncodedFileIngestEncodedFileObservations"]]
    ]


class IngestEncodedFileIngestEncodedFileCollections(BaseModel):
    id: str
    name: str


class IngestEncodedFileIngestEncodedFileObservations(BaseModel):
    id: str
    type: ObservableTypes
    observable: "IngestEncodedFileIngestEncodedFileObservationsObservable"
    related: Optional["IngestEncodedFileIngestEncodedFileObservationsRelated"]
    related_type: Optional[ObservableTypes] = Field(alias="relatedType")
    relation: Optional[str]
    occurrences: Optional[
        List[Optional["IngestEncodedFileIngestEncodedFileObservationsOccurrences"]]
    ]
    state: EntityState


class IngestEncodedFileIngestEncodedFileObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class IngestEncodedFileIngestEncodedFileObservationsRelated(BaseModel):
    id: str
    name: Optional[str]


class IngestEncodedFileIngestEncodedFileObservationsOccurrences(BaseModel):
    type: Optional[OccurrenceTypes]
    confidence: Optional[float]
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_index: Optional[int] = Field(alias="pageIndex")
    bounding_box: Optional[
        "IngestEncodedFileIngestEncodedFileObservationsOccurrencesBoundingBox"
    ] = Field(alias="boundingBox")


class IngestEncodedFileIngestEncodedFileObservationsOccurrencesBoundingBox(BaseModel):
    left: Optional[float]
    top: Optional[float]
    width: Optional[float]
    height: Optional[float]


IngestEncodedFile.model_rebuild()
IngestEncodedFileIngestEncodedFile.model_rebuild()
IngestEncodedFileIngestEncodedFileObservations.model_rebuild()
IngestEncodedFileIngestEncodedFileObservationsOccurrences.model_rebuild()



================================================
FILE: graphlit_api/ingest_memory.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ObservableTypes,
    OccurrenceTypes,
)


class IngestMemory(BaseModel):
    ingest_memory: Optional["IngestMemoryIngestMemory"] = Field(alias="ingestMemory")


class IngestMemoryIngestMemory(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    uri: Optional[Any]
    collections: Optional[List[Optional["IngestMemoryIngestMemoryCollections"]]]
    observations: Optional[List[Optional["IngestMemoryIngestMemoryObservations"]]]


class IngestMemoryIngestMemoryCollections(BaseModel):
    id: str
    name: str


class IngestMemoryIngestMemoryObservations(BaseModel):
    id: str
    type: ObservableTypes
    observable: "IngestMemoryIngestMemoryObservationsObservable"
    related: Optional["IngestMemoryIngestMemoryObservationsRelated"]
    related_type: Optional[ObservableTypes] = Field(alias="relatedType")
    relation: Optional[str]
    occurrences: Optional[
        List[Optional["IngestMemoryIngestMemoryObservationsOccurrences"]]
    ]
    state: EntityState


class IngestMemoryIngestMemoryObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class IngestMemoryIngestMemoryObservationsRelated(BaseModel):
    id: str
    name: Optional[str]


class IngestMemoryIngestMemoryObservationsOccurrences(BaseModel):
    type: Optional[OccurrenceTypes]
    confidence: Optional[float]
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_index: Optional[int] = Field(alias="pageIndex")
    bounding_box: Optional[
        "IngestMemoryIngestMemoryObservationsOccurrencesBoundingBox"
    ] = Field(alias="boundingBox")


class IngestMemoryIngestMemoryObservationsOccurrencesBoundingBox(BaseModel):
    left: Optional[float]
    top: Optional[float]
    width: Optional[float]
    height: Optional[float]


IngestMemory.model_rebuild()
IngestMemoryIngestMemory.model_rebuild()
IngestMemoryIngestMemoryObservations.model_rebuild()
IngestMemoryIngestMemoryObservationsOccurrences.model_rebuild()



================================================
FILE: graphlit_api/ingest_text.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ObservableTypes,
    OccurrenceTypes,
)


class IngestText(BaseModel):
    ingest_text: Optional["IngestTextIngestText"] = Field(alias="ingestText")


class IngestTextIngestText(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    uri: Optional[Any]
    collections: Optional[List[Optional["IngestTextIngestTextCollections"]]]
    observations: Optional[List[Optional["IngestTextIngestTextObservations"]]]


class IngestTextIngestTextCollections(BaseModel):
    id: str
    name: str


class IngestTextIngestTextObservations(BaseModel):
    id: str
    type: ObservableTypes
    observable: "IngestTextIngestTextObservationsObservable"
    related: Optional["IngestTextIngestTextObservationsRelated"]
    related_type: Optional[ObservableTypes] = Field(alias="relatedType")
    relation: Optional[str]
    occurrences: Optional[List[Optional["IngestTextIngestTextObservationsOccurrences"]]]
    state: EntityState


class IngestTextIngestTextObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class IngestTextIngestTextObservationsRelated(BaseModel):
    id: str
    name: Optional[str]


class IngestTextIngestTextObservationsOccurrences(BaseModel):
    type: Optional[OccurrenceTypes]
    confidence: Optional[float]
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_index: Optional[int] = Field(alias="pageIndex")
    bounding_box: Optional["IngestTextIngestTextObservationsOccurrencesBoundingBox"] = (
        Field(alias="boundingBox")
    )


class IngestTextIngestTextObservationsOccurrencesBoundingBox(BaseModel):
    left: Optional[float]
    top: Optional[float]
    width: Optional[float]
    height: Optional[float]


IngestText.model_rebuild()
IngestTextIngestText.model_rebuild()
IngestTextIngestTextObservations.model_rebuild()
IngestTextIngestTextObservationsOccurrences.model_rebuild()



================================================
FILE: graphlit_api/ingest_text_batch.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ObservableTypes,
    OccurrenceTypes,
)


class IngestTextBatch(BaseModel):
    ingest_text_batch: Optional[List[Optional["IngestTextBatchIngestTextBatch"]]] = (
        Field(alias="ingestTextBatch")
    )


class IngestTextBatchIngestTextBatch(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    uri: Optional[Any]
    collections: Optional[List[Optional["IngestTextBatchIngestTextBatchCollections"]]]
    observations: Optional[List[Optional["IngestTextBatchIngestTextBatchObservations"]]]


class IngestTextBatchIngestTextBatchCollections(BaseModel):
    id: str
    name: str


class IngestTextBatchIngestTextBatchObservations(BaseModel):
    id: str
    type: ObservableTypes
    observable: "IngestTextBatchIngestTextBatchObservationsObservable"
    related: Optional["IngestTextBatchIngestTextBatchObservationsRelated"]
    related_type: Optional[ObservableTypes] = Field(alias="relatedType")
    relation: Optional[str]
    occurrences: Optional[
        List[Optional["IngestTextBatchIngestTextBatchObservationsOccurrences"]]
    ]
    state: EntityState


class IngestTextBatchIngestTextBatchObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class IngestTextBatchIngestTextBatchObservationsRelated(BaseModel):
    id: str
    name: Optional[str]


class IngestTextBatchIngestTextBatchObservationsOccurrences(BaseModel):
    type: Optional[OccurrenceTypes]
    confidence: Optional[float]
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_index: Optional[int] = Field(alias="pageIndex")
    bounding_box: Optional[
        "IngestTextBatchIngestTextBatchObservationsOccurrencesBoundingBox"
    ] = Field(alias="boundingBox")


class IngestTextBatchIngestTextBatchObservationsOccurrencesBoundingBox(BaseModel):
    left: Optional[float]
    top: Optional[float]
    width: Optional[float]
    height: Optional[float]


IngestTextBatch.model_rebuild()
IngestTextBatchIngestTextBatch.model_rebuild()
IngestTextBatchIngestTextBatchObservations.model_rebuild()
IngestTextBatchIngestTextBatchObservationsOccurrences.model_rebuild()



================================================
FILE: graphlit_api/ingest_uri.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ObservableTypes,
    OccurrenceTypes,
)


class IngestUri(BaseModel):
    ingest_uri: Optional["IngestUriIngestUri"] = Field(alias="ingestUri")


class IngestUriIngestUri(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    uri: Optional[Any]
    collections: Optional[List[Optional["IngestUriIngestUriCollections"]]]
    observations: Optional[List[Optional["IngestUriIngestUriObservations"]]]


class IngestUriIngestUriCollections(BaseModel):
    id: str
    name: str


class IngestUriIngestUriObservations(BaseModel):
    id: str
    type: ObservableTypes
    observable: "IngestUriIngestUriObservationsObservable"
    related: Optional["IngestUriIngestUriObservationsRelated"]
    related_type: Optional[ObservableTypes] = Field(alias="relatedType")
    relation: Optional[str]
    occurrences: Optional[List[Optional["IngestUriIngestUriObservationsOccurrences"]]]
    state: EntityState


class IngestUriIngestUriObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class IngestUriIngestUriObservationsRelated(BaseModel):
    id: str
    name: Optional[str]


class IngestUriIngestUriObservationsOccurrences(BaseModel):
    type: Optional[OccurrenceTypes]
    confidence: Optional[float]
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_index: Optional[int] = Field(alias="pageIndex")
    bounding_box: Optional["IngestUriIngestUriObservationsOccurrencesBoundingBox"] = (
        Field(alias="boundingBox")
    )


class IngestUriIngestUriObservationsOccurrencesBoundingBox(BaseModel):
    left: Optional[float]
    top: Optional[float]
    width: Optional[float]
    height: Optional[float]


IngestUri.model_rebuild()
IngestUriIngestUri.model_rebuild()
IngestUriIngestUriObservations.model_rebuild()
IngestUriIngestUriObservationsOccurrences.model_rebuild()



================================================
FILE: graphlit_api/input_types.py
================================================
# Generated by ariadne-codegen
# Source: https://data-scus.graphlit.io/api/v1/graphql

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AlertTypes,
    AnthropicModels,
    AssemblyAIModels,
    AuthenticationServiceTypes,
    AzureDocumentIntelligenceModels,
    AzureDocumentIntelligenceVersions,
    AzureOpenAIModels,
    BedrockModels,
    CategoryFacetTypes,
    CerebrasModels,
    CohereModels,
    CollectionTypes,
    ConnectorTypes,
    ContentClassificationServiceTypes,
    ContentFacetTypes,
    ContentIndexingServiceTypes,
    ContentPublishingFormats,
    ContentPublishingServiceTypes,
    ContentTypes,
    ConversationRoleTypes,
    ConversationSearchTypes,
    ConversationStrategyTypes,
    ConversationTypes,
    DeepgramModels,
    DeepseekModels,
    ElevenLabsModels,
    EmailListingTypes,
    EntityEnrichmentServiceTypes,
    EntityExtractionServiceTypes,
    EntityState,
    EnvironmentTypes,
    EventFacetTypes,
    FeedListingTypes,
    FeedServiceTypes,
    FeedTypes,
    FilePreparationServiceTypes,
    FileTypes,
    GoogleDriveAuthenticationTypes,
    GoogleModels,
    GraphStrategyTypes,
    GroqModels,
    H3ResolutionTypes,
    ImageProjectionTypes,
    IntegrationServiceTypes,
    JinaModels,
    LabelFacetTypes,
    LinkTypes,
    MailImportance,
    MailPriority,
    MailSensitivity,
    MedicalConditionFacetTypes,
    MedicalContraindicationFacetTypes,
    MedicalDeviceFacetTypes,
    MedicalDrugClassFacetTypes,
    MedicalDrugFacetTypes,
    MedicalGuidelineFacetTypes,
    MedicalIndicationFacetTypes,
    MedicalProcedureFacetTypes,
    MedicalStudyFacetTypes,
    MedicalTestFacetTypes,
    MedicalTherapyFacetTypes,
    MetadataTypes,
    MistralModels,
    ModelServiceTypes,
    ModelTypes,
    NotionTypes,
    ObservableTypes,
    OccurrenceTypes,
    OpenAIImageModels,
    OpenAIModels,
    OpenAIReasoningEffortLevels,
    OpenAIVisionDetailLevels,
    OrderByTypes,
    OrderDirectionTypes,
    OrganizationFacetTypes,
    OrientationTypes,
    PersonFacetTypes,
    PlaceFacetTypes,
    PolicyTimeTypes,
    ProductFacetTypes,
    PromptStrategyTypes,
    RegexSourceTypes,
    ReplicateModels,
    RepoFacetTypes,
    RerankingModelServiceTypes,
    ResourceConnectorTypes,
    RetrievalStrategyTypes,
    RevisionStrategyTypes,
    SearchQueryTypes,
    SearchServiceTypes,
    SearchTypes,
    SharePointAuthenticationTypes,
    SoftwareFacetTypes,
    SpecificationTypes,
    StoragePolicyTypes,
    SummarizationTypes,
    TimedPolicyRecurrenceTypes,
    TimeIntervalTypes,
    TrelloTypes,
    TwitterListingTypes,
    UnitTypes,
    UserTypes,
    VoyageModels,
    YouTubeTypes,
)


class MedicalDrugClassFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalDrugClassFacetTypes] = None


class OrganizationInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None
    founding_date: Optional[Any] = Field(alias="foundingDate", default=None)
    industries: Optional[List[Optional[str]]] = None
    revenue_currency: Optional[str] = Field(alias="revenueCurrency", default=None)
    revenue: Optional[Any] = None
    investment_currency: Optional[str] = Field(alias="investmentCurrency", default=None)
    investment: Optional[Any] = None


class ContentCriteriaInput(BaseModel):
    in_last: Optional[Any] = Field(alias="inLast", default=None)
    date_range: Optional["DateRangeInput"] = Field(alias="dateRange", default=None)
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeInput"] = Field(
        alias="creationDateRange", default=None
    )
    types: Optional[List[ContentTypes]] = None
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes", default=None)
    similar_contents: Optional[List["EntityReferenceInput"]] = Field(
        alias="similarContents", default=None
    )
    contents: Optional[List["EntityReferenceInput"]] = None
    feeds: Optional[List["EntityReferenceInput"]] = None
    workflows: Optional[List["EntityReferenceInput"]] = None
    collections: Optional[List["EntityReferenceInput"]] = None
    observations: Optional[List["ObservationCriteriaInput"]] = None
    or_: Optional[List["ContentCriteriaLevelInput"]] = Field(alias="or", default=None)
    and_: Optional[List["ContentCriteriaLevelInput"]] = Field(alias="and", default=None)


class DiscordFeedPropertiesInput(BaseModel):
    type: Optional[FeedListingTypes] = None
    token: str
    channel: str
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class AtlassianJiraFeedPropertiesUpdateInput(BaseModel):
    uri: Optional[Any] = None
    project: Optional[str] = None
    email: Optional[str] = None
    token: Optional[str] = None
    offset: Optional[Any] = None


class EventFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[EventFacetTypes] = None


class AddressFilter(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress", default=None)
    city: Optional[str] = None
    region: Optional[str] = None
    country: Optional[str] = None
    postal_code: Optional[str] = Field(alias="postalCode", default=None)


class StoragePolicyInput(BaseModel):
    type: Optional[StoragePolicyTypes] = None
    allow_duplicates: Optional[bool] = Field(alias="allowDuplicates", default=None)


class ContentIndexingConnectorInput(BaseModel):
    type: Optional[ContentIndexingServiceTypes] = None
    content_type: Optional[ContentTypes] = Field(alias="contentType", default=None)
    file_type: Optional[FileTypes] = Field(alias="fileType", default=None)


class MetadataUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    mime_type: Optional[str] = Field(alias="mimeType", default=None)
    value: Optional[str] = None
    content: Optional["EntityReferenceInput"] = None


class CerebrasModelPropertiesInput(BaseModel):
    model: CerebrasModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )


class MedicalContraindicationFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalContraindicationFacetTypes] = None


class MedicalIndicationUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class MedicalIndicationFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalIndicationFacetTypes] = None


class OpenAIModelPropertiesUpdateInput(BaseModel):
    model: Optional[OpenAIModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)
    detail_level: Optional[OpenAIVisionDetailLevels] = Field(
        alias="detailLevel", default=None
    )
    reasoning_effort: Optional[OpenAIReasoningEffortLevels] = Field(
        alias="reasoningEffort", default=None
    )


class StorageWorkflowStageInput(BaseModel):
    policy: Optional["StoragePolicyInput"] = None


class WorkflowFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )


class GraphStrategyInput(BaseModel):
    type: Optional[GraphStrategyTypes] = None
    generate_graph: Optional[bool] = Field(alias="generateGraph", default=None)
    observable_limit: Optional[int] = Field(alias="observableLimit", default=None)


class MedicalIndicationInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class BoxFeedPropertiesInput(BaseModel):
    folder_id: Optional[str] = Field(alias="folderId", default=None)
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")
    refresh_token: str = Field(alias="refreshToken")
    redirect_uri: str = Field(alias="redirectUri")


class MicrosoftAuthenticationPropertiesInput(BaseModel):
    tenant_id: str = Field(alias="tenantId")
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class UserFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    identifier: Optional[str] = None


class ReplicateModelPropertiesUpdateInput(BaseModel):
    model: Optional[ReplicateModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )


class SearchFeedPropertiesInput(BaseModel):
    type: Optional[SearchServiceTypes] = None
    text: str
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class AzureFileFeedPropertiesInput(BaseModel):
    storage_access_key: str = Field(alias="storageAccessKey")
    account_name: str = Field(alias="accountName")
    share_name: str = Field(alias="shareName")
    prefix: Optional[str] = None


class MedicalTherapyFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalTherapyFacetTypes] = None


class RegexContentClassificationPropertiesInput(BaseModel):
    rules: Optional[List[Optional["RegexClassificationRuleInput"]]] = None


class ProductFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    production_date_range: Optional["DateRangeFilter"] = Field(
        alias="productionDateRange", default=None
    )
    release_date_range: Optional["DateRangeFilter"] = Field(
        alias="releaseDateRange", default=None
    )
    sku: Optional[str] = None
    upc: Optional[str] = None
    manufacturer: Optional[str] = None
    brand: Optional[str] = None
    model: Optional[str] = None
    similar_products: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarProducts", default=None
    )


class OneDriveFeedPropertiesInput(BaseModel):
    files: Optional[List[Optional[str]]] = None
    folder_id: Optional[str] = Field(alias="folderId", default=None)
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")
    refresh_token: str = Field(alias="refreshToken")


class RSSFeedPropertiesInput(BaseModel):
    uri: Any
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class EnrichmentWorkflowJobInput(BaseModel):
    connector: Optional["EntityEnrichmentConnectorInput"] = None


class EntityReferenceInput(BaseModel):
    id: str


class OrganizationFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[OrganizationFacetTypes] = None


class ContentUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    identifier: Optional[str] = None
    summary: Optional[str] = None
    custom_summary: Optional[str] = Field(alias="customSummary", default=None)
    keywords: Optional[List[str]] = None
    bullets: Optional[List[str]] = None
    headlines: Optional[List[str]] = None
    posts: Optional[List[str]] = None
    chapters: Optional[List[str]] = None
    questions: Optional[List[str]] = None
    video: Optional["VideoMetadataInput"] = None
    audio: Optional["AudioMetadataInput"] = None
    image: Optional["ImageMetadataInput"] = None
    document: Optional["DocumentMetadataInput"] = None
    email: Optional["EmailMetadataInput"] = None
    issue: Optional["IssueMetadataInput"] = None
    drawing: Optional["DrawingMetadataInput"] = None
    shape: Optional["ShapeMetadataInput"] = None
    geometry: Optional["GeometryMetadataInput"] = None
    point_cloud: Optional["PointCloudMetadataInput"] = Field(
        alias="pointCloud", default=None
    )
    package: Optional["PackageMetadataInput"] = None
    language: Optional["LanguageMetadataInput"] = None


class ShapeMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    feature_count: Optional[int] = Field(alias="featureCount", default=None)
    attribute_count: Optional[int] = Field(alias="attributeCount", default=None)


class RetrievalStrategyInput(BaseModel):
    type: RetrievalStrategyTypes
    content_limit: Optional[int] = Field(alias="contentLimit", default=None)
    disable_fallback: Optional[bool] = Field(alias="disableFallback", default=None)


class MedicalDeviceInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class MedicalContraindicationUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class MedicalDrugFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalDrugFacetTypes] = None


class MistralDocumentPreparationPropertiesInput(BaseModel):
    key: Optional[str] = None


class NotionDatabasesInput(BaseModel):
    token: str


class DocumentPreparationPropertiesInput(BaseModel):
    include_images: Optional[bool] = Field(alias="includeImages", default=None)


class RevisionStrategyUpdateInput(BaseModel):
    type: Optional[RevisionStrategyTypes] = None
    custom_revision: Optional[str] = Field(alias="customRevision", default=None)
    count: Optional[int] = None


class EntityEnrichmentConnectorInput(BaseModel):
    type: EntityEnrichmentServiceTypes
    enriched_types: Optional[List[Optional[ObservableTypes]]] = Field(
        alias="enrichedTypes", default=None
    )
    fhir: Optional["FHIREnrichmentPropertiesInput"] = None
    diffbot: Optional["DiffbotEnrichmentPropertiesInput"] = None


class PlaceInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None


class IngestionContentFilterInput(BaseModel):
    types: Optional[List[ContentTypes]] = None
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes", default=None)
    formats: Optional[List[Optional[str]]] = None
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions", default=None)
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths", default=None)
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths", default=None)


class SpecificationFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    types: Optional[List[Optional[SpecificationTypes]]] = None
    service_types: Optional[List[Optional[ModelServiceTypes]]] = Field(
        alias="serviceTypes", default=None
    )


class SoftwareUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    developer: Optional[str] = None
    release_date: Optional[Any] = Field(alias="releaseDate", default=None)


class ConversationStrategyInput(BaseModel):
    type: Optional[ConversationStrategyTypes] = None
    message_limit: Optional[int] = Field(alias="messageLimit", default=None)
    embed_citations: Optional[bool] = Field(alias="embedCitations", default=None)
    flatten_citations: Optional[bool] = Field(alias="flattenCitations", default=None)
    enable_facets: Optional[bool] = Field(alias="enableFacets", default=None)
    messages_weight: Optional[float] = Field(alias="messagesWeight", default=None)
    contents_weight: Optional[float] = Field(alias="contentsWeight", default=None)


class AmazonFeedPropertiesInput(BaseModel):
    access_key: str = Field(alias="accessKey")
    secret_access_key: str = Field(alias="secretAccessKey")
    bucket_name: str = Field(alias="bucketName")
    prefix: Optional[str] = None
    region: Optional[str] = None


class TextContentInput(BaseModel):
    name: str
    text: str


class NamedEntityReferenceInput(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None


class RerankingStrategyInput(BaseModel):
    service_type: RerankingModelServiceTypes = Field(alias="serviceType")
    threshold: Optional[float] = None


class CohereModelPropertiesUpdateInput(BaseModel):
    model: Optional[CohereModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class EmbeddingsStrategyInput(BaseModel):
    text_specification: Optional["EntityReferenceInput"] = Field(
        alias="textSpecification", default=None
    )
    image_specification: Optional["EntityReferenceInput"] = Field(
        alias="imageSpecification", default=None
    )


class ConnectorFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    types: Optional[List[ConnectorTypes]] = None


class OpenAIImagePublishingPropertiesInput(BaseModel):
    model: Optional[OpenAIImageModels] = None
    count: Optional[int] = None
    seed: Optional["EntityReferenceInput"] = None


class RedditFeedPropertiesInput(BaseModel):
    subreddit_name: str = Field(alias="subredditName")
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class DateRangeFilter(BaseModel):
    from_: Optional[Any] = Field(alias="from", default=None)
    to: Optional[Any] = None


class MedicalDeviceFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalDeviceFacetTypes] = None


class SharePointFoldersInput(BaseModel):
    authentication_type: SharePointAuthenticationTypes = Field(
        alias="authenticationType"
    )
    tenant_id: Optional[str] = Field(alias="tenantId", default=None)
    client_id: Optional[str] = Field(alias="clientId", default=None)
    client_secret: Optional[str] = Field(alias="clientSecret", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)


class AzureAIModelPropertiesInput(BaseModel):
    key: str
    endpoint: Any
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: int = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class AzureImageExtractionPropertiesInput(BaseModel):
    confidence_threshold: Optional[float] = Field(
        alias="confidenceThreshold", default=None
    )


class LabelFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[LabelFacetTypes] = None


class RedditFeedPropertiesUpdateInput(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class OpenAIModelPropertiesInput(BaseModel):
    model: OpenAIModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)
    detail_level: Optional[OpenAIVisionDetailLevels] = Field(
        alias="detailLevel", default=None
    )
    reasoning_effort: Optional[OpenAIReasoningEffortLevels] = Field(
        alias="reasoningEffort", default=None
    )


class ToolDefinitionInput(BaseModel):
    name: str
    description: Optional[str] = None
    schema_: str = Field(alias="schema")


class ContentFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[ContentFacetTypes] = None


class JinaModelPropertiesInput(BaseModel):
    model: JinaModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class ProjectUpdateInput(BaseModel):
    workflow: Optional["EntityReferenceInput"] = None
    specification: Optional["EntityReferenceInput"] = None
    embeddings: Optional["EmbeddingsStrategyInput"] = None
    callback_uri: Optional[Any] = Field(alias="callbackUri", default=None)


class MedicalStudyFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_studies: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarStudies", default=None
    )


class H3IndexFilter(BaseModel):
    resolution: Optional[H3ResolutionTypes] = None
    key: Optional[str] = None


class ClassificationWorkflowJobInput(BaseModel):
    connector: Optional["ContentClassificationConnectorInput"] = None


class ModelFilter(BaseModel):
    types: Optional[List[Optional[ModelTypes]]] = None
    service_types: Optional[List[Optional[ModelServiceTypes]]] = Field(
        alias="serviceTypes", default=None
    )


class CollectionUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    type: Optional[CollectionTypes] = None
    contents: Optional[List["EntityReferenceInput"]] = None
    expected_count: Optional[int] = Field(alias="expectedCount", default=None)


class SpecificationInput(BaseModel):
    name: str
    type: Optional[SpecificationTypes] = None
    service_type: ModelServiceTypes = Field(alias="serviceType")
    search_type: Optional[ConversationSearchTypes] = Field(
        alias="searchType", default=None
    )
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    system_prompt: Optional[str] = Field(alias="systemPrompt", default=None)
    custom_guidance: Optional[str] = Field(alias="customGuidance", default=None)
    custom_instructions: Optional[str] = Field(alias="customInstructions", default=None)
    strategy: Optional["ConversationStrategyInput"] = None
    prompt_strategy: Optional["PromptStrategyInput"] = Field(
        alias="promptStrategy", default=None
    )
    retrieval_strategy: Optional["RetrievalStrategyInput"] = Field(
        alias="retrievalStrategy", default=None
    )
    reranking_strategy: Optional["RerankingStrategyInput"] = Field(
        alias="rerankingStrategy", default=None
    )
    graph_strategy: Optional["GraphStrategyInput"] = Field(
        alias="graphStrategy", default=None
    )
    revision_strategy: Optional["RevisionStrategyInput"] = Field(
        alias="revisionStrategy", default=None
    )
    azure_ai: Optional["AzureAIModelPropertiesInput"] = Field(
        alias="azureAI", default=None
    )
    open_ai: Optional["OpenAIModelPropertiesInput"] = Field(
        alias="openAI", default=None
    )
    azure_open_ai: Optional["AzureOpenAIModelPropertiesInput"] = Field(
        alias="azureOpenAI", default=None
    )
    cohere: Optional["CohereModelPropertiesInput"] = None
    anthropic: Optional["AnthropicModelPropertiesInput"] = None
    google: Optional["GoogleModelPropertiesInput"] = None
    replicate: Optional["ReplicateModelPropertiesInput"] = None
    mistral: Optional["MistralModelPropertiesInput"] = None
    bedrock: Optional["BedrockModelPropertiesInput"] = None
    groq: Optional["GroqModelPropertiesInput"] = None
    cerebras: Optional["CerebrasModelPropertiesInput"] = None
    deepseek: Optional["DeepseekModelPropertiesInput"] = None
    jina: Optional["JinaModelPropertiesInput"] = None
    voyage: Optional["VoyageModelPropertiesInput"] = None


class PackageMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    file_count: Optional[int] = Field(alias="fileCount", default=None)
    folder_count: Optional[int] = Field(alias="folderCount", default=None)


class SharePointFeedPropertiesInput(BaseModel):
    authentication_type: SharePointAuthenticationTypes = Field(
        alias="authenticationType"
    )
    tenant_id: Optional[str] = Field(alias="tenantId", default=None)
    client_id: Optional[str] = Field(alias="clientId", default=None)
    client_secret: Optional[str] = Field(alias="clientSecret", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    account_name: str = Field(alias="accountName")
    library_id: str = Field(alias="libraryId")
    folder_id: Optional[str] = Field(alias="folderId", default=None)


class ConnectorInput(BaseModel):
    name: str
    type: ConnectorTypes
    authentication: Optional["AuthenticationConnectorInput"] = None
    integration: Optional["IntegrationConnectorInput"] = None


class LabelInput(BaseModel):
    name: str
    description: Optional[str] = None


class PreparationWorkflowStageInput(BaseModel):
    enable_unblocked_capture: Optional[bool] = Field(
        alias="enableUnblockedCapture", default=None
    )
    disable_smart_capture: Optional[bool] = Field(
        alias="disableSmartCapture", default=None
    )
    summarizations: Optional[List[Optional["SummarizationStrategyInput"]]] = None
    jobs: Optional[List[Optional["PreparationWorkflowJobInput"]]] = None


class ProjectFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )


class MedicalProcedureUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class BoxFeedPropertiesUpdateInput(BaseModel):
    folder_id: Optional[str] = Field(alias="folderId", default=None)
    client_id: Optional[str] = Field(alias="clientId", default=None)
    client_secret: Optional[str] = Field(alias="clientSecret", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    redirect_uri: Optional[str] = Field(alias="redirectUri", default=None)


class GitHubFeedPropertiesInput(BaseModel):
    repository_owner: str = Field(alias="repositoryOwner")
    repository_name: str = Field(alias="repositoryName")
    uri: Optional[Any] = None
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    personal_access_token: Optional[str] = Field(
        alias="personalAccessToken", default=None
    )


class MedicalStudyUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None


class MedicalTestInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class MedicalGuidelineFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalGuidelineFacetTypes] = None


class MedicalProcedureFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalProcedureFacetTypes] = None


class RepoFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_repos: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarRepos", default=None
    )


class GoogleDriveFeedPropertiesInput(BaseModel):
    authentication_type: Optional[GoogleDriveAuthenticationTypes] = Field(
        alias="authenticationType", default=None
    )
    files: Optional[List[Optional[str]]] = None
    folder_id: Optional[str] = Field(alias="folderId", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    client_id: Optional[str] = Field(alias="clientId", default=None)
    client_secret: Optional[str] = Field(alias="clientSecret", default=None)
    service_account_json: Optional[str] = Field(
        alias="serviceAccountJson", default=None
    )


class IntegrationConnectorUpdateInput(BaseModel):
    uri: Optional[str] = None
    slack: Optional["SlackIntegrationPropertiesInput"] = None
    email: Optional["EmailIntegrationPropertiesInput"] = None
    twitter: Optional["TwitterIntegrationPropertiesInput"] = None


class PagePreparationPropertiesInput(BaseModel):
    enable_screenshot: Optional[bool] = Field(alias="enableScreenshot", default=None)


class BedrockModelPropertiesInput(BaseModel):
    model: BedrockModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    access_key: Optional[str] = Field(alias="accessKey", default=None)
    secret_access_key: Optional[str] = Field(alias="secretAccessKey", default=None)
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )


class MedicalDeviceFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_devices: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarDevices", default=None
    )


class MedicalContraindicationFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_contraindications: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarContraindications", default=None
    )


class DiscordFeedPropertiesUpdateInput(BaseModel):
    type: Optional[FeedListingTypes] = None
    token: Optional[str] = None
    channel: Optional[str] = None
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class AzureFileFeedPropertiesUpdateInput(BaseModel):
    storage_access_key: Optional[str] = Field(alias="storageAccessKey", default=None)
    account_name: Optional[str] = Field(alias="accountName", default=None)
    share_name: Optional[str] = Field(alias="shareName", default=None)
    prefix: Optional[str] = None


class BedrockModelPropertiesUpdateInput(BaseModel):
    model: Optional[BedrockModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    access_key: Optional[str] = Field(alias="accessKey", default=None)
    secret_access_key: Optional[str] = Field(alias="secretAccessKey", default=None)
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )


class PromptClassificationRuleInput(BaseModel):
    if_: Optional[str] = Field(alias="if", default=None)
    then: Optional[str] = None


class ProjectInput(BaseModel):
    name: str
    environment_type: EnvironmentTypes = Field(alias="environmentType")
    platform: ResourceConnectorTypes
    region: str
    jwt_secret: str = Field(alias="jwtSecret")
    quota: Optional["ProjectQuotaInput"] = None
    callback_uri: Optional[Any] = Field(alias="callbackUri", default=None)


class MedicalIndicationFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_indications: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarIndications", default=None
    )


class IndexingWorkflowJobInput(BaseModel):
    connector: Optional["ContentIndexingConnectorInput"] = None


class ObservationCriteriaInput(BaseModel):
    type: Optional[ObservableTypes] = None
    observable: Optional["EntityReferenceInput"] = None
    states: Optional[List[Optional[EntityState]]] = None


class LanguageMetadataInput(BaseModel):
    languages: Optional[List[Optional[str]]] = None


class MedicalTherapyUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class NotionFeedPropertiesUpdateInput(BaseModel):
    is_recursive: Optional[bool] = Field(alias="isRecursive", default=None)
    token: str
    type: Optional[NotionTypes] = None
    identifiers: Optional[List[str]] = None
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class ObservationInput(BaseModel):
    content: "EntityReferenceInput"
    type: ObservableTypes
    observable: "NamedEntityReferenceInput"
    related: Optional["NamedEntityReferenceInput"] = None
    related_type: Optional[ObservableTypes] = Field(alias="relatedType", default=None)
    relation: Optional[str] = None
    occurrences: List["ObservationOccurrenceInput"]


class LinearProjectsInput(BaseModel):
    key: str


class ContentGraphInput(BaseModel):
    types: Optional[List[Optional[ObservableTypes]]] = None


class DiffbotEnrichmentPropertiesInput(BaseModel):
    key: Optional[str] = None


class GoogleModelPropertiesUpdateInput(BaseModel):
    model: Optional[GoogleModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)
    enable_thinking: Optional[bool] = Field(alias="enableThinking", default=None)
    thinking_token_limit: Optional[int] = Field(
        alias="thinkingTokenLimit", default=None
    )


class IntegrationConnectorInput(BaseModel):
    type: IntegrationServiceTypes
    uri: Optional[str] = None
    slack: Optional["SlackIntegrationPropertiesInput"] = None
    email: Optional["EmailIntegrationPropertiesInput"] = None
    twitter: Optional["TwitterIntegrationPropertiesInput"] = None


class SummarizationStrategyInput(BaseModel):
    type: SummarizationTypes
    specification: Optional["EntityReferenceInput"] = None
    tokens: Optional[int] = None
    items: Optional[int] = None
    prompt: Optional[str] = None


class GroqModelPropertiesUpdateInput(BaseModel):
    model: Optional[GroqModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )


class OrganizationUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None
    founding_date: Optional[Any] = Field(alias="foundingDate", default=None)
    industries: Optional[List[Optional[str]]] = None
    revenue_currency: Optional[str] = Field(alias="revenueCurrency", default=None)
    revenue: Optional[Any] = None
    investment_currency: Optional[str] = Field(alias="investmentCurrency", default=None)
    investment: Optional[Any] = None


class DocumentMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    title: Optional[str] = None
    subject: Optional[str] = None
    author: Optional[str] = None
    software: Optional[str] = None
    publisher: Optional[str] = None
    description: Optional[str] = None
    summary: Optional[str] = None
    comments: Optional[str] = None
    identifier: Optional[str] = None
    keywords: Optional[List[Optional[str]]] = None
    links: Optional[List[Optional[Any]]] = None
    page_count: Optional[int] = Field(alias="pageCount", default=None)
    worksheet_count: Optional[int] = Field(alias="worksheetCount", default=None)
    slide_count: Optional[int] = Field(alias="slideCount", default=None)
    word_count: Optional[int] = Field(alias="wordCount", default=None)
    line_count: Optional[int] = Field(alias="lineCount", default=None)
    paragraph_count: Optional[int] = Field(alias="paragraphCount", default=None)
    character_count: Optional[int] = Field(alias="characterCount", default=None)
    total_editing_time: Optional[str] = Field(alias="totalEditingTime", default=None)
    is_encrypted: Optional[bool] = Field(alias="isEncrypted", default=None)
    has_digital_signature: Optional[bool] = Field(
        alias="hasDigitalSignature", default=None
    )


class WebFeedPropertiesUpdateInput(BaseModel):
    uri: Optional[Any] = None
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths", default=None)
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths", default=None)
    include_files: Optional[bool] = Field(alias="includeFiles", default=None)
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class RSSFeedPropertiesUpdateInput(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class FHIREnrichmentPropertiesInput(BaseModel):
    endpoint: Optional[Any] = None


class ConversationFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    types: Optional[List[ConversationTypes]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_conversations: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarConversations", default=None
    )
    conversations: Optional[List["EntityReferenceFilter"]] = None


class PointInput(BaseModel):
    latitude: float
    longitude: float
    distance: Optional[float] = None


class TwitterFeedPropertiesUpdateInput(BaseModel):
    token: Optional[str] = None
    type: Optional[TwitterListingTypes] = None
    user_name: Optional[str] = Field(alias="userName", default=None)
    query: Optional[str] = None
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class RegexClassificationRuleInput(BaseModel):
    type: Optional[RegexSourceTypes] = None
    path: Optional[str] = None
    matches: Optional[str] = None
    then: Optional[str] = None


class ContentPublishingConnectorInput(BaseModel):
    type: ContentPublishingServiceTypes
    format: ContentPublishingFormats
    eleven_labs: Optional["ElevenLabsPublishingPropertiesInput"] = Field(
        alias="elevenLabs", default=None
    )
    open_ai_image: Optional["OpenAIImagePublishingPropertiesInput"] = Field(
        alias="openAIImage", default=None
    )


class AmazonFeedPropertiesUpdateInput(BaseModel):
    access_key: Optional[str] = Field(alias="accessKey", default=None)
    secret_access_key: Optional[str] = Field(alias="secretAccessKey", default=None)
    bucket_name: Optional[str] = Field(alias="bucketName", default=None)
    prefix: Optional[str] = None
    region: Optional[str] = None


class DateRangeInput(BaseModel):
    from_: Optional[Any] = Field(alias="from", default=None)
    to: Optional[Any] = None


class TwitterIntegrationPropertiesInput(BaseModel):
    consumer_key: str = Field(alias="consumerKey")
    consumer_secret: str = Field(alias="consumerSecret")
    access_token_key: str = Field(alias="accessTokenKey")
    access_token_secret: str = Field(alias="accessTokenSecret")


class EventInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None
    start_date: Optional[Any] = Field(alias="startDate", default=None)
    end_date: Optional[Any] = Field(alias="endDate", default=None)
    availability_start_date: Optional[Any] = Field(
        alias="availabilityStartDate", default=None
    )
    availability_end_date: Optional[Any] = Field(
        alias="availabilityEndDate", default=None
    )
    price: Optional[Any] = None
    min_price: Optional[Any] = Field(alias="minPrice", default=None)
    max_price: Optional[Any] = Field(alias="maxPrice", default=None)
    price_currency: Optional[str] = Field(alias="priceCurrency", default=None)
    is_accessible_for_free: Optional[bool] = Field(
        alias="isAccessibleForFree", default=None
    )
    typical_age_range: Optional[str] = Field(alias="typicalAgeRange", default=None)


class GoogleFeedPropertiesInput(BaseModel):
    credentials: str
    container_name: str = Field(alias="containerName")
    prefix: Optional[str] = None


class ObservationUpdateInput(BaseModel):
    id: str
    type: Optional[ObservableTypes] = None
    observable: Optional["NamedEntityReferenceInput"] = None
    related: Optional["NamedEntityReferenceInput"] = None
    related_type: Optional[ObservableTypes] = Field(alias="relatedType", default=None)
    relation: Optional[str] = None
    occurrences: Optional[List["ObservationOccurrenceInput"]] = None


class VoyageModelPropertiesInput(BaseModel):
    model: VoyageModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class AudioMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    keywords: Optional[List[Optional[str]]] = None
    author: Optional[str] = None
    series: Optional[str] = None
    episode: Optional[str] = None
    episode_type: Optional[str] = Field(alias="episodeType", default=None)
    season: Optional[str] = None
    publisher: Optional[str] = None
    copyright: Optional[str] = None
    genre: Optional[str] = None
    title: Optional[str] = None
    bitrate: Optional[int] = None
    channels: Optional[int] = None
    sample_rate: Optional[int] = Field(alias="sampleRate", default=None)
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample", default=None)
    duration: Optional[str] = None


class SpecificationUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    type: Optional[SpecificationTypes] = None
    service_type: ModelServiceTypes = Field(alias="serviceType")
    search_type: Optional[ConversationSearchTypes] = Field(
        alias="searchType", default=None
    )
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    system_prompt: Optional[str] = Field(alias="systemPrompt", default=None)
    custom_guidance: Optional[str] = Field(alias="customGuidance", default=None)
    custom_instructions: Optional[str] = Field(alias="customInstructions", default=None)
    strategy: Optional["ConversationStrategyUpdateInput"] = None
    prompt_strategy: Optional["PromptStrategyUpdateInput"] = Field(
        alias="promptStrategy", default=None
    )
    retrieval_strategy: Optional["RetrievalStrategyUpdateInput"] = Field(
        alias="retrievalStrategy", default=None
    )
    reranking_strategy: Optional["RerankingStrategyUpdateInput"] = Field(
        alias="rerankingStrategy", default=None
    )
    graph_strategy: Optional["GraphStrategyUpdateInput"] = Field(
        alias="graphStrategy", default=None
    )
    revision_strategy: Optional["RevisionStrategyUpdateInput"] = Field(
        alias="revisionStrategy", default=None
    )
    azure_ai: Optional["AzureAIModelPropertiesUpdateInput"] = Field(
        alias="azureAI", default=None
    )
    open_ai: Optional["OpenAIModelPropertiesUpdateInput"] = Field(
        alias="openAI", default=None
    )
    azure_open_ai: Optional["AzureOpenAIModelPropertiesUpdateInput"] = Field(
        alias="azureOpenAI", default=None
    )
    cohere: Optional["CohereModelPropertiesUpdateInput"] = None
    anthropic: Optional["AnthropicModelPropertiesUpdateInput"] = None
    google: Optional["GoogleModelPropertiesUpdateInput"] = None
    replicate: Optional["ReplicateModelPropertiesUpdateInput"] = None
    mistral: Optional["MistralModelPropertiesUpdateInput"] = None
    bedrock: Optional["BedrockModelPropertiesUpdateInput"] = None
    groq: Optional["GroqModelPropertiesUpdateInput"] = None
    cerebras: Optional["CerebrasModelPropertiesUpdateInput"] = None
    deepseek: Optional["DeepseekModelPropertiesUpdateInput"] = None
    jina: Optional["JinaModelPropertiesUpdateInput"] = None
    voyage: Optional["VoyageModelPropertiesUpdateInput"] = None


class UserInput(BaseModel):
    name: str
    type: Optional[UserTypes] = None
    identifier: str
    description: Optional[str] = None


class ContentPublishingConnectorUpdateInput(BaseModel):
    type: Optional[ContentPublishingServiceTypes] = None
    format: Optional[ContentPublishingFormats] = None
    eleven_labs: Optional["ElevenLabsPublishingPropertiesInput"] = Field(
        alias="elevenLabs", default=None
    )
    open_ai_image: Optional["OpenAIImagePublishingPropertiesInput"] = Field(
        alias="openAIImage", default=None
    )


class EventFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    start_date_range: Optional["DateRangeFilter"] = Field(
        alias="startDateRange", default=None
    )
    end_date_range: Optional["DateRangeFilter"] = Field(
        alias="endDateRange", default=None
    )
    availability_start_date_range: Optional["DateRangeFilter"] = Field(
        alias="availabilityStartDateRange", default=None
    )
    availability_end_date_range: Optional["DateRangeFilter"] = Field(
        alias="availabilityEndDateRange", default=None
    )
    price: Optional[Any] = None
    min_price: Optional[Any] = Field(alias="minPrice", default=None)
    max_price: Optional[Any] = Field(alias="maxPrice", default=None)
    price_currency: Optional[str] = Field(alias="priceCurrency", default=None)
    is_accessible_for_free: Optional[bool] = Field(
        alias="isAccessibleForFree", default=None
    )
    typical_age_range: Optional[str] = Field(alias="typicalAgeRange", default=None)
    similar_events: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarEvents", default=None
    )


class ClassificationWorkflowStageInput(BaseModel):
    jobs: Optional[List[Optional["ClassificationWorkflowJobInput"]]] = None


class RepoInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None


class PromptStrategyUpdateInput(BaseModel):
    type: Optional[PromptStrategyTypes] = None


class CategoryFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[CategoryFacetTypes] = None


class AzureBlobFeedPropertiesInput(BaseModel):
    storage_access_key: str = Field(alias="storageAccessKey")
    account_name: str = Field(alias="accountName")
    container_name: str = Field(alias="containerName")
    prefix: Optional[str] = None


class ObservationReferenceFilter(BaseModel):
    type: ObservableTypes
    observable: "EntityReferenceFilter"
    states: Optional[List[Optional[EntityState]]] = None


class CategoryUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None


class EmailPreparationPropertiesInput(BaseModel):
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )


class MedicalGuidelineFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_guidelines: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarGuidelines", default=None
    )


class EmailFeedPropertiesInput(BaseModel):
    type: FeedServiceTypes
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )
    google: Optional["GoogleEmailFeedPropertiesInput"] = None
    microsoft: Optional["MicrosoftEmailFeedPropertiesInput"] = None
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class LinearFeedPropertiesUpdateInput(BaseModel):
    key: Optional[str] = None
    project: Optional[str] = None


class JinaModelPropertiesUpdateInput(BaseModel):
    model: Optional[JinaModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class ObservationReferenceInput(BaseModel):
    type: ObservableTypes
    observable: "NamedEntityReferenceInput"


class ContentFilterLevel(BaseModel):
    feeds: Optional[List["EntityReferenceFilter"]] = None
    workflows: Optional[List["EntityReferenceFilter"]] = None
    collections: Optional[List["EntityReferenceFilter"]] = None
    users: Optional[List["EntityReferenceFilter"]] = None
    observations: Optional[List["ObservationReferenceFilter"]] = None


class OneDriveFoldersInput(BaseModel):
    refresh_token: str = Field(alias="refreshToken")


class TrelloFeedPropertiesUpdateInput(BaseModel):
    key: Optional[str] = None
    token: Optional[str] = None
    type: Optional[TrelloTypes] = None
    identifiers: Optional[List[str]] = None


class SoftwareInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    developer: Optional[str] = None
    release_date: Optional[Any] = Field(alias="releaseDate", default=None)


class GoogleEmailFeedPropertiesUpdateInput(BaseModel):
    type: Optional[EmailListingTypes] = None
    inbox_only: Optional[bool] = Field(alias="inboxOnly", default=None)
    include_deleted_items: Optional[bool] = Field(
        alias="includeDeletedItems", default=None
    )
    exclude_sent_items: Optional[bool] = Field(alias="excludeSentItems", default=None)
    include_spam: Optional[bool] = Field(alias="includeSpam", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    client_id: Optional[str] = Field(alias="clientId", default=None)
    client_secret: Optional[str] = Field(alias="clientSecret", default=None)


class ReplicateModelPropertiesInput(BaseModel):
    model: ReplicateModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )


class FeedInput(BaseModel):
    name: str
    description: Optional[str] = None
    type: FeedTypes
    site: Optional["SiteFeedPropertiesInput"] = None
    email: Optional["EmailFeedPropertiesInput"] = None
    issue: Optional["IssueFeedPropertiesInput"] = None
    rss: Optional["RSSFeedPropertiesInput"] = None
    web: Optional["WebFeedPropertiesInput"] = None
    search: Optional["SearchFeedPropertiesInput"] = None
    reddit: Optional["RedditFeedPropertiesInput"] = None
    youtube: Optional["YouTubeFeedPropertiesInput"] = None
    notion: Optional["NotionFeedPropertiesInput"] = None
    twitter: Optional["TwitterFeedPropertiesInput"] = None
    slack: Optional["SlackFeedPropertiesInput"] = None
    microsoft_teams: Optional["MicrosoftTeamsFeedPropertiesInput"] = Field(
        alias="microsoftTeams", default=None
    )
    discord: Optional["DiscordFeedPropertiesInput"] = None
    intercom: Optional["IntercomFeedPropertiesInput"] = None
    zendesk: Optional["ZendeskFeedPropertiesInput"] = None
    schedule_policy: Optional["FeedSchedulePolicyInput"] = Field(
        alias="schedulePolicy", default=None
    )
    workflow: Optional["EntityReferenceInput"] = None


class TrelloFeedPropertiesInput(BaseModel):
    key: str
    token: str
    type: TrelloTypes
    identifiers: List[str]


class RepoUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None


class FilePreparationConnectorInput(BaseModel):
    type: FilePreparationServiceTypes
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes", default=None)
    page: Optional["PagePreparationPropertiesInput"] = None
    document: Optional["DocumentPreparationPropertiesInput"] = None
    email: Optional["EmailPreparationPropertiesInput"] = None
    azure_document: Optional["AzureDocumentPreparationPropertiesInput"] = Field(
        alias="azureDocument", default=None
    )
    deepgram: Optional["DeepgramAudioPreparationPropertiesInput"] = None
    assembly_ai: Optional["AssemblyAIAudioPreparationPropertiesInput"] = Field(
        alias="assemblyAI", default=None
    )
    mistral: Optional["MistralDocumentPreparationPropertiesInput"] = None
    model_document: Optional["ModelDocumentPreparationPropertiesInput"] = Field(
        alias="modelDocument", default=None
    )


class MedicalDrugFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_drugs: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarDrugs", default=None
    )


class SlackIntegrationPropertiesInput(BaseModel):
    channel: str
    token: str


class MedicalTherapyInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class ContentInput(BaseModel):
    name: str
    type: Optional[ContentTypes] = None
    uri: Optional[Any] = None
    description: Optional[str] = None
    text: Optional[str] = None
    identifier: Optional[str] = None
    workflow: Optional["EntityReferenceInput"] = None


class MedicalContraindicationInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class MistralModelPropertiesUpdateInput(BaseModel):
    model: Optional[MistralModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class ContentFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    image_data: Optional[str] = Field(alias="imageData", default=None)
    image_mime_type: Optional[str] = Field(alias="imageMimeType", default=None)
    disable_inheritance: Optional[bool] = Field(
        alias="disableInheritance", default=None
    )
    types: Optional[List[ContentTypes]] = None
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes", default=None)
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    in_last: Optional[Any] = Field(alias="inLast", default=None)
    original_date_range: Optional["DateRangeFilter"] = Field(
        alias="originalDateRange", default=None
    )
    c_4_id: Optional[str] = Field(alias="c4id", default=None)
    formats: Optional[List[Optional[str]]] = None
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions", default=None)
    file_size_range: Optional["Int64RangeFilter"] = Field(
        alias="fileSizeRange", default=None
    )
    similar_contents: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarContents", default=None
    )
    contents: Optional[List["EntityReferenceFilter"]] = None
    feeds: Optional[List["EntityReferenceFilter"]] = None
    workflows: Optional[List["EntityReferenceFilter"]] = None
    collections: Optional[List["EntityReferenceFilter"]] = None
    users: Optional[List["EntityReferenceFilter"]] = None
    observations: Optional[List["ObservationReferenceFilter"]] = None
    or_: Optional[List[Optional["ContentFilterLevel"]]] = Field(
        alias="or", default=None
    )
    and_: Optional[List[Optional["ContentFilterLevel"]]] = Field(
        alias="and", default=None
    )


class EntityExtractionConnectorInput(BaseModel):
    type: EntityExtractionServiceTypes
    content_types: Optional[List[ContentTypes]] = Field(
        alias="contentTypes", default=None
    )
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes", default=None)
    extracted_types: Optional[List[ObservableTypes]] = Field(
        alias="extractedTypes", default=None
    )
    extracted_count: Optional[int] = Field(alias="extractedCount", default=None)
    azure_text: Optional["AzureTextExtractionPropertiesInput"] = Field(
        alias="azureText", default=None
    )
    azure_image: Optional["AzureImageExtractionPropertiesInput"] = Field(
        alias="azureImage", default=None
    )
    model_text: Optional["ModelTextExtractionPropertiesInput"] = Field(
        alias="modelText", default=None
    )
    model_image: Optional["ModelImageExtractionPropertiesInput"] = Field(
        alias="modelImage", default=None
    )


class MetadataFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    metadata_types: Optional[List[Optional[MetadataTypes]]] = Field(
        alias="metadataTypes", default=None
    )
    content: Optional["EntityReferenceFilter"] = None


class AlertFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    types: Optional[List[Optional[AlertTypes]]] = None


class GoogleEmailFeedPropertiesInput(BaseModel):
    type: Optional[EmailListingTypes] = None
    inbox_only: Optional[bool] = Field(alias="inboxOnly", default=None)
    include_deleted_items: Optional[bool] = Field(
        alias="includeDeletedItems", default=None
    )
    exclude_sent_items: Optional[bool] = Field(alias="excludeSentItems", default=None)
    include_spam: Optional[bool] = Field(alias="includeSpam", default=None)
    refresh_token: str = Field(alias="refreshToken")
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class MedicalConditionInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class ProductUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None
    production_date: Optional[Any] = Field(alias="productionDate", default=None)
    release_date: Optional[Any] = Field(alias="releaseDate", default=None)
    sku: Optional[str] = None
    upc: Optional[str] = None
    manufacturer: Optional[str] = None
    brand: Optional[str] = None
    model: Optional[str] = None


class PersonUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None
    given_name: Optional[str] = Field(alias="givenName", default=None)
    family_name: Optional[str] = Field(alias="familyName", default=None)
    phone_number: Optional[str] = Field(alias="phoneNumber", default=None)
    email: Optional[str] = None
    birth_date: Optional[Any] = Field(alias="birthDate", default=None)
    title: Optional[str] = None
    occupation: Optional[str] = None
    education: Optional[str] = None


class SharePointLibrariesInput(BaseModel):
    authentication_type: SharePointAuthenticationTypes = Field(
        alias="authenticationType"
    )
    tenant_id: Optional[str] = Field(alias="tenantId", default=None)
    client_id: Optional[str] = Field(alias="clientId", default=None)
    client_secret: Optional[str] = Field(alias="clientSecret", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)


class IngestionWorkflowStageInput(BaseModel):
    if_: Optional["IngestionContentFilterInput"] = Field(alias="if", default=None)
    collections: Optional[List[Optional["EntityReferenceInput"]]] = None
    observations: Optional[List[Optional["ObservationReferenceInput"]]] = None
    enable_email_collections: Optional[bool] = Field(
        alias="enableEmailCollections", default=None
    )


class VideoMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    width: Optional[int] = None
    height: Optional[int] = None
    duration: Optional[str] = None
    software: Optional[str] = None
    make: Optional[str] = None
    model: Optional[str] = None


class ExtractionWorkflowStageInput(BaseModel):
    jobs: Optional[List[Optional["ExtractionWorkflowJobInput"]]] = None


class PointFilter(BaseModel):
    latitude: float
    longitude: float
    distance: Optional[float] = None


class NotionPagesInput(BaseModel):
    token: str


class CohereModelPropertiesInput(BaseModel):
    model: CohereModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class ZendeskTicketsFeedPropertiesUpdateInput(BaseModel):
    subdomain: Optional[str] = None
    access_token: Optional[str] = Field(alias="accessToken", default=None)


class MedicalConditionUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class IssueMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    title: Optional[str] = None
    project: Optional[str] = None
    team: Optional[str] = None
    status: Optional[str] = None
    priority: Optional[str] = None
    type: Optional[str] = None
    identifier: Optional[str] = None
    labels: Optional[List[Optional[str]]] = None
    links: Optional[List[Optional[Any]]] = None


class ZendeskTicketsFeedPropertiesInput(BaseModel):
    subdomain: str
    access_token: str = Field(alias="accessToken")


class MedicalTherapyFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_therapies: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarTherapies", default=None
    )


class ElevenLabsPublishingPropertiesInput(BaseModel):
    model: Optional[ElevenLabsModels] = None
    voice: Optional[str] = None


class YouTubeFeedPropertiesInput(BaseModel):
    type: YouTubeTypes
    video_name: Optional[str] = Field(alias="videoName", default=None)
    video_identifiers: Optional[List[str]] = Field(
        alias="videoIdentifiers", default=None
    )
    channel_identifier: Optional[str] = Field(alias="channelIdentifier", default=None)
    playlist_identifier: Optional[str] = Field(alias="playlistIdentifier", default=None)
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class AtlassianJiraFeedPropertiesInput(BaseModel):
    uri: Any
    project: str
    email: str
    token: str
    offset: Optional[Any] = None


class MedicalDrugUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class PromptStrategyInput(BaseModel):
    type: Optional[PromptStrategyTypes] = None


class YouTubeFeedPropertiesUpdateInput(BaseModel):
    type: Optional[YouTubeTypes] = None
    video_name: Optional[str] = Field(alias="videoName", default=None)
    video_identifiers: Optional[List[str]] = Field(
        alias="videoIdentifiers", default=None
    )
    channel_identifier: Optional[str] = Field(alias="channelIdentifier", default=None)
    playlist_identifier: Optional[str] = Field(alias="playlistIdentifier", default=None)
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class GitHubIssuesFeedPropertiesUpdateInput(BaseModel):
    repository_owner: Optional[str] = Field(alias="repositoryOwner", default=None)
    repository_name: Optional[str] = Field(alias="repositoryName", default=None)
    uri: Optional[Any] = None
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    personal_access_token: Optional[str] = Field(
        alias="personalAccessToken", default=None
    )


class PersonInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None
    given_name: Optional[str] = Field(alias="givenName", default=None)
    family_name: Optional[str] = Field(alias="familyName", default=None)
    phone_number: Optional[str] = Field(alias="phoneNumber", default=None)
    email: Optional[str] = None
    birth_date: Optional[Any] = Field(alias="birthDate", default=None)
    title: Optional[str] = None
    occupation: Optional[str] = None
    education: Optional[str] = None


class SoftwareFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_softwares: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarSoftwares", default=None
    )


class AzureAIModelPropertiesUpdateInput(BaseModel):
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class MedicalStudyFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalStudyFacetTypes] = None


class SiteFeedPropertiesInput(BaseModel):
    type: FeedServiceTypes
    is_recursive: Optional[bool] = Field(alias="isRecursive", default=None)
    s_3: Optional["AmazonFeedPropertiesInput"] = Field(alias="s3", default=None)
    azure_blob: Optional["AzureBlobFeedPropertiesInput"] = Field(
        alias="azureBlob", default=None
    )
    azure_file: Optional["AzureFileFeedPropertiesInput"] = Field(
        alias="azureFile", default=None
    )
    google: Optional["GoogleFeedPropertiesInput"] = None
    share_point: Optional["SharePointFeedPropertiesInput"] = Field(
        alias="sharePoint", default=None
    )
    one_drive: Optional["OneDriveFeedPropertiesInput"] = Field(
        alias="oneDrive", default=None
    )
    google_drive: Optional["GoogleDriveFeedPropertiesInput"] = Field(
        alias="googleDrive", default=None
    )
    github: Optional["GitHubFeedPropertiesInput"] = None
    dropbox: Optional["DropboxFeedPropertiesInput"] = None
    box: Optional["BoxFeedPropertiesInput"] = None
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class ModelContentClassificationPropertiesInput(BaseModel):
    specification: Optional["EntityReferenceInput"] = None
    rules: Optional[List[Optional["PromptClassificationRuleInput"]]] = None


class DropboxFeedPropertiesUpdateInput(BaseModel):
    path: Optional[str] = None
    app_key: Optional[str] = Field(alias="appKey", default=None)
    app_secret: Optional[str] = Field(alias="appSecret", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    redirect_uri: Optional[str] = Field(alias="redirectUri", default=None)


class RepoFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[RepoFacetTypes] = None


class ContentClassificationConnectorInput(BaseModel):
    type: Optional[ContentClassificationServiceTypes] = None
    content_type: Optional[ContentTypes] = Field(alias="contentType", default=None)
    file_type: Optional[FileTypes] = Field(alias="fileType", default=None)
    model: Optional["ModelContentClassificationPropertiesInput"] = None
    regex: Optional["RegexContentClassificationPropertiesInput"] = None


class EnrichmentWorkflowStageInput(BaseModel):
    link: Optional["LinkStrategyInput"] = None
    jobs: Optional[List[Optional["EnrichmentWorkflowJobInput"]]] = None


class DeepgramAudioPreparationPropertiesInput(BaseModel):
    model: Optional[DeepgramModels] = None
    key: Optional[str] = None
    enable_redaction: Optional[bool] = Field(alias="enableRedaction", default=None)
    enable_speaker_diarization: Optional[bool] = Field(
        alias="enableSpeakerDiarization", default=None
    )
    detect_language: Optional[bool] = Field(alias="detectLanguage", default=None)
    language: Optional[str] = None


class IntercomTicketsFeedPropertiesUpdateInput(BaseModel):
    access_token: Optional[str] = Field(alias="accessToken", default=None)


class PersonFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    given_name: Optional[str] = Field(alias="givenName", default=None)
    family_name: Optional[str] = Field(alias="familyName", default=None)
    phone_number: Optional[str] = Field(alias="phoneNumber", default=None)
    email: Optional[str] = None
    uri: Optional[Any] = None
    similar_persons: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarPersons", default=None
    )


class CerebrasModelPropertiesUpdateInput(BaseModel):
    model: Optional[CerebrasModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )


class RerankingStrategyUpdateInput(BaseModel):
    service_type: Optional[RerankingModelServiceTypes] = Field(
        alias="serviceType", default=None
    )
    threshold: Optional[float] = None


class FeedFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    types: Optional[List[Optional[FeedTypes]]] = None


class DrawingMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    x: Optional[float] = None
    y: Optional[float] = None
    width: Optional[float] = None
    height: Optional[float] = None
    depth: Optional[float] = None
    unit_type: Optional[UnitTypes] = Field(alias="unitType", default=None)


class ConversationInput(BaseModel):
    name: str
    type: Optional[ConversationTypes] = None
    messages: Optional[List["ConversationMessageInput"]] = None
    specification: Optional["EntityReferenceInput"] = None
    fallbacks: Optional[List[Optional["EntityReferenceInput"]]] = None
    filter: Optional["ContentCriteriaInput"] = None
    augmented_filter: Optional["ContentCriteriaInput"] = Field(
        alias="augmentedFilter", default=None
    )


class Int64RangeFilter(BaseModel):
    from_: Optional[Any] = Field(alias="from", default=None)
    to: Optional[Any] = None


class AzureTextExtractionPropertiesInput(BaseModel):
    enable_pii: Optional[bool] = Field(alias="enablePII", default=None)
    confidence_threshold: Optional[float] = Field(
        alias="confidenceThreshold", default=None
    )


class WebFeedPropertiesInput(BaseModel):
    uri: Any
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths", default=None)
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths", default=None)
    include_files: Optional[bool] = Field(alias="includeFiles", default=None)
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class ImageMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    width: Optional[int] = None
    height: Optional[int] = None
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent", default=None)
    components: Optional[int] = None
    projection_type: Optional[ImageProjectionTypes] = Field(
        alias="projectionType", default=None
    )
    orientation: Optional[OrientationTypes] = None
    resolution_x: Optional[int] = Field(alias="resolutionX", default=None)
    resolution_y: Optional[int] = Field(alias="resolutionY", default=None)
    description: Optional[str] = None
    software: Optional[str] = None
    identifier: Optional[str] = None
    make: Optional[str] = None
    model: Optional[str] = None
    lens: Optional[str] = None
    lens_specification: Optional[str] = Field(alias="lensSpecification", default=None)
    focal_length: Optional[float] = Field(alias="focalLength", default=None)
    exposure_time: Optional[str] = Field(alias="exposureTime", default=None)
    f_number: Optional[str] = Field(alias="fNumber", default=None)
    iso: Optional[str] = None
    color_space: Optional[str] = Field(alias="colorSpace", default=None)
    heading: Optional[float] = None
    pitch: Optional[float] = None


class AlertUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    summary_prompt: Optional[str] = Field(alias="summaryPrompt", default=None)
    publish_prompt: Optional[str] = Field(alias="publishPrompt", default=None)
    filter: Optional["ContentCriteriaInput"] = None
    publishing: Optional["ContentPublishingConnectorUpdateInput"] = None
    integration: Optional["IntegrationConnectorUpdateInput"] = None
    summary_specification: Optional["EntityReferenceInput"] = Field(
        alias="summarySpecification", default=None
    )
    publish_specification: Optional["EntityReferenceInput"] = Field(
        alias="publishSpecification", default=None
    )
    schedule_policy: Optional["AlertSchedulePolicyInput"] = Field(
        alias="schedulePolicy", default=None
    )


class CategoryFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )


class ObservationOccurrenceInput(BaseModel):
    type: OccurrenceTypes
    confidence: Optional[float] = None
    bounding_box: Optional["BoundingBoxInput"] = Field(
        alias="boundingBox", default=None
    )
    page_index: Optional[int] = Field(alias="pageIndex", default=None)
    start_time: Optional[Any] = Field(alias="startTime", default=None)
    end_time: Optional[Any] = Field(alias="endTime", default=None)


class DeepseekModelPropertiesInput(BaseModel):
    model: DeepseekModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )


class MistralModelPropertiesInput(BaseModel):
    model: MistralModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class DeepseekModelPropertiesUpdateInput(BaseModel):
    model: Optional[DeepseekModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )


class GitHubIssuesFeedPropertiesInput(BaseModel):
    repository_owner: str = Field(alias="repositoryOwner")
    repository_name: str = Field(alias="repositoryName")
    uri: Optional[Any] = None
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    personal_access_token: Optional[str] = Field(
        alias="personalAccessToken", default=None
    )


class CategoryInput(BaseModel):
    name: str
    description: Optional[str] = None


class GoogleDriveFeedPropertiesUpdateInput(BaseModel):
    authentication_type: Optional[GoogleDriveAuthenticationTypes] = Field(
        alias="authenticationType", default=None
    )
    files: Optional[List[Optional[str]]] = None
    folder_id: Optional[str] = Field(alias="folderId", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    client_id: Optional[str] = Field(alias="clientId", default=None)
    client_secret: Optional[str] = Field(alias="clientSecret", default=None)
    service_account_json: Optional[str] = Field(
        alias="serviceAccountJson", default=None
    )


class PointCloudMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    software: Optional[str] = None
    description: Optional[str] = None
    identifier: Optional[str] = None
    point_count: Optional[Any] = Field(alias="pointCount", default=None)


class SearchFeedPropertiesUpdateInput(BaseModel):
    type: Optional[SearchServiceTypes] = None
    text: Optional[str] = None
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class MicrosoftTeamsFeedPropertiesInput(BaseModel):
    type: Optional[FeedListingTypes] = None
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")
    refresh_token: str = Field(alias="refreshToken")
    team_id: str = Field(alias="teamId")
    channel_id: str = Field(alias="channelId")
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class MedicalTestFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalTestFacetTypes] = None


class IssueFeedPropertiesInput(BaseModel):
    type: FeedServiceTypes
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )
    jira: Optional["AtlassianJiraFeedPropertiesInput"] = None
    linear: Optional["LinearFeedPropertiesInput"] = None
    github: Optional["GitHubIssuesFeedPropertiesInput"] = None
    intercom: Optional["IntercomTicketsFeedPropertiesInput"] = None
    zendesk: Optional["ZendeskTicketsFeedPropertiesInput"] = None
    trello: Optional["TrelloFeedPropertiesInput"] = None
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class CollectionInput(BaseModel):
    name: str
    type: Optional[CollectionTypes] = None
    contents: Optional[List["EntityReferenceInput"]] = None
    expected_count: Optional[int] = Field(alias="expectedCount", default=None)


class AzureOpenAIModelPropertiesInput(BaseModel):
    model: AzureOpenAIModels
    deployment_name: Optional[str] = Field(alias="deploymentName", default=None)
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class MicrosoftTeamsTeamsInput(BaseModel):
    refresh_token: str = Field(alias="refreshToken")


class ModelImageExtractionPropertiesInput(BaseModel):
    specification: Optional["EntityReferenceInput"] = None


class MedicalGuidelineInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class MedicalDrugClassFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_classes: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarClasses", default=None
    )


class MedicalStudyInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None


class LabelFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )


class AssemblyAIAudioPreparationPropertiesInput(BaseModel):
    model: Optional[AssemblyAIModels] = None
    key: Optional[str] = None
    enable_redaction: Optional[bool] = Field(alias="enableRedaction", default=None)
    enable_speaker_diarization: Optional[bool] = Field(
        alias="enableSpeakerDiarization", default=None
    )
    detect_language: Optional[bool] = Field(alias="detectLanguage", default=None)
    language: Optional[str] = None


class MicrosoftEmailFeedPropertiesInput(BaseModel):
    type: Optional[EmailListingTypes] = None
    inbox_only: Optional[bool] = Field(alias="inboxOnly", default=None)
    include_deleted_items: Optional[bool] = Field(
        alias="includeDeletedItems", default=None
    )
    exclude_sent_items: Optional[bool] = Field(alias="excludeSentItems", default=None)
    include_spam: Optional[bool] = Field(alias="includeSpam", default=None)
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")
    refresh_token: str = Field(alias="refreshToken")


class GoogleModelPropertiesInput(BaseModel):
    model: GoogleModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)
    enable_thinking: Optional[bool] = Field(alias="enableThinking", default=None)
    thinking_token_limit: Optional[int] = Field(
        alias="thinkingTokenLimit", default=None
    )


class WorkflowActionInput(BaseModel):
    connector: Optional["IntegrationConnectorInput"] = None


class RevisionStrategyInput(BaseModel):
    type: Optional[RevisionStrategyTypes] = None
    custom_revision: Optional[str] = Field(alias="customRevision", default=None)
    count: Optional[int] = None


class EmailIntegrationPropertiesInput(BaseModel):
    subject: str
    from_: str = Field(alias="from")
    to: List[str]


class ConversationUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    specification: Optional["EntityReferenceInput"] = None
    fallbacks: Optional[List[Optional["EntityReferenceInput"]]] = None
    filter: Optional["ContentCriteriaInput"] = None
    augmented_filter: Optional["ContentCriteriaInput"] = Field(
        alias="augmentedFilter", default=None
    )


class ProjectQuotaInput(BaseModel):
    storage: Optional[Any] = None
    contents: Optional[int] = None
    feeds: Optional[int] = None
    posts: Optional[int] = None
    conversations: Optional[int] = None


class ModelDocumentPreparationPropertiesInput(BaseModel):
    specification: Optional["EntityReferenceInput"] = None


class IssueFeedPropertiesUpdateInput(BaseModel):
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )
    jira: Optional["AtlassianJiraFeedPropertiesUpdateInput"] = None
    linear: Optional["LinearFeedPropertiesUpdateInput"] = None
    github: Optional["GitHubIssuesFeedPropertiesUpdateInput"] = None
    intercom: Optional["IntercomTicketsFeedPropertiesUpdateInput"] = None
    zendesk: Optional["ZendeskTicketsFeedPropertiesUpdateInput"] = None
    trello: Optional["TrelloFeedPropertiesUpdateInput"] = None
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class WorkflowUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    ingestion: Optional["IngestionWorkflowStageInput"] = None
    indexing: Optional["IndexingWorkflowStageInput"] = None
    preparation: Optional["PreparationWorkflowStageInput"] = None
    extraction: Optional["ExtractionWorkflowStageInput"] = None
    enrichment: Optional["EnrichmentWorkflowStageInput"] = None
    classification: Optional["ClassificationWorkflowStageInput"] = None
    storage: Optional["StorageWorkflowStageInput"] = None
    actions: Optional[List[Optional["WorkflowActionInput"]]] = None


class AzureBlobFeedPropertiesUpdateInput(BaseModel):
    storage_access_key: Optional[str] = Field(alias="storageAccessKey", default=None)
    account_name: Optional[str] = Field(alias="accountName", default=None)
    container_name: Optional[str] = Field(alias="containerName", default=None)
    prefix: Optional[str] = None


class MedicalDrugClassUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class AlertSchedulePolicyInput(BaseModel):
    recurrence_type: Optional[TimedPolicyRecurrenceTypes] = Field(
        alias="recurrenceType", default=None
    )
    repeat_until_time: Optional[Any] = Field(alias="repeatUntilTime", default=None)
    repeat_interval: Optional[Any] = Field(alias="repeatInterval", default=None)
    delay: Optional[Any] = None
    time_type: Optional[PolicyTimeTypes] = Field(alias="timeType", default=None)
    absolute_time: Optional[Any] = Field(alias="absoluteTime", default=None)
    relative_time: Optional[Any] = Field(alias="relativeTime", default=None)


class MedicalTestFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_tests: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarTests", default=None
    )


class IndexingWorkflowStageInput(BaseModel):
    jobs: Optional[List[Optional["IndexingWorkflowJobInput"]]] = None


class FeedUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    type: Optional[FeedTypes] = None
    site: Optional["SiteFeedPropertiesUpdateInput"] = None
    email: Optional["EmailFeedPropertiesUpdateInput"] = None
    issue: Optional["IssueFeedPropertiesUpdateInput"] = None
    rss: Optional["RSSFeedPropertiesUpdateInput"] = None
    web: Optional["WebFeedPropertiesUpdateInput"] = None
    search: Optional["SearchFeedPropertiesUpdateInput"] = None
    reddit: Optional["RedditFeedPropertiesUpdateInput"] = None
    youtube: Optional["YouTubeFeedPropertiesUpdateInput"] = None
    notion: Optional["NotionFeedPropertiesUpdateInput"] = None
    twitter: Optional["TwitterFeedPropertiesUpdateInput"] = None
    slack: Optional["SlackFeedPropertiesUpdateInput"] = None
    microsoft_teams: Optional["MicrosoftTeamsFeedPropertiesUpdateInput"] = Field(
        alias="microsoftTeams", default=None
    )
    discord: Optional["DiscordFeedPropertiesUpdateInput"] = None
    intercom: Optional["IntercomFeedPropertiesUpdateInput"] = None
    zendesk: Optional["ZendeskFeedPropertiesUpdateInput"] = None
    schedule_policy: Optional["FeedSchedulePolicyInput"] = Field(
        alias="schedulePolicy", default=None
    )
    workflow: Optional["EntityReferenceInput"] = None


class SlackChannelsInput(BaseModel):
    token: str


class SlackFeedPropertiesInput(BaseModel):
    type: Optional[FeedListingTypes] = None
    token: str
    channel: str
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class SlackFeedPropertiesUpdateInput(BaseModel):
    type: Optional[FeedListingTypes] = None
    token: Optional[str] = None
    channel: Optional[str] = None
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class DropboxFeedPropertiesInput(BaseModel):
    path: Optional[str] = None
    app_key: str = Field(alias="appKey")
    app_secret: str = Field(alias="appSecret")
    refresh_token: str = Field(alias="refreshToken")
    redirect_uri: str = Field(alias="redirectUri")


class MedicalProcedureFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_procedures: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarProcedures", default=None
    )


class ExtractionWorkflowJobInput(BaseModel):
    connector: Optional["EntityExtractionConnectorInput"] = None


class GoogleAuthenticationPropertiesInput(BaseModel):
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class MedicalProcedureInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class AzureDocumentPreparationPropertiesInput(BaseModel):
    model: Optional[AzureDocumentIntelligenceModels] = None
    endpoint: Optional[Any] = None
    key: Optional[str] = None
    version: Optional[AzureDocumentIntelligenceVersions] = None


class BoundingBoxInput(BaseModel):
    left: Optional[float] = None
    top: Optional[float] = None
    width: Optional[float] = None
    height: Optional[float] = None


class IntercomFeedPropertiesUpdateInput(BaseModel):
    access_token: Optional[str] = Field(alias="accessToken", default=None)
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class ModelTextExtractionPropertiesInput(BaseModel):
    specification: Optional["EntityReferenceInput"] = None


class FeedSchedulePolicyInput(BaseModel):
    recurrence_type: TimedPolicyRecurrenceTypes = Field(alias="recurrenceType")
    repeat_interval: Optional[Any] = Field(alias="repeatInterval", default=None)


class AzureOpenAIModelPropertiesUpdateInput(BaseModel):
    model: Optional[AzureOpenAIModels] = None
    deployment_name: Optional[str] = Field(alias="deploymentName", default=None)
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class WorkflowInput(BaseModel):
    name: str
    ingestion: Optional["IngestionWorkflowStageInput"] = None
    indexing: Optional["IndexingWorkflowStageInput"] = None
    preparation: Optional["PreparationWorkflowStageInput"] = None
    extraction: Optional["ExtractionWorkflowStageInput"] = None
    enrichment: Optional["EnrichmentWorkflowStageInput"] = None
    classification: Optional["ClassificationWorkflowStageInput"] = None
    storage: Optional["StorageWorkflowStageInput"] = None
    actions: Optional[List[Optional["WorkflowActionInput"]]] = None


class MicrosoftTeamsFeedPropertiesUpdateInput(BaseModel):
    type: Optional[FeedListingTypes] = None
    client_id: Optional[str] = Field(alias="clientId", default=None)
    client_secret: Optional[str] = Field(alias="clientSecret", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    team_id: str = Field(alias="teamId")
    channel_id: str = Field(alias="channelId")
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class ZendeskFeedPropertiesInput(BaseModel):
    subdomain: str
    access_token: str = Field(alias="accessToken")
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class CollectionFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    types: Optional[List[CollectionTypes]] = None
    disable_inheritance: Optional[bool] = Field(
        alias="disableInheritance", default=None
    )


class ConversationToolResponseInput(BaseModel):
    id: str
    content: str


class LabelUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None


class MedicalConditionFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_conditions: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarConditions", default=None
    )


class EmailMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    subject: Optional[str] = None
    identifier: Optional[str] = None
    thread_identifier: Optional[str] = Field(alias="threadIdentifier", default=None)
    sensitivity: Optional[MailSensitivity] = None
    priority: Optional[MailPriority] = None
    importance: Optional[MailImportance] = None
    labels: Optional[List[Optional[str]]] = None
    links: Optional[List[Optional[Any]]] = None


class MicrosoftTeamsChannelsInput(BaseModel):
    refresh_token: str = Field(alias="refreshToken")


class IntercomFeedPropertiesInput(BaseModel):
    access_token: str = Field(alias="accessToken")
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class AddressInput(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress", default=None)
    city: Optional[str] = None
    region: Optional[str] = None
    country: Optional[str] = None
    postal_code: Optional[str] = Field(alias="postalCode", default=None)


class GroqModelPropertiesInput(BaseModel):
    model: GroqModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    endpoint: Optional[Any] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )


class LinearFeedPropertiesInput(BaseModel):
    key: str
    project: str


class GitHubFeedPropertiesUpdateInput(BaseModel):
    repository_owner: Optional[str] = Field(alias="repositoryOwner", default=None)
    repository_name: Optional[str] = Field(alias="repositoryName", default=None)
    uri: Optional[Any] = None
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    personal_access_token: Optional[str] = Field(
        alias="personalAccessToken", default=None
    )


class VoyageModelPropertiesUpdateInput(BaseModel):
    model: Optional[VoyageModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)


class MedicalGuidelineUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class GeometryMetadataInput(BaseModel):
    creation_date: Optional[Any] = Field(alias="creationDate", default=None)
    modified_date: Optional[Any] = Field(alias="modifiedDate", default=None)
    location: Optional["PointInput"] = None
    triangle_count: Optional[Any] = Field(alias="triangleCount", default=None)
    vertex_count: Optional[Any] = Field(alias="vertexCount", default=None)


class SiteFeedPropertiesUpdateInput(BaseModel):
    is_recursive: Optional[bool] = Field(alias="isRecursive", default=None)
    s_3: Optional["AmazonFeedPropertiesUpdateInput"] = Field(alias="s3", default=None)
    azure_blob: Optional["AzureBlobFeedPropertiesUpdateInput"] = Field(
        alias="azureBlob", default=None
    )
    azure_file: Optional["AzureFileFeedPropertiesUpdateInput"] = Field(
        alias="azureFile", default=None
    )
    google: Optional["GoogleFeedPropertiesUpdateInput"] = None
    share_point: Optional["SharePointFeedPropertiesUpdateInput"] = Field(
        alias="sharePoint", default=None
    )
    one_drive: Optional["OneDriveFeedPropertiesUpdateInput"] = Field(
        alias="oneDrive", default=None
    )
    google_drive: Optional["GoogleDriveFeedPropertiesUpdateInput"] = Field(
        alias="googleDrive", default=None
    )
    github: Optional["GitHubFeedPropertiesUpdateInput"] = None
    dropbox: Optional["DropboxFeedPropertiesUpdateInput"] = None
    box: Optional["BoxFeedPropertiesUpdateInput"] = None
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class MedicalTestUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class GraphStrategyUpdateInput(BaseModel):
    type: Optional[GraphStrategyTypes] = None
    generate_graph: Optional[bool] = Field(alias="generateGraph", default=None)
    observable_limit: Optional[int] = Field(alias="observableLimit", default=None)


class PreparationWorkflowJobInput(BaseModel):
    connector: Optional["FilePreparationConnectorInput"] = None


class NotionFeedPropertiesInput(BaseModel):
    is_recursive: Optional[bool] = Field(alias="isRecursive", default=None)
    token: str
    type: NotionTypes
    identifiers: List[str]
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class MedicalDeviceUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class ConversationStrategyUpdateInput(BaseModel):
    type: Optional[ConversationStrategyTypes] = None
    message_limit: Optional[int] = Field(alias="messageLimit", default=None)
    embed_citations: Optional[bool] = Field(alias="embedCitations", default=None)
    flatten_citations: Optional[bool] = Field(alias="flattenCitations", default=None)
    enable_facets: Optional[bool] = Field(alias="enableFacets", default=None)
    messages_weight: Optional[float] = Field(alias="messagesWeight", default=None)
    contents_weight: Optional[float] = Field(alias="contentsWeight", default=None)


class MicrosoftEmailFeedPropertiesUpdateInput(BaseModel):
    type: Optional[EmailListingTypes] = None
    inbox_only: Optional[bool] = Field(alias="inboxOnly", default=None)
    include_deleted_items: Optional[bool] = Field(
        alias="includeDeletedItems", default=None
    )
    exclude_sent_items: Optional[bool] = Field(alias="excludeSentItems", default=None)
    include_spam: Optional[bool] = Field(alias="includeSpam", default=None)
    client_id: Optional[str] = Field(alias="clientId", default=None)
    client_secret: Optional[str] = Field(alias="clientSecret", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)


class MetadataInput(BaseModel):
    name: str
    mime_type: Optional[str] = Field(alias="mimeType", default=None)
    value: Optional[str] = None
    content: Optional["EntityReferenceInput"] = None


class OneDriveFeedPropertiesUpdateInput(BaseModel):
    files: Optional[List[Optional[str]]] = None
    folder_id: Optional[str] = Field(alias="folderId", default=None)
    client_id: Optional[str] = Field(alias="clientId", default=None)
    client_secret: Optional[str] = Field(alias="clientSecret", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)


class TwitterFeedPropertiesInput(BaseModel):
    token: str
    type: Optional[TwitterListingTypes] = None
    user_name: Optional[str] = Field(alias="userName", default=None)
    query: Optional[str] = None
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class ConversationMessageInput(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str] = None
    message: str
    data: Optional[str] = None
    mime_type: Optional[str] = Field(alias="mimeType", default=None)


class AnthropicModelPropertiesUpdateInput(BaseModel):
    model: Optional[AnthropicModels] = None
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    enable_thinking: Optional[bool] = Field(alias="enableThinking", default=None)
    thinking_token_limit: Optional[int] = Field(
        alias="thinkingTokenLimit", default=None
    )


class PlaceUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None


class AlertInput(BaseModel):
    name: str
    type: AlertTypes
    summary_prompt: Optional[str] = Field(alias="summaryPrompt", default=None)
    publish_prompt: str = Field(alias="publishPrompt")
    filter: Optional["ContentCriteriaInput"] = None
    publishing: "ContentPublishingConnectorInput"
    integration: "IntegrationConnectorInput"
    summary_specification: Optional["EntityReferenceInput"] = Field(
        alias="summarySpecification", default=None
    )
    publish_specification: Optional["EntityReferenceInput"] = Field(
        alias="publishSpecification", default=None
    )
    schedule_policy: Optional["AlertSchedulePolicyInput"] = Field(
        alias="schedulePolicy", default=None
    )


class RetrievalStrategyUpdateInput(BaseModel):
    type: Optional[RetrievalStrategyTypes] = None
    content_limit: Optional[int] = Field(alias="contentLimit", default=None)


class EventUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None
    start_date: Optional[Any] = Field(alias="startDate", default=None)
    end_date: Optional[Any] = Field(alias="endDate", default=None)
    availability_start_date: Optional[Any] = Field(
        alias="availabilityStartDate", default=None
    )
    availability_end_date: Optional[Any] = Field(
        alias="availabilityEndDate", default=None
    )
    price: Optional[Any] = None
    min_price: Optional[Any] = Field(alias="minPrice", default=None)
    max_price: Optional[Any] = Field(alias="maxPrice", default=None)
    price_currency: Optional[str] = Field(alias="priceCurrency", default=None)
    is_accessible_for_free: Optional[bool] = Field(
        alias="isAccessibleForFree", default=None
    )
    typical_age_range: Optional[str] = Field(alias="typicalAgeRange", default=None)


class UserUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    type: Optional[UserTypes] = None
    identifier: Optional[str] = None
    description: Optional[str] = None


class EmailFeedPropertiesUpdateInput(BaseModel):
    include_attachments: Optional[bool] = Field(
        alias="includeAttachments", default=None
    )
    google: Optional["GoogleEmailFeedPropertiesUpdateInput"] = None
    microsoft: Optional["MicrosoftEmailFeedPropertiesUpdateInput"] = None
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class LinkStrategyInput(BaseModel):
    enable_crawling: Optional[bool] = Field(alias="enableCrawling", default=None)
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths", default=None)
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths", default=None)
    allowed_domains: Optional[List[str]] = Field(alias="allowedDomains", default=None)
    excluded_domains: Optional[List[str]] = Field(alias="excludedDomains", default=None)
    allow_content_domain: Optional[bool] = Field(
        alias="allowContentDomain", default=None
    )
    allowed_links: Optional[List[LinkTypes]] = Field(alias="allowedLinks", default=None)
    excluded_links: Optional[List[LinkTypes]] = Field(
        alias="excludedLinks", default=None
    )
    allowed_files: Optional[List[FileTypes]] = Field(alias="allowedFiles", default=None)
    excluded_files: Optional[List[FileTypes]] = Field(
        alias="excludedFiles", default=None
    )
    maximum_links: Optional[int] = Field(alias="maximumLinks", default=None)


class IntercomTicketsFeedPropertiesInput(BaseModel):
    access_token: str = Field(alias="accessToken")


class MedicalDrugInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class ProductInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None
    address: Optional["AddressInput"] = None
    production_date: Optional[Any] = Field(alias="productionDate", default=None)
    release_date: Optional[Any] = Field(alias="releaseDate", default=None)
    sku: Optional[str] = None
    upc: Optional[str] = None
    manufacturer: Optional[str] = None
    brand: Optional[str] = None
    model: Optional[str] = None


class MedicalDrugClassInput(BaseModel):
    name: str
    uri: Optional[Any] = None
    identifier: Optional[str] = None
    description: Optional[str] = None
    location: Optional["PointInput"] = None
    boundary: Optional[str] = None


class OrganizationFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    uri: Optional[Any] = None
    similar_organizations: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarOrganizations", default=None
    )


class SoftwareFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[SoftwareFacetTypes] = None


class ZendeskFeedPropertiesUpdateInput(BaseModel):
    subdomain: Optional[str] = None
    access_token: Optional[str] = Field(alias="accessToken", default=None)
    read_limit: Optional[int] = Field(alias="readLimit", default=None)


class AuthenticationConnectorInput(BaseModel):
    type: AuthenticationServiceTypes
    microsoft: Optional["MicrosoftAuthenticationPropertiesInput"] = None
    google: Optional["GoogleAuthenticationPropertiesInput"] = None


class MedicalConditionFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[MedicalConditionFacetTypes] = None


class GoogleFeedPropertiesUpdateInput(BaseModel):
    credentials: Optional[str] = None
    container_name: Optional[str] = Field(alias="containerName", default=None)
    prefix: Optional[str] = None


class PersonFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[PersonFacetTypes] = None


class PlaceFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[PlaceFacetTypes] = None


class AnthropicModelPropertiesInput(BaseModel):
    model: AnthropicModels
    model_name: Optional[str] = Field(alias="modelName", default=None)
    key: Optional[str] = None
    temperature: Optional[float] = None
    probability: Optional[float] = None
    token_limit: Optional[int] = Field(alias="tokenLimit", default=None)
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit", default=None)
    completion_token_limit: Optional[int] = Field(
        alias="completionTokenLimit", default=None
    )
    enable_thinking: Optional[bool] = Field(alias="enableThinking", default=None)
    thinking_token_limit: Optional[int] = Field(
        alias="thinkingTokenLimit", default=None
    )


class ContentCriteriaLevelInput(BaseModel):
    feeds: Optional[List["EntityReferenceInput"]] = None
    workflows: Optional[List["EntityReferenceInput"]] = None
    collections: Optional[List["EntityReferenceInput"]] = None
    observations: Optional[List["ObservationCriteriaInput"]] = None


class ConnectorUpdateInput(BaseModel):
    id: str
    name: Optional[str] = None
    authentication: Optional["AuthenticationConnectorInput"] = None
    integration: Optional["IntegrationConnectorInput"] = None


class SharePointFeedPropertiesUpdateInput(BaseModel):
    authentication_type: Optional[SharePointAuthenticationTypes] = Field(
        alias="authenticationType", default=None
    )
    tenant_id: Optional[str] = Field(alias="tenantId", default=None)
    refresh_token: Optional[str] = Field(alias="refreshToken", default=None)
    account_name: Optional[str] = Field(alias="accountName", default=None)
    library_id: Optional[str] = Field(alias="libraryId", default=None)
    folder_id: Optional[str] = Field(alias="folderId", default=None)


class PlaceFilter(BaseModel):
    search: Optional[str] = None
    order_by: Optional[OrderByTypes] = Field(alias="orderBy", default=None)
    direction: Optional[OrderDirectionTypes] = None
    offset: Optional[int] = None
    limit: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    states: Optional[List[EntityState]] = None
    created_in_last: Optional[Any] = Field(alias="createdInLast", default=None)
    creation_date_range: Optional["DateRangeFilter"] = Field(
        alias="creationDateRange", default=None
    )
    address: Optional["AddressFilter"] = None
    location: Optional["PointFilter"] = None
    h_3: Optional["H3Filter"] = Field(alias="h3", default=None)
    boundaries: Optional[List[Optional[str]]] = None
    search_type: Optional[SearchTypes] = Field(alias="searchType", default=None)
    query_type: Optional[SearchQueryTypes] = Field(alias="queryType", default=None)
    number_similar: Optional[int] = Field(alias="numberSimilar", default=None)
    similar_places: Optional[List["EntityReferenceFilter"]] = Field(
        alias="similarPlaces", default=None
    )


class H3Filter(BaseModel):
    indexes: Optional[List["H3IndexFilter"]] = None


class ProductFacetInput(BaseModel):
    time_interval: Optional[TimeIntervalTypes] = Field(
        alias="timeInterval", default=None
    )
    time_offset: Optional[int] = Field(alias="timeOffset", default=None)
    facet: Optional[ProductFacetTypes] = None


class EntityReferenceFilter(BaseModel):
    id: str


OrganizationInput.model_rebuild()
ContentCriteriaInput.model_rebuild()
MetadataUpdateInput.model_rebuild()
MedicalIndicationUpdateInput.model_rebuild()
StorageWorkflowStageInput.model_rebuild()
WorkflowFilter.model_rebuild()
MedicalIndicationInput.model_rebuild()
UserFilter.model_rebuild()
RegexContentClassificationPropertiesInput.model_rebuild()
ProductFilter.model_rebuild()
EnrichmentWorkflowJobInput.model_rebuild()
ContentUpdateInput.model_rebuild()
ShapeMetadataInput.model_rebuild()
MedicalDeviceInput.model_rebuild()
MedicalContraindicationUpdateInput.model_rebuild()
EntityEnrichmentConnectorInput.model_rebuild()
PlaceInput.model_rebuild()
SpecificationFilter.model_rebuild()
EmbeddingsStrategyInput.model_rebuild()
ConnectorFilter.model_rebuild()
OpenAIImagePublishingPropertiesInput.model_rebuild()
ProjectUpdateInput.model_rebuild()
MedicalStudyFilter.model_rebuild()
ClassificationWorkflowJobInput.model_rebuild()
CollectionUpdateInput.model_rebuild()
SpecificationInput.model_rebuild()
PackageMetadataInput.model_rebuild()
ConnectorInput.model_rebuild()
PreparationWorkflowStageInput.model_rebuild()
ProjectFilter.model_rebuild()
MedicalProcedureUpdateInput.model_rebuild()
MedicalStudyUpdateInput.model_rebuild()
MedicalTestInput.model_rebuild()
RepoFilter.model_rebuild()
IntegrationConnectorUpdateInput.model_rebuild()
MedicalDeviceFilter.model_rebuild()
MedicalContraindicationFilter.model_rebuild()
ProjectInput.model_rebuild()
MedicalIndicationFilter.model_rebuild()
IndexingWorkflowJobInput.model_rebuild()
ObservationCriteriaInput.model_rebuild()
MedicalTherapyUpdateInput.model_rebuild()
ObservationInput.model_rebuild()
IntegrationConnectorInput.model_rebuild()
SummarizationStrategyInput.model_rebuild()
OrganizationUpdateInput.model_rebuild()
DocumentMetadataInput.model_rebuild()
ConversationFilter.model_rebuild()
ContentPublishingConnectorInput.model_rebuild()
EventInput.model_rebuild()
ObservationUpdateInput.model_rebuild()
AudioMetadataInput.model_rebuild()
SpecificationUpdateInput.model_rebuild()
ContentPublishingConnectorUpdateInput.model_rebuild()
EventFilter.model_rebuild()
ClassificationWorkflowStageInput.model_rebuild()
ObservationReferenceFilter.model_rebuild()
MedicalGuidelineFilter.model_rebuild()
EmailFeedPropertiesInput.model_rebuild()
ObservationReferenceInput.model_rebuild()
ContentFilterLevel.model_rebuild()
FeedInput.model_rebuild()
FilePreparationConnectorInput.model_rebuild()
MedicalDrugFilter.model_rebuild()
MedicalTherapyInput.model_rebuild()
ContentInput.model_rebuild()
MedicalContraindicationInput.model_rebuild()
ContentFilter.model_rebuild()
EntityExtractionConnectorInput.model_rebuild()
MetadataFilter.model_rebuild()
AlertFilter.model_rebuild()
MedicalConditionInput.model_rebuild()
ProductUpdateInput.model_rebuild()
PersonUpdateInput.model_rebuild()
IngestionWorkflowStageInput.model_rebuild()
VideoMetadataInput.model_rebuild()
ExtractionWorkflowStageInput.model_rebuild()
MedicalConditionUpdateInput.model_rebuild()
IssueMetadataInput.model_rebuild()
MedicalTherapyFilter.model_rebuild()
MedicalDrugUpdateInput.model_rebuild()
PersonInput.model_rebuild()
SoftwareFilter.model_rebuild()
SiteFeedPropertiesInput.model_rebuild()
ModelContentClassificationPropertiesInput.model_rebuild()
ContentClassificationConnectorInput.model_rebuild()
EnrichmentWorkflowStageInput.model_rebuild()
PersonFilter.model_rebuild()
FeedFilter.model_rebuild()
DrawingMetadataInput.model_rebuild()
ConversationInput.model_rebuild()
ImageMetadataInput.model_rebuild()
AlertUpdateInput.model_rebuild()
CategoryFilter.model_rebuild()
ObservationOccurrenceInput.model_rebuild()
PointCloudMetadataInput.model_rebuild()
IssueFeedPropertiesInput.model_rebuild()
CollectionInput.model_rebuild()
ModelImageExtractionPropertiesInput.model_rebuild()
MedicalGuidelineInput.model_rebuild()
MedicalDrugClassFilter.model_rebuild()
MedicalStudyInput.model_rebuild()
LabelFilter.model_rebuild()
WorkflowActionInput.model_rebuild()
ConversationUpdateInput.model_rebuild()
ModelDocumentPreparationPropertiesInput.model_rebuild()
IssueFeedPropertiesUpdateInput.model_rebuild()
WorkflowUpdateInput.model_rebuild()
MedicalDrugClassUpdateInput.model_rebuild()
MedicalTestFilter.model_rebuild()
IndexingWorkflowStageInput.model_rebuild()
FeedUpdateInput.model_rebuild()
MedicalProcedureFilter.model_rebuild()
ExtractionWorkflowJobInput.model_rebuild()
MedicalProcedureInput.model_rebuild()
ModelTextExtractionPropertiesInput.model_rebuild()
WorkflowInput.model_rebuild()
CollectionFilter.model_rebuild()
MedicalConditionFilter.model_rebuild()
EmailMetadataInput.model_rebuild()
MedicalGuidelineUpdateInput.model_rebuild()
GeometryMetadataInput.model_rebuild()
SiteFeedPropertiesUpdateInput.model_rebuild()
MedicalTestUpdateInput.model_rebuild()
PreparationWorkflowJobInput.model_rebuild()
MedicalDeviceUpdateInput.model_rebuild()
MetadataInput.model_rebuild()
PlaceUpdateInput.model_rebuild()
AlertInput.model_rebuild()
EventUpdateInput.model_rebuild()
EmailFeedPropertiesUpdateInput.model_rebuild()
MedicalDrugInput.model_rebuild()
ProductInput.model_rebuild()
MedicalDrugClassInput.model_rebuild()
OrganizationFilter.model_rebuild()
AuthenticationConnectorInput.model_rebuild()
ContentCriteriaLevelInput.model_rebuild()
ConnectorUpdateInput.model_rebuild()
PlaceFilter.model_rebuild()
H3Filter.model_rebuild()



================================================
FILE: graphlit_api/is_content_done.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class IsContentDone(BaseModel):
    is_content_done: Optional["IsContentDoneIsContentDone"] = Field(
        alias="isContentDone"
    )


class IsContentDoneIsContentDone(BaseModel):
    result: Optional[bool]


IsContentDone.model_rebuild()



================================================
FILE: graphlit_api/is_feed_done.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class IsFeedDone(BaseModel):
    is_feed_done: Optional["IsFeedDoneIsFeedDone"] = Field(alias="isFeedDone")


class IsFeedDoneIsFeedDone(BaseModel):
    result: Optional[bool]


IsFeedDone.model_rebuild()



================================================
FILE: graphlit_api/lookup_credits.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class LookupCredits(BaseModel):
    lookup_credits: Optional["LookupCreditsLookupCredits"] = Field(
        alias="lookupCredits"
    )


class LookupCreditsLookupCredits(BaseModel):
    correlation_id: Optional[str] = Field(alias="correlationId")
    owner_id: Optional[str] = Field(alias="ownerId")
    credits: Optional[Any]
    storage_ratio: Optional[Any] = Field(alias="storageRatio")
    compute_ratio: Optional[Any] = Field(alias="computeRatio")
    embedding_ratio: Optional[Any] = Field(alias="embeddingRatio")
    completion_ratio: Optional[Any] = Field(alias="completionRatio")
    generation_ratio: Optional[Any] = Field(alias="generationRatio")
    ingestion_ratio: Optional[Any] = Field(alias="ingestionRatio")
    indexing_ratio: Optional[Any] = Field(alias="indexingRatio")
    preparation_ratio: Optional[Any] = Field(alias="preparationRatio")
    extraction_ratio: Optional[Any] = Field(alias="extractionRatio")
    classification_ratio: Optional[Any] = Field(alias="classificationRatio")
    enrichment_ratio: Optional[Any] = Field(alias="enrichmentRatio")
    publishing_ratio: Optional[Any] = Field(alias="publishingRatio")
    search_ratio: Optional[Any] = Field(alias="searchRatio")
    conversation_ratio: Optional[Any] = Field(alias="conversationRatio")


LookupCredits.model_rebuild()



================================================
FILE: graphlit_api/lookup_usage.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import BillableMetrics, ContentTypes, EntityTypes, FileTypes, OperationTypes


class LookupUsage(BaseModel):
    lookup_usage: Optional[List[Optional["LookupUsageLookupUsage"]]] = Field(
        alias="lookupUsage"
    )


class LookupUsageLookupUsage(BaseModel):
    id: Optional[str]
    correlation_id: Optional[str] = Field(alias="correlationId")
    date: Any
    credits: Optional[Any]
    name: str
    metric: Optional[BillableMetrics]
    workflow: Optional[str]
    entity_type: Optional[EntityTypes] = Field(alias="entityType")
    entity_id: Optional[str] = Field(alias="entityId")
    project_id: str = Field(alias="projectId")
    owner_id: str = Field(alias="ownerId")
    uri: Optional[str]
    duration: Optional[Any]
    throughput: Optional[float]
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")
    model_service: Optional[str] = Field(alias="modelService")
    model_name: Optional[str] = Field(alias="modelName")
    processor_name: Optional[str] = Field(alias="processorName")
    prompt: Optional[str]
    prompt_tokens: Optional[int] = Field(alias="promptTokens")
    completion: Optional[str]
    completion_tokens: Optional[int] = Field(alias="completionTokens")
    tokens: Optional[int]
    count: Optional[int]
    operation: Optional[str]
    operation_type: Optional[OperationTypes] = Field(alias="operationType")
    request: Optional[str]
    variables: Optional[str]
    response: Optional[str]


LookupUsage.model_rebuild()



================================================
FILE: graphlit_api/map_web.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class MapWeb(BaseModel):
    map_web: Optional["MapWebMapWeb"] = Field(alias="mapWeb")


class MapWebMapWeb(BaseModel):
    results: Optional[List[Optional[Any]]]


MapWeb.model_rebuild()



================================================
FILE: graphlit_api/operations.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

__all__ = [
    "ADD_CONTENTS_TO_COLLECTIONS_GQL",
    "ASK_GRAPHLIT_GQL",
    "CLEAR_CONVERSATION_GQL",
    "CLOSE_CONVERSATION_GQL",
    "COMPLETE_CONVERSATION_GQL",
    "CONTINUE_CONVERSATION_GQL",
    "COUNT_ALERTS_GQL",
    "COUNT_CATEGORIES_GQL",
    "COUNT_COLLECTIONS_GQL",
    "COUNT_CONTENTS_GQL",
    "COUNT_CONVERSATIONS_GQL",
    "COUNT_EVENTS_GQL",
    "COUNT_FEEDS_GQL",
    "COUNT_LABELS_GQL",
    "COUNT_MEDICAL_CONDITIONS_GQL",
    "COUNT_MEDICAL_CONTRAINDICATIONS_GQL",
    "COUNT_MEDICAL_DEVICES_GQL",
    "COUNT_MEDICAL_DRUGS_GQL",
    "COUNT_MEDICAL_DRUG_CLASSES_GQL",
    "COUNT_MEDICAL_GUIDELINES_GQL",
    "COUNT_MEDICAL_INDICATIONS_GQL",
    "COUNT_MEDICAL_PROCEDURES_GQL",
    "COUNT_MEDICAL_STUDIES_GQL",
    "COUNT_MEDICAL_TESTS_GQL",
    "COUNT_MEDICAL_THERAPIES_GQL",
    "COUNT_ORGANIZATIONS_GQL",
    "COUNT_PERSONS_GQL",
    "COUNT_PLACES_GQL",
    "COUNT_PRODUCTS_GQL",
    "COUNT_REPOS_GQL",
    "COUNT_SOFTWARES_GQL",
    "COUNT_SPECIFICATIONS_GQL",
    "COUNT_USERS_GQL",
    "COUNT_WORKFLOWS_GQL",
    "CREATE_ALERT_GQL",
    "CREATE_CATEGORY_GQL",
    "CREATE_COLLECTION_GQL",
    "CREATE_CONVERSATION_GQL",
    "CREATE_EVENT_GQL",
    "CREATE_FEED_GQL",
    "CREATE_LABEL_GQL",
    "CREATE_MEDICAL_CONDITION_GQL",
    "CREATE_MEDICAL_CONTRAINDICATION_GQL",
    "CREATE_MEDICAL_DEVICE_GQL",
    "CREATE_MEDICAL_DRUG_CLASS_GQL",
    "CREATE_MEDICAL_DRUG_GQL",
    "CREATE_MEDICAL_GUIDELINE_GQL",
    "CREATE_MEDICAL_INDICATION_GQL",
    "CREATE_MEDICAL_PROCEDURE_GQL",
    "CREATE_MEDICAL_STUDY_GQL",
    "CREATE_MEDICAL_TEST_GQL",
    "CREATE_MEDICAL_THERAPY_GQL",
    "CREATE_OBSERVATION_GQL",
    "CREATE_ORGANIZATION_GQL",
    "CREATE_PERSON_GQL",
    "CREATE_PLACE_GQL",
    "CREATE_PRODUCT_GQL",
    "CREATE_REPO_GQL",
    "CREATE_SOFTWARE_GQL",
    "CREATE_SPECIFICATION_GQL",
    "CREATE_USER_GQL",
    "CREATE_WORKFLOW_GQL",
    "DELETE_ALERTS_GQL",
    "DELETE_ALERT_GQL",
    "DELETE_ALL_ALERTS_GQL",
    "DELETE_ALL_CATEGORIES_GQL",
    "DELETE_ALL_COLLECTIONS_GQL",
    "DELETE_ALL_CONTENTS_GQL",
    "DELETE_ALL_CONVERSATIONS_GQL",
    "DELETE_ALL_EVENTS_GQL",
    "DELETE_ALL_FEEDS_GQL",
    "DELETE_ALL_LABELS_GQL",
    "DELETE_ALL_MEDICAL_CONDITIONS_GQL",
    "DELETE_ALL_MEDICAL_CONTRAINDICATIONS_GQL",
    "DELETE_ALL_MEDICAL_DEVICES_GQL",
    "DELETE_ALL_MEDICAL_DRUGS_GQL",
    "DELETE_ALL_MEDICAL_DRUG_CLASSES_GQL",
    "DELETE_ALL_MEDICAL_GUIDELINES_GQL",
    "DELETE_ALL_MEDICAL_INDICATIONS_GQL",
    "DELETE_ALL_MEDICAL_PROCEDURES_GQL",
    "DELETE_ALL_MEDICAL_STUDIES_GQL",
    "DELETE_ALL_MEDICAL_TESTS_GQL",
    "DELETE_ALL_MEDICAL_THERAPIES_GQL",
    "DELETE_ALL_ORGANIZATIONS_GQL",
    "DELETE_ALL_PERSONS_GQL",
    "DELETE_ALL_PLACES_GQL",
    "DELETE_ALL_PRODUCTS_GQL",
    "DELETE_ALL_REPOS_GQL",
    "DELETE_ALL_SOFTWARES_GQL",
    "DELETE_ALL_SPECIFICATIONS_GQL",
    "DELETE_ALL_WORKFLOWS_GQL",
    "DELETE_CATEGORIES_GQL",
    "DELETE_CATEGORY_GQL",
    "DELETE_COLLECTIONS_GQL",
    "DELETE_COLLECTION_GQL",
    "DELETE_CONTENTS_GQL",
    "DELETE_CONTENT_GQL",
    "DELETE_CONVERSATIONS_GQL",
    "DELETE_CONVERSATION_GQL",
    "DELETE_EVENTS_GQL",
    "DELETE_EVENT_GQL",
    "DELETE_FEEDS_GQL",
    "DELETE_FEED_GQL",
    "DELETE_LABELS_GQL",
    "DELETE_LABEL_GQL",
    "DELETE_MEDICAL_CONDITIONS_GQL",
    "DELETE_MEDICAL_CONDITION_GQL",
    "DELETE_MEDICAL_CONTRAINDICATIONS_GQL",
    "DELETE_MEDICAL_CONTRAINDICATION_GQL",
    "DELETE_MEDICAL_DEVICES_GQL",
    "DELETE_MEDICAL_DEVICE_GQL",
    "DELETE_MEDICAL_DRUGS_GQL",
    "DELETE_MEDICAL_DRUG_CLASSES_GQL",
    "DELETE_MEDICAL_DRUG_CLASS_GQL",
    "DELETE_MEDICAL_DRUG_GQL",
    "DELETE_MEDICAL_GUIDELINES_GQL",
    "DELETE_MEDICAL_GUIDELINE_GQL",
    "DELETE_MEDICAL_INDICATIONS_GQL",
    "DELETE_MEDICAL_INDICATION_GQL",
    "DELETE_MEDICAL_PROCEDURES_GQL",
    "DELETE_MEDICAL_PROCEDURE_GQL",
    "DELETE_MEDICAL_STUDIES_GQL",
    "DELETE_MEDICAL_STUDY_GQL",
    "DELETE_MEDICAL_TESTS_GQL",
    "DELETE_MEDICAL_TEST_GQL",
    "DELETE_MEDICAL_THERAPIES_GQL",
    "DELETE_MEDICAL_THERAPY_GQL",
    "DELETE_OBSERVATION_GQL",
    "DELETE_ORGANIZATIONS_GQL",
    "DELETE_ORGANIZATION_GQL",
    "DELETE_PERSONS_GQL",
    "DELETE_PERSON_GQL",
    "DELETE_PLACES_GQL",
    "DELETE_PLACE_GQL",
    "DELETE_PRODUCTS_GQL",
    "DELETE_PRODUCT_GQL",
    "DELETE_REPOS_GQL",
    "DELETE_REPO_GQL",
    "DELETE_SOFTWARES_GQL",
    "DELETE_SOFTWARE_GQL",
    "DELETE_SPECIFICATIONS_GQL",
    "DELETE_SPECIFICATION_GQL",
    "DELETE_USER_GQL",
    "DELETE_WORKFLOWS_GQL",
    "DELETE_WORKFLOW_GQL",
    "DESCRIBE_ENCODED_IMAGE_GQL",
    "DESCRIBE_IMAGE_GQL",
    "DISABLE_ALERT_GQL",
    "DISABLE_FEED_GQL",
    "DISABLE_USER_GQL",
    "ENABLE_ALERT_GQL",
    "ENABLE_FEED_GQL",
    "ENABLE_USER_GQL",
    "EXTRACT_CONTENTS_GQL",
    "EXTRACT_TEXT_GQL",
    "FEED_EXISTS_GQL",
    "FORMAT_CONVERSATION_GQL",
    "GET_ALERT_GQL",
    "GET_CATEGORY_GQL",
    "GET_COLLECTION_GQL",
    "GET_CONTENT_GQL",
    "GET_CONVERSATION_GQL",
    "GET_EVENT_GQL",
    "GET_FEED_GQL",
    "GET_LABEL_GQL",
    "GET_MEDICAL_CONDITION_GQL",
    "GET_MEDICAL_CONTRAINDICATION_GQL",
    "GET_MEDICAL_DEVICE_GQL",
    "GET_MEDICAL_DRUG_CLASS_GQL",
    "GET_MEDICAL_DRUG_GQL",
    "GET_MEDICAL_GUIDELINE_GQL",
    "GET_MEDICAL_INDICATION_GQL",
    "GET_MEDICAL_PROCEDURE_GQL",
    "GET_MEDICAL_STUDY_GQL",
    "GET_MEDICAL_TEST_GQL",
    "GET_MEDICAL_THERAPY_GQL",
    "GET_ORGANIZATION_GQL",
    "GET_PERSON_GQL",
    "GET_PLACE_GQL",
    "GET_PRODUCT_GQL",
    "GET_PROJECT_GQL",
    "GET_REPO_GQL",
    "GET_SHARE_POINT_CONSENT_URI_GQL",
    "GET_SOFTWARE_GQL",
    "GET_SPECIFICATION_GQL",
    "GET_USER_GQL",
    "GET_WORKFLOW_GQL",
    "INGEST_BATCH_GQL",
    "INGEST_ENCODED_FILE_GQL",
    "INGEST_MEMORY_GQL",
    "INGEST_TEXT_BATCH_GQL",
    "INGEST_TEXT_GQL",
    "INGEST_URI_GQL",
    "IS_CONTENT_DONE_GQL",
    "IS_FEED_DONE_GQL",
    "LOOKUP_CREDITS_GQL",
    "LOOKUP_USAGE_GQL",
    "MAP_WEB_GQL",
    "PROMPT_CONVERSATION_GQL",
    "PROMPT_GQL",
    "PROMPT_SPECIFICATIONS_GQL",
    "PUBLISH_CONTENTS_GQL",
    "PUBLISH_CONVERSATION_GQL",
    "PUBLISH_TEXT_GQL",
    "QUERY_ALERTS_GQL",
    "QUERY_CATEGORIES_GQL",
    "QUERY_COLLECTIONS_GQL",
    "QUERY_CONTENTS_FACETS_GQL",
    "QUERY_CONTENTS_GQL",
    "QUERY_CONTENTS_GRAPH_GQL",
    "QUERY_CONVERSATIONS_GQL",
    "QUERY_CREDITS_GQL",
    "QUERY_EVENTS_GQL",
    "QUERY_FEEDS_GQL",
    "QUERY_LABELS_GQL",
    "QUERY_LINEAR_PROJECTS_GQL",
    "QUERY_MEDICAL_CONDITIONS_GQL",
    "QUERY_MEDICAL_CONTRAINDICATIONS_GQL",
    "QUERY_MEDICAL_DEVICES_GQL",
    "QUERY_MEDICAL_DRUGS_GQL",
    "QUERY_MEDICAL_DRUG_CLASSES_GQL",
    "QUERY_MEDICAL_GUIDELINES_GQL",
    "QUERY_MEDICAL_INDICATIONS_GQL",
    "QUERY_MEDICAL_PROCEDURES_GQL",
    "QUERY_MEDICAL_STUDIES_GQL",
    "QUERY_MEDICAL_TESTS_GQL",
    "QUERY_MEDICAL_THERAPIES_GQL",
    "QUERY_MICROSOFT_TEAMS_CHANNELS_GQL",
    "QUERY_MICROSOFT_TEAMS_TEAMS_GQL",
    "QUERY_MODELS_GQL",
    "QUERY_NOTION_DATABASES_GQL",
    "QUERY_NOTION_PAGES_GQL",
    "QUERY_ONE_DRIVE_FOLDERS_GQL",
    "QUERY_ORGANIZATIONS_GQL",
    "QUERY_PERSONS_GQL",
    "QUERY_PLACES_GQL",
    "QUERY_PRODUCTS_GQL",
    "QUERY_REPOS_GQL",
    "QUERY_SHARE_POINT_FOLDERS_GQL",
    "QUERY_SHARE_POINT_LIBRARIES_GQL",
    "QUERY_SLACK_CHANNELS_GQL",
    "QUERY_SOFTWARES_GQL",
    "QUERY_SPECIFICATIONS_GQL",
    "QUERY_TOKENS_GQL",
    "QUERY_USAGE_GQL",
    "QUERY_USERS_GQL",
    "QUERY_WORKFLOWS_GQL",
    "REMOVE_CONTENTS_FROM_COLLECTION_GQL",
    "RETRIEVE_SOURCES_GQL",
    "REVISE_CONTENT_GQL",
    "REVISE_ENCODED_IMAGE_GQL",
    "REVISE_IMAGE_GQL",
    "REVISE_TEXT_GQL",
    "SCREENSHOT_PAGE_GQL",
    "SEARCH_WEB_GQL",
    "SEND_NOTIFICATION_GQL",
    "SPECIFICATION_EXISTS_GQL",
    "SUGGEST_CONVERSATION_GQL",
    "SUMMARIZE_CONTENTS_GQL",
    "SUMMARIZE_TEXT_GQL",
    "UPDATE_ALERT_GQL",
    "UPDATE_CATEGORY_GQL",
    "UPDATE_COLLECTION_GQL",
    "UPDATE_CONTENT_GQL",
    "UPDATE_CONVERSATION_GQL",
    "UPDATE_EVENT_GQL",
    "UPDATE_FEED_GQL",
    "UPDATE_LABEL_GQL",
    "UPDATE_MEDICAL_CONDITION_GQL",
    "UPDATE_MEDICAL_CONTRAINDICATION_GQL",
    "UPDATE_MEDICAL_DEVICE_GQL",
    "UPDATE_MEDICAL_DRUG_CLASS_GQL",
    "UPDATE_MEDICAL_DRUG_GQL",
    "UPDATE_MEDICAL_GUIDELINE_GQL",
    "UPDATE_MEDICAL_INDICATION_GQL",
    "UPDATE_MEDICAL_PROCEDURE_GQL",
    "UPDATE_MEDICAL_STUDY_GQL",
    "UPDATE_MEDICAL_TEST_GQL",
    "UPDATE_MEDICAL_THERAPY_GQL",
    "UPDATE_OBSERVATION_GQL",
    "UPDATE_ORGANIZATION_GQL",
    "UPDATE_PERSON_GQL",
    "UPDATE_PLACE_GQL",
    "UPDATE_PRODUCT_GQL",
    "UPDATE_PROJECT_GQL",
    "UPDATE_REPO_GQL",
    "UPDATE_SOFTWARE_GQL",
    "UPDATE_SPECIFICATION_GQL",
    "UPDATE_USER_GQL",
    "UPDATE_WORKFLOW_GQL",
    "UPSERT_CATEGORY_GQL",
    "UPSERT_LABEL_GQL",
    "UPSERT_SPECIFICATION_GQL",
    "UPSERT_WORKFLOW_GQL",
    "WORKFLOW_EXISTS_GQL",
]

COUNT_ALERTS_GQL = """
query CountAlerts($filter: AlertFilter, $correlationId: String) {
  countAlerts(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_ALERT_GQL = """
mutation CreateAlert($alert: AlertInput!, $correlationId: String) {
  createAlert(alert: $alert, correlationId: $correlationId) {
    id
    name
    state
    type
  }
}
"""

DELETE_ALERT_GQL = """
mutation DeleteAlert($id: ID!) {
  deleteAlert(id: $id) {
    id
    state
  }
}
"""

DELETE_ALERTS_GQL = """
mutation DeleteAlerts($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteAlerts(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

DELETE_ALL_ALERTS_GQL = """
mutation DeleteAllAlerts($filter: AlertFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllAlerts(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DISABLE_ALERT_GQL = """
mutation DisableAlert($id: ID!) {
  disableAlert(id: $id) {
    id
    state
  }
}
"""

ENABLE_ALERT_GQL = """
mutation EnableAlert($id: ID!) {
  enableAlert(id: $id) {
    id
    state
  }
}
"""

GET_ALERT_GQL = """
query GetAlert($id: ID!, $correlationId: String) {
  alert(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    correlationId
    type
    summaryPrompt
    publishPrompt
    filter {
      dateRange {
        from
        to
      }
      inLast
      creationDateRange {
        from
        to
      }
      createdInLast
      types
      fileTypes
      formats
      fileExtensions
      similarContents {
        id
      }
      contents {
        id
      }
      feeds {
        id
      }
      workflows {
        id
      }
      collections {
        id
      }
      users {
        id
      }
      observations {
        type
        observable {
          id
        }
        states
      }
      or {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
      and {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
    }
    integration {
      type
      uri
      slack {
        token
        channel
      }
      email {
        from
        subject
        to
      }
      twitter {
        consumerKey
        consumerSecret
        accessTokenKey
        accessTokenSecret
      }
    }
    publishing {
      type
      elevenLabs {
        model
        voice
      }
      openAIImage {
        model
        count
        seed {
          id
        }
      }
    }
    summarySpecification {
      id
    }
    publishSpecification {
      id
    }
    lastAlertDate
  }
}
"""

QUERY_ALERTS_GQL = """
query QueryAlerts($filter: AlertFilter, $correlationId: String) {
  alerts(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      correlationId
      type
      summaryPrompt
      publishPrompt
      filter {
        dateRange {
          from
          to
        }
        inLast
        creationDateRange {
          from
          to
        }
        createdInLast
        types
        fileTypes
        formats
        fileExtensions
        similarContents {
          id
        }
        contents {
          id
        }
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
        or {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
        and {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
      }
      integration {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
      publishing {
        type
        elevenLabs {
          model
          voice
        }
        openAIImage {
          model
          count
          seed {
            id
          }
        }
      }
      summarySpecification {
        id
      }
      publishSpecification {
        id
      }
      lastAlertDate
    }
  }
}
"""

UPDATE_ALERT_GQL = """
mutation UpdateAlert($alert: AlertUpdateInput!) {
  updateAlert(alert: $alert) {
    id
    name
    state
    type
  }
}
"""

COUNT_CATEGORIES_GQL = """
query CountCategories($filter: CategoryFilter, $correlationId: String) {
  countCategories(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_CATEGORY_GQL = """
mutation CreateCategory($category: CategoryInput!) {
  createCategory(category: $category) {
    id
    name
  }
}
"""

DELETE_ALL_CATEGORIES_GQL = """
mutation DeleteAllCategories($filter: CategoryFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllCategories(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_CATEGORIES_GQL = """
mutation DeleteCategories($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteCategories(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

DELETE_CATEGORY_GQL = """
mutation DeleteCategory($id: ID!) {
  deleteCategory(id: $id) {
    id
    state
  }
}
"""

GET_CATEGORY_GQL = """
query GetCategory($id: ID!, $correlationId: String) {
  category(id: $id, correlationId: $correlationId) {
    id
    name
    description
    creationDate
    relevance
  }
}
"""

QUERY_CATEGORIES_GQL = """
query QueryCategories($filter: CategoryFilter, $correlationId: String) {
  categories(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      description
      creationDate
      relevance
    }
  }
}
"""

UPDATE_CATEGORY_GQL = """
mutation UpdateCategory($category: CategoryUpdateInput!) {
  updateCategory(category: $category) {
    id
    name
  }
}
"""

UPSERT_CATEGORY_GQL = """
mutation UpsertCategory($category: CategoryInput!) {
  upsertCategory(category: $category) {
    id
    name
  }
}
"""

ADD_CONTENTS_TO_COLLECTIONS_GQL = """
mutation AddContentsToCollections($contents: [EntityReferenceInput!]!, $collections: [EntityReferenceInput!]!) {
  addContentsToCollections(contents: $contents, collections: $collections) {
    id
    name
    state
    type
    contents {
      id
      name
    }
  }
}
"""

COUNT_COLLECTIONS_GQL = """
query CountCollections($filter: CollectionFilter, $correlationId: String) {
  countCollections(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_COLLECTION_GQL = """
mutation CreateCollection($collection: CollectionInput!) {
  createCollection(collection: $collection) {
    id
    name
    state
    type
  }
}
"""

DELETE_ALL_COLLECTIONS_GQL = """
mutation DeleteAllCollections($filter: CollectionFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllCollections(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_COLLECTION_GQL = """
mutation DeleteCollection($id: ID!) {
  deleteCollection(id: $id) {
    id
    state
  }
}
"""

DELETE_COLLECTIONS_GQL = """
mutation DeleteCollections($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteCollections(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_COLLECTION_GQL = """
query GetCollection($id: ID!, $correlationId: String) {
  collection(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    type
    contents {
      id
      name
    }
  }
}
"""

QUERY_COLLECTIONS_GQL = """
query QueryCollections($filter: CollectionFilter, $correlationId: String) {
  collections(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      type
      contents {
        id
        name
      }
    }
  }
}
"""

REMOVE_CONTENTS_FROM_COLLECTION_GQL = """
mutation RemoveContentsFromCollection($contents: [EntityReferenceInput!]!, $collection: EntityReferenceInput!) {
  removeContentsFromCollection(contents: $contents, collection: $collection) {
    id
    name
    state
    type
    contents {
      id
      name
    }
  }
}
"""

UPDATE_COLLECTION_GQL = """
mutation UpdateCollection($collection: CollectionUpdateInput!) {
  updateCollection(collection: $collection) {
    id
    name
    state
    type
  }
}
"""

COUNT_CONTENTS_GQL = """
query CountContents($filter: ContentFilter, $correlationId: String) {
  countContents(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

DELETE_ALL_CONTENTS_GQL = """
mutation DeleteAllContents($filter: ContentFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllContents(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_CONTENT_GQL = """
mutation DeleteContent($id: ID!) {
  deleteContent(id: $id) {
    id
    state
  }
}
"""

DELETE_CONTENTS_GQL = """
mutation DeleteContents($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteContents(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

DESCRIBE_ENCODED_IMAGE_GQL = """
mutation DescribeEncodedImage($prompt: String!, $mimeType: String!, $data: String!, $specification: EntityReferenceInput, $correlationId: String) {
  describeEncodedImage(
    prompt: $prompt
    mimeType: $mimeType
    data: $data
    specification: $specification
    correlationId: $correlationId
  ) {
    role
    author
    message
    citations {
      content {
        id
        name
        state
        originalDate
        identifier
        uri
        type
        fileType
        mimeType
        format
        formatName
        fileExtension
        fileName
        fileSize
        masterUri
        imageUri
        textUri
        audioUri
        transcriptUri
        summary
        customSummary
        keywords
        bullets
        headlines
        posts
        chapters
        questions
        video {
          width
          height
          duration
          make
          model
          software
          title
          description
          keywords
          author
        }
        audio {
          keywords
          author
          series
          episode
          episodeType
          season
          publisher
          copyright
          genre
          title
          description
          bitrate
          channels
          sampleRate
          bitsPerSample
          duration
        }
        image {
          width
          height
          resolutionX
          resolutionY
          bitsPerComponent
          components
          projectionType
          orientation
          description
          make
          model
          software
          lens
          focalLength
          exposureTime
          fNumber
          iso
          heading
          pitch
        }
        document {
          title
          subject
          summary
          author
          publisher
          description
          keywords
          pageCount
          worksheetCount
          slideCount
          wordCount
          lineCount
          paragraphCount
          isEncrypted
          hasDigitalSignature
        }
      }
      index
      text
      startTime
      endTime
      pageNumber
      frameNumber
    }
    toolCalls {
      id
      name
      arguments
    }
    tokens
    throughput
    completionTime
    timestamp
    modelService
    model
    data
    mimeType
    toolCallId
    toolCallResponse
  }
}
"""

DESCRIBE_IMAGE_GQL = """
mutation DescribeImage($prompt: String!, $uri: URL!, $specification: EntityReferenceInput, $correlationId: String) {
  describeImage(
    prompt: $prompt
    uri: $uri
    specification: $specification
    correlationId: $correlationId
  ) {
    role
    author
    message
    citations {
      content {
        id
        name
        state
        originalDate
        identifier
        uri
        type
        fileType
        mimeType
        format
        formatName
        fileExtension
        fileName
        fileSize
        masterUri
        imageUri
        textUri
        audioUri
        transcriptUri
        summary
        customSummary
        keywords
        bullets
        headlines
        posts
        chapters
        questions
        video {
          width
          height
          duration
          make
          model
          software
          title
          description
          keywords
          author
        }
        audio {
          keywords
          author
          series
          episode
          episodeType
          season
          publisher
          copyright
          genre
          title
          description
          bitrate
          channels
          sampleRate
          bitsPerSample
          duration
        }
        image {
          width
          height
          resolutionX
          resolutionY
          bitsPerComponent
          components
          projectionType
          orientation
          description
          make
          model
          software
          lens
          focalLength
          exposureTime
          fNumber
          iso
          heading
          pitch
        }
        document {
          title
          subject
          summary
          author
          publisher
          description
          keywords
          pageCount
          worksheetCount
          slideCount
          wordCount
          lineCount
          paragraphCount
          isEncrypted
          hasDigitalSignature
        }
      }
      index
      text
      startTime
      endTime
      pageNumber
      frameNumber
    }
    toolCalls {
      id
      name
      arguments
    }
    tokens
    throughput
    completionTime
    timestamp
    modelService
    model
    data
    mimeType
    toolCallId
    toolCallResponse
  }
}
"""

EXTRACT_CONTENTS_GQL = """
mutation ExtractContents($prompt: String!, $filter: ContentFilter, $specification: EntityReferenceInput, $tools: [ToolDefinitionInput!]!, $correlationId: String) {
  extractContents(
    prompt: $prompt
    filter: $filter
    specification: $specification
    tools: $tools
    correlationId: $correlationId
  ) {
    specification {
      id
    }
    content {
      id
    }
    name
    value
    startTime
    endTime
    pageNumber
    error
  }
}
"""

EXTRACT_TEXT_GQL = """
mutation ExtractText($prompt: String!, $text: String!, $textType: TextTypes, $specification: EntityReferenceInput, $tools: [ToolDefinitionInput!]!, $correlationId: String) {
  extractText(
    prompt: $prompt
    text: $text
    textType: $textType
    specification: $specification
    tools: $tools
    correlationId: $correlationId
  ) {
    specification {
      id
    }
    content {
      id
    }
    name
    value
    startTime
    endTime
    pageNumber
    error
  }
}
"""

GET_CONTENT_GQL = """
query GetContent($id: ID!, $correlationId: String) {
  content(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    owner {
      id
    }
    state
    originalDate
    finishedDate
    workflowDuration
    uri
    description
    identifier
    markdown
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
    location {
      latitude
      longitude
    }
    c4id
    type
    fileType
    mimeType
    format
    formatName
    fileName
    fileSize
    masterUri
    imageUri
    textUri
    audioUri
    transcriptUri
    summary
    customSummary
    keywords
    bullets
    headlines
    posts
    chapters
    questions
    video {
      width
      height
      duration
      make
      model
      software
      title
      description
      keywords
      author
    }
    audio {
      keywords
      author
      series
      episode
      episodeType
      season
      publisher
      copyright
      genre
      title
      description
      bitrate
      channels
      sampleRate
      bitsPerSample
      duration
    }
    image {
      width
      height
      resolutionX
      resolutionY
      bitsPerComponent
      components
      projectionType
      orientation
      description
      make
      model
      software
      lens
      focalLength
      exposureTime
      fNumber
      iso
      heading
      pitch
    }
    document {
      title
      subject
      summary
      author
      publisher
      description
      keywords
      pageCount
      worksheetCount
      slideCount
      wordCount
      lineCount
      paragraphCount
      isEncrypted
      hasDigitalSignature
    }
    email {
      identifier
      threadIdentifier
      subject
      labels
      sensitivity
      priority
      importance
      from {
        name
        email
        givenName
        familyName
      }
      to {
        name
        email
        givenName
        familyName
      }
      cc {
        name
        email
        givenName
        familyName
      }
      bcc {
        name
        email
        givenName
        familyName
      }
    }
    issue {
      identifier
      title
      project
      team
      status
      priority
      type
      labels
    }
    package {
      fileCount
      folderCount
      isEncrypted
    }
    language {
      languages
    }
    parent {
      id
      name
    }
    children {
      id
      name
    }
    feed {
      id
      name
    }
    collections {
      id
      name
    }
    links {
      uri
      linkType
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
    workflow {
      id
      name
    }
    pages {
      index
      text
      relevance
      images {
        id
        mimeType
        data
        left
        right
        top
        bottom
      }
      chunks {
        index
        pageIndex
        rowIndex
        columnIndex
        confidence
        text
        role
        language
        relevance
      }
    }
    segments {
      startTime
      endTime
      text
      relevance
    }
    frames {
      index
      description
      text
      relevance
    }
    error
  }
}
"""

INGEST_BATCH_GQL = """
mutation IngestBatch($uris: [URL!]!, $workflow: EntityReferenceInput, $collections: [EntityReferenceInput!], $observations: [ObservationReferenceInput!], $correlationId: String) {
  ingestBatch(
    uris: $uris
    workflow: $workflow
    collections: $collections
    observations: $observations
    correlationId: $correlationId
  ) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}
"""

INGEST_ENCODED_FILE_GQL = """
mutation IngestEncodedFile($name: String!, $data: String!, $mimeType: String!, $id: ID, $isSynchronous: Boolean, $collections: [EntityReferenceInput!], $observations: [ObservationReferenceInput!], $workflow: EntityReferenceInput, $correlationId: String) {
  ingestEncodedFile(
    name: $name
    data: $data
    mimeType: $mimeType
    id: $id
    isSynchronous: $isSynchronous
    collections: $collections
    observations: $observations
    workflow: $workflow
    correlationId: $correlationId
  ) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}
"""

INGEST_MEMORY_GQL = """
mutation IngestMemory($text: String!, $name: String, $textType: TextTypes, $collections: [EntityReferenceInput!], $correlationId: String) {
  ingestMemory(
    name: $name
    text: $text
    textType: $textType
    collections: $collections
    correlationId: $correlationId
  ) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}
"""

INGEST_TEXT_GQL = """
mutation IngestText($text: String!, $name: String, $textType: TextTypes, $uri: URL, $id: ID, $isSynchronous: Boolean, $workflow: EntityReferenceInput, $collections: [EntityReferenceInput!], $observations: [ObservationReferenceInput!], $correlationId: String) {
  ingestText(
    name: $name
    text: $text
    textType: $textType
    uri: $uri
    id: $id
    isSynchronous: $isSynchronous
    workflow: $workflow
    collections: $collections
    observations: $observations
    correlationId: $correlationId
  ) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}
"""

INGEST_TEXT_BATCH_GQL = """
mutation IngestTextBatch($batch: [TextContentInput!]!, $textType: TextTypes, $workflow: EntityReferenceInput, $collections: [EntityReferenceInput!], $observations: [ObservationReferenceInput!], $correlationId: String) {
  ingestTextBatch(
    batch: $batch
    workflow: $workflow
    textType: $textType
    collections: $collections
    observations: $observations
    correlationId: $correlationId
  ) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}
"""

INGEST_URI_GQL = """
mutation IngestUri($name: String, $uri: URL!, $id: ID, $mimeType: String, $isSynchronous: Boolean, $workflow: EntityReferenceInput, $collections: [EntityReferenceInput!], $observations: [ObservationReferenceInput!], $correlationId: String) {
  ingestUri(
    name: $name
    uri: $uri
    id: $id
    mimeType: $mimeType
    workflow: $workflow
    collections: $collections
    observations: $observations
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}
"""

IS_CONTENT_DONE_GQL = """
query IsContentDone($id: ID!) {
  isContentDone(id: $id) {
    result
  }
}
"""

PUBLISH_CONTENTS_GQL = """
mutation PublishContents($summaryPrompt: String, $publishPrompt: String!, $connector: ContentPublishingConnectorInput!, $filter: ContentFilter, $includeDetails: Boolean, $isSynchronous: Boolean, $correlationId: String, $name: String, $summarySpecification: EntityReferenceInput, $publishSpecification: EntityReferenceInput, $workflow: EntityReferenceInput) {
  publishContents(
    summaryPrompt: $summaryPrompt
    publishPrompt: $publishPrompt
    connector: $connector
    filter: $filter
    includeDetails: $includeDetails
    isSynchronous: $isSynchronous
    correlationId: $correlationId
    name: $name
    summarySpecification: $summarySpecification
    publishSpecification: $publishSpecification
    workflow: $workflow
  ) {
    contents {
      id
      name
      state
      originalDate
      identifier
      markdown
      uri
      type
      fileType
      mimeType
      format
      formatName
      fileExtension
      fileName
      fileSize
      masterUri
      imageUri
      textUri
      audioUri
      transcriptUri
      summary
      customSummary
      keywords
      bullets
      headlines
      posts
      chapters
      questions
      video {
        width
        height
        duration
        make
        model
        software
        title
        description
        keywords
        author
      }
      audio {
        keywords
        author
        series
        episode
        episodeType
        season
        publisher
        copyright
        genre
        title
        description
        bitrate
        channels
        sampleRate
        bitsPerSample
        duration
      }
      image {
        width
        height
        resolutionX
        resolutionY
        bitsPerComponent
        components
        projectionType
        orientation
        description
        make
        model
        software
        lens
        focalLength
        exposureTime
        fNumber
        iso
        heading
        pitch
      }
      document {
        title
        subject
        summary
        author
        publisher
        description
        keywords
        pageCount
        worksheetCount
        slideCount
        wordCount
        lineCount
        paragraphCount
        isEncrypted
        hasDigitalSignature
      }
    }
    details {
      contents {
        id
      }
      summaries
      text
      textType
      summarySpecification
      publishSpecification
      summaryTime
      publishTime
    }
  }
}
"""

PUBLISH_TEXT_GQL = """
mutation PublishText($text: String!, $textType: TextTypes, $connector: ContentPublishingConnectorInput!, $isSynchronous: Boolean, $correlationId: String, $name: String, $workflow: EntityReferenceInput) {
  publishText(
    text: $text
    textType: $textType
    connector: $connector
    isSynchronous: $isSynchronous
    correlationId: $correlationId
    name: $name
    workflow: $workflow
  ) {
    contents {
      id
      name
      state
      originalDate
      identifier
      markdown
      uri
      type
      fileType
      mimeType
      format
      formatName
      fileExtension
      fileName
      fileSize
      masterUri
      imageUri
      textUri
      audioUri
      transcriptUri
      summary
      customSummary
      keywords
      bullets
      headlines
      posts
      chapters
      questions
      video {
        width
        height
        duration
        make
        model
        software
        title
        description
        keywords
        author
      }
      audio {
        keywords
        author
        series
        episode
        episodeType
        season
        publisher
        copyright
        genre
        title
        description
        bitrate
        channels
        sampleRate
        bitsPerSample
        duration
      }
      image {
        width
        height
        resolutionX
        resolutionY
        bitsPerComponent
        components
        projectionType
        orientation
        description
        make
        model
        software
        lens
        focalLength
        exposureTime
        fNumber
        iso
        heading
        pitch
      }
      document {
        title
        subject
        summary
        author
        publisher
        description
        keywords
        pageCount
        worksheetCount
        slideCount
        wordCount
        lineCount
        paragraphCount
        isEncrypted
        hasDigitalSignature
      }
    }
    details {
      contents {
        id
      }
      summaries
      text
      textType
      summarySpecification
      publishSpecification
      summaryTime
      publishTime
    }
  }
}
"""

QUERY_CONTENTS_GQL = """
query QueryContents($filter: ContentFilter, $correlationId: String) {
  contents(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      originalDate
      finishedDate
      workflowDuration
      uri
      description
      identifier
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
      location {
        latitude
        longitude
      }
      type
      fileType
      mimeType
      fileName
      fileSize
      masterUri
      imageUri
      textUri
      audioUri
      transcriptUri
      summary
      customSummary
      keywords
      bullets
      headlines
      posts
      chapters
      questions
      video {
        width
        height
        duration
        make
        model
        software
        title
        description
        keywords
        author
      }
      audio {
        keywords
        author
        series
        episode
        episodeType
        season
        publisher
        copyright
        genre
        title
        description
        bitrate
        channels
        sampleRate
        bitsPerSample
        duration
      }
      image {
        width
        height
        resolutionX
        resolutionY
        bitsPerComponent
        components
        projectionType
        orientation
        description
        make
        model
        software
        lens
        focalLength
        exposureTime
        fNumber
        iso
        heading
        pitch
      }
      document {
        title
        subject
        summary
        author
        publisher
        description
        keywords
        pageCount
        worksheetCount
        slideCount
        wordCount
        lineCount
        paragraphCount
        isEncrypted
        hasDigitalSignature
      }
      email {
        identifier
        threadIdentifier
        subject
        labels
        sensitivity
        priority
        importance
        from {
          name
          email
          givenName
          familyName
        }
        to {
          name
          email
          givenName
          familyName
        }
        cc {
          name
          email
          givenName
          familyName
        }
        bcc {
          name
          email
          givenName
          familyName
        }
      }
      issue {
        identifier
        title
        project
        team
        status
        priority
        type
        labels
      }
      package {
        fileCount
        folderCount
        isEncrypted
      }
      language {
        languages
      }
      feed {
        id
        name
      }
      collections {
        id
        name
      }
      links {
        uri
        linkType
      }
      observations {
        id
        type
        observable {
          id
          name
        }
        related {
          id
          name
        }
        relatedType
        relation
        occurrences {
          type
          confidence
          startTime
          endTime
          pageIndex
          boundingBox {
            left
            top
            width
            height
          }
        }
        state
      }
      workflow {
        id
        name
      }
      pages {
        index
        text
        relevance
        images {
          id
          mimeType
          data
          left
          right
          top
          bottom
        }
        chunks {
          index
          pageIndex
          rowIndex
          columnIndex
          confidence
          text
          role
          language
          relevance
        }
      }
      segments {
        startTime
        endTime
        text
        relevance
      }
      frames {
        index
        description
        text
        relevance
      }
      error
    }
  }
}
"""

QUERY_CONTENTS_FACETS_GQL = """
query QueryContentsFacets($filter: ContentFilter, $facets: [ContentFacetInput!], $correlationId: String) {
  contents(filter: $filter, facets: $facets, correlationId: $correlationId) {
    facets {
      facet
      count
      type
      value
      range {
        from
        to
      }
      observable {
        type
        observable {
          id
          name
        }
      }
    }
  }
}
"""

QUERY_CONTENTS_GRAPH_GQL = """
query QueryContentsGraph($filter: ContentFilter, $graph: ContentGraphInput, $correlationId: String) {
  contents(filter: $filter, graph: $graph, correlationId: $correlationId) {
    graph {
      nodes {
        id
        name
        type
        metadata
      }
      edges {
        from
        to
        relation
      }
    }
  }
}
"""

SCREENSHOT_PAGE_GQL = """
mutation ScreenshotPage($uri: URL!, $maximumHeight: Int, $isSynchronous: Boolean, $workflow: EntityReferenceInput, $collections: [EntityReferenceInput!], $correlationId: String) {
  screenshotPage(
    uri: $uri
    maximumHeight: $maximumHeight
    workflow: $workflow
    collections: $collections
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}
"""

SUMMARIZE_CONTENTS_GQL = """
mutation SummarizeContents($summarizations: [SummarizationStrategyInput!]!, $filter: ContentFilter, $correlationId: String) {
  summarizeContents(
    summarizations: $summarizations
    filter: $filter
    correlationId: $correlationId
  ) {
    specification {
      id
    }
    content {
      id
    }
    type
    items {
      text
      tokens
      summarizationTime
    }
    error
  }
}
"""

SUMMARIZE_TEXT_GQL = """
mutation SummarizeText($summarization: SummarizationStrategyInput!, $text: String!, $textType: TextTypes, $correlationId: String) {
  summarizeText(
    summarization: $summarization
    text: $text
    textType: $textType
    correlationId: $correlationId
  ) {
    specification {
      id
    }
    content {
      id
    }
    type
    items {
      text
      tokens
      summarizationTime
    }
    error
  }
}
"""

UPDATE_CONTENT_GQL = """
mutation UpdateContent($content: ContentUpdateInput!) {
  updateContent(content: $content) {
    id
    name
    state
    type
    fileType
    mimeType
    uri
    collections {
      id
      name
    }
    observations {
      id
      type
      observable {
        id
        name
      }
      related {
        id
        name
      }
      relatedType
      relation
      occurrences {
        type
        confidence
        startTime
        endTime
        pageIndex
        boundingBox {
          left
          top
          width
          height
        }
      }
      state
    }
  }
}
"""

ASK_GRAPHLIT_GQL = """
mutation AskGraphlit($prompt: String!, $type: SdkTypes, $id: ID, $specification: EntityReferenceInput, $correlationId: String) {
  askGraphlit(
    prompt: $prompt
    type: $type
    id: $id
    specification: $specification
    correlationId: $correlationId
  ) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
  }
}
"""

CLEAR_CONVERSATION_GQL = """
mutation ClearConversation($id: ID!) {
  clearConversation(id: $id) {
    id
    name
    state
    type
  }
}
"""

CLOSE_CONVERSATION_GQL = """
mutation CloseConversation($id: ID!) {
  closeConversation(id: $id) {
    id
    name
    state
    type
  }
}
"""

COMPLETE_CONVERSATION_GQL = """
mutation CompleteConversation($completion: String!, $id: ID!, $correlationId: String) {
  completeConversation(
    completion: $completion
    id: $id
    correlationId: $correlationId
  ) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
    facets {
      type
      value
      range {
        from
        to
      }
      count
      facet
      observable {
        type
        observable {
          id
          name
        }
      }
    }
    graph {
      nodes {
        id
        name
        type
        metadata
      }
      edges {
        from
        to
        relation
      }
    }
    details {
      modelService
      model
      supportsToolCalling
      sourceCount
      observableCount
      toolCount
      renderedSourceCount
      renderedObservableCount
      renderedToolCount
      rankedSourceCount
      rankedObservableCount
      rankedToolCount
      tokenLimit
      completionTokenLimit
      sources
      formattedSources
      formattedObservables
      formattedInstructions
      formattedTools
      specification
      messages {
        role
        author
        message
        citations {
          content {
            id
            name
            state
            originalDate
            identifier
            uri
            type
            fileType
            mimeType
            format
            formatName
            fileExtension
            fileName
            fileSize
            masterUri
            imageUri
            textUri
            audioUri
            transcriptUri
            summary
            customSummary
            keywords
            bullets
            headlines
            posts
            chapters
            questions
            video {
              width
              height
              duration
              make
              model
              software
              title
              description
              keywords
              author
            }
            audio {
              keywords
              author
              series
              episode
              episodeType
              season
              publisher
              copyright
              genre
              title
              description
              bitrate
              channels
              sampleRate
              bitsPerSample
              duration
            }
            image {
              width
              height
              resolutionX
              resolutionY
              bitsPerComponent
              components
              projectionType
              orientation
              description
              make
              model
              software
              lens
              focalLength
              exposureTime
              fNumber
              iso
              heading
              pitch
            }
            document {
              title
              subject
              summary
              author
              publisher
              description
              keywords
              pageCount
              worksheetCount
              slideCount
              wordCount
              lineCount
              paragraphCount
              isEncrypted
              hasDigitalSignature
            }
          }
          index
          text
          startTime
          endTime
          pageNumber
          frameNumber
        }
        toolCalls {
          id
          name
          arguments
        }
        tokens
        throughput
        completionTime
        timestamp
        modelService
        model
        data
        mimeType
        toolCallId
        toolCallResponse
      }
    }
  }
}
"""

CONTINUE_CONVERSATION_GQL = """
mutation ContinueConversation($id: ID!, $responses: [ConversationToolResponseInput!]!, $correlationId: String) {
  continueConversation(
    id: $id
    responses: $responses
    correlationId: $correlationId
  ) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
    facets {
      type
      value
      range {
        from
        to
      }
      count
      facet
      observable {
        type
        observable {
          id
          name
        }
      }
    }
    graph {
      nodes {
        id
        name
        type
        metadata
      }
      edges {
        from
        to
        relation
      }
    }
    details {
      modelService
      model
      supportsToolCalling
      sourceCount
      observableCount
      toolCount
      renderedSourceCount
      renderedObservableCount
      renderedToolCount
      rankedSourceCount
      rankedObservableCount
      rankedToolCount
      tokenLimit
      completionTokenLimit
      sources
      formattedSources
      formattedObservables
      formattedInstructions
      formattedTools
      specification
      messages {
        role
        author
        message
        citations {
          content {
            id
            name
            state
            originalDate
            identifier
            uri
            type
            fileType
            mimeType
            format
            formatName
            fileExtension
            fileName
            fileSize
            masterUri
            imageUri
            textUri
            audioUri
            transcriptUri
            summary
            customSummary
            keywords
            bullets
            headlines
            posts
            chapters
            questions
            video {
              width
              height
              duration
              make
              model
              software
              title
              description
              keywords
              author
            }
            audio {
              keywords
              author
              series
              episode
              episodeType
              season
              publisher
              copyright
              genre
              title
              description
              bitrate
              channels
              sampleRate
              bitsPerSample
              duration
            }
            image {
              width
              height
              resolutionX
              resolutionY
              bitsPerComponent
              components
              projectionType
              orientation
              description
              make
              model
              software
              lens
              focalLength
              exposureTime
              fNumber
              iso
              heading
              pitch
            }
            document {
              title
              subject
              summary
              author
              publisher
              description
              keywords
              pageCount
              worksheetCount
              slideCount
              wordCount
              lineCount
              paragraphCount
              isEncrypted
              hasDigitalSignature
            }
          }
          index
          text
          startTime
          endTime
          pageNumber
          frameNumber
        }
        toolCalls {
          id
          name
          arguments
        }
        tokens
        throughput
        completionTime
        timestamp
        modelService
        model
        data
        mimeType
        toolCallId
        toolCallResponse
      }
    }
  }
}
"""

COUNT_CONVERSATIONS_GQL = """
query CountConversations($filter: ConversationFilter, $correlationId: String) {
  countConversations(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_CONVERSATION_GQL = """
mutation CreateConversation($conversation: ConversationInput!, $correlationId: String) {
  createConversation(conversation: $conversation, correlationId: $correlationId) {
    id
    name
    state
    type
  }
}
"""

DELETE_ALL_CONVERSATIONS_GQL = """
mutation DeleteAllConversations($filter: ConversationFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllConversations(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_CONVERSATION_GQL = """
mutation DeleteConversation($id: ID!) {
  deleteConversation(id: $id) {
    id
    state
  }
}
"""

DELETE_CONVERSATIONS_GQL = """
mutation DeleteConversations($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteConversations(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

FORMAT_CONVERSATION_GQL = """
mutation FormatConversation($prompt: String!, $id: ID, $specification: EntityReferenceInput, $includeDetails: Boolean, $correlationId: String) {
  formatConversation(
    prompt: $prompt
    id: $id
    specification: $specification
    includeDetails: $includeDetails
    correlationId: $correlationId
  ) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
    facets {
      type
      value
      range {
        from
        to
      }
      count
      facet
      observable {
        type
        observable {
          id
          name
        }
      }
    }
    graph {
      nodes {
        id
        name
        type
        metadata
      }
      edges {
        from
        to
        relation
      }
    }
    details {
      modelService
      model
      supportsToolCalling
      sourceCount
      observableCount
      toolCount
      renderedSourceCount
      renderedObservableCount
      renderedToolCount
      rankedSourceCount
      rankedObservableCount
      rankedToolCount
      tokenLimit
      completionTokenLimit
      sources
      formattedSources
      formattedObservables
      formattedInstructions
      formattedTools
      specification
      messages {
        role
        author
        message
        citations {
          content {
            id
            name
            state
            originalDate
            identifier
            uri
            type
            fileType
            mimeType
            format
            formatName
            fileExtension
            fileName
            fileSize
            masterUri
            imageUri
            textUri
            audioUri
            transcriptUri
            summary
            customSummary
            keywords
            bullets
            headlines
            posts
            chapters
            questions
            video {
              width
              height
              duration
              make
              model
              software
              title
              description
              keywords
              author
            }
            audio {
              keywords
              author
              series
              episode
              episodeType
              season
              publisher
              copyright
              genre
              title
              description
              bitrate
              channels
              sampleRate
              bitsPerSample
              duration
            }
            image {
              width
              height
              resolutionX
              resolutionY
              bitsPerComponent
              components
              projectionType
              orientation
              description
              make
              model
              software
              lens
              focalLength
              exposureTime
              fNumber
              iso
              heading
              pitch
            }
            document {
              title
              subject
              summary
              author
              publisher
              description
              keywords
              pageCount
              worksheetCount
              slideCount
              wordCount
              lineCount
              paragraphCount
              isEncrypted
              hasDigitalSignature
            }
          }
          index
          text
          startTime
          endTime
          pageNumber
          frameNumber
        }
        toolCalls {
          id
          name
          arguments
        }
        tokens
        throughput
        completionTime
        timestamp
        modelService
        model
        data
        mimeType
        toolCallId
        toolCallResponse
      }
    }
  }
}
"""

GET_CONVERSATION_GQL = """
query GetConversation($id: ID!, $correlationId: String) {
  conversation(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    correlationId
    type
    messages {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    specification {
      id
      name
    }
    fallbacks {
      id
      name
    }
    filter {
      dateRange {
        from
        to
      }
      inLast
      creationDateRange {
        from
        to
      }
      createdInLast
      types
      fileTypes
      formats
      fileExtensions
      similarContents {
        id
      }
      contents {
        id
      }
      feeds {
        id
      }
      workflows {
        id
      }
      collections {
        id
      }
      users {
        id
      }
      observations {
        type
        observable {
          id
        }
        states
      }
      or {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
      and {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
    }
    augmentedFilter {
      dateRange {
        from
        to
      }
      inLast
      creationDateRange {
        from
        to
      }
      createdInLast
      types
      fileTypes
      formats
      fileExtensions
      similarContents {
        id
      }
      contents {
        id
      }
      feeds {
        id
      }
      workflows {
        id
      }
      collections {
        id
      }
      users {
        id
      }
      observations {
        type
        observable {
          id
        }
        states
      }
      or {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
      and {
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
      }
    }
  }
}
"""

PROMPT_GQL = """
mutation Prompt($prompt: String, $mimeType: String, $data: String, $specification: EntityReferenceInput, $messages: [ConversationMessageInput!], $correlationId: String) {
  prompt(
    prompt: $prompt
    mimeType: $mimeType
    data: $data
    specification: $specification
    messages: $messages
    correlationId: $correlationId
  ) {
    specification {
      id
    }
    messages {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    error
  }
}
"""

PROMPT_CONVERSATION_GQL = """
mutation PromptConversation($prompt: String!, $mimeType: String, $data: String, $id: ID, $specification: EntityReferenceInput, $tools: [ToolDefinitionInput!], $requireTool: Boolean, $includeDetails: Boolean, $correlationId: String) {
  promptConversation(
    prompt: $prompt
    id: $id
    mimeType: $mimeType
    data: $data
    specification: $specification
    tools: $tools
    requireTool: $requireTool
    includeDetails: $includeDetails
    correlationId: $correlationId
  ) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
    facets {
      type
      value
      range {
        from
        to
      }
      count
      facet
      observable {
        type
        observable {
          id
          name
        }
      }
    }
    graph {
      nodes {
        id
        name
        type
        metadata
      }
      edges {
        from
        to
        relation
      }
    }
    details {
      modelService
      model
      supportsToolCalling
      sourceCount
      observableCount
      toolCount
      renderedSourceCount
      renderedObservableCount
      renderedToolCount
      rankedSourceCount
      rankedObservableCount
      rankedToolCount
      tokenLimit
      completionTokenLimit
      sources
      formattedSources
      formattedObservables
      formattedInstructions
      formattedTools
      specification
      messages {
        role
        author
        message
        citations {
          content {
            id
            name
            state
            originalDate
            identifier
            uri
            type
            fileType
            mimeType
            format
            formatName
            fileExtension
            fileName
            fileSize
            masterUri
            imageUri
            textUri
            audioUri
            transcriptUri
            summary
            customSummary
            keywords
            bullets
            headlines
            posts
            chapters
            questions
            video {
              width
              height
              duration
              make
              model
              software
              title
              description
              keywords
              author
            }
            audio {
              keywords
              author
              series
              episode
              episodeType
              season
              publisher
              copyright
              genre
              title
              description
              bitrate
              channels
              sampleRate
              bitsPerSample
              duration
            }
            image {
              width
              height
              resolutionX
              resolutionY
              bitsPerComponent
              components
              projectionType
              orientation
              description
              make
              model
              software
              lens
              focalLength
              exposureTime
              fNumber
              iso
              heading
              pitch
            }
            document {
              title
              subject
              summary
              author
              publisher
              description
              keywords
              pageCount
              worksheetCount
              slideCount
              wordCount
              lineCount
              paragraphCount
              isEncrypted
              hasDigitalSignature
            }
          }
          index
          text
          startTime
          endTime
          pageNumber
          frameNumber
        }
        toolCalls {
          id
          name
          arguments
        }
        tokens
        throughput
        completionTime
        timestamp
        modelService
        model
        data
        mimeType
        toolCallId
        toolCallResponse
      }
    }
  }
}
"""

PUBLISH_CONVERSATION_GQL = """
mutation PublishConversation($id: ID!, $connector: ContentPublishingConnectorInput!, $name: String, $isSynchronous: Boolean, $workflow: EntityReferenceInput, $correlationId: String) {
  publishConversation(
    id: $id
    connector: $connector
    name: $name
    isSynchronous: $isSynchronous
    workflow: $workflow
    correlationId: $correlationId
  ) {
    contents {
      id
      name
      state
      originalDate
      identifier
      markdown
      uri
      type
      fileType
      mimeType
      format
      formatName
      fileExtension
      fileName
      fileSize
      masterUri
      imageUri
      textUri
      audioUri
      transcriptUri
      summary
      customSummary
      keywords
      bullets
      headlines
      posts
      chapters
      questions
      video {
        width
        height
        duration
        make
        model
        software
        title
        description
        keywords
        author
      }
      audio {
        keywords
        author
        series
        episode
        episodeType
        season
        publisher
        copyright
        genre
        title
        description
        bitrate
        channels
        sampleRate
        bitsPerSample
        duration
      }
      image {
        width
        height
        resolutionX
        resolutionY
        bitsPerComponent
        components
        projectionType
        orientation
        description
        make
        model
        software
        lens
        focalLength
        exposureTime
        fNumber
        iso
        heading
        pitch
      }
      document {
        title
        subject
        summary
        author
        publisher
        description
        keywords
        pageCount
        worksheetCount
        slideCount
        wordCount
        lineCount
        paragraphCount
        isEncrypted
        hasDigitalSignature
      }
    }
    details {
      contents {
        id
      }
      summaries
      text
      textType
      summarySpecification
      publishSpecification
      summaryTime
      publishTime
    }
  }
}
"""

QUERY_CONVERSATIONS_GQL = """
query QueryConversations($filter: ConversationFilter, $correlationId: String) {
  conversations(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      correlationId
      type
      messages {
        role
        author
        message
        citations {
          content {
            id
            name
            state
            originalDate
            identifier
            uri
            type
            fileType
            mimeType
            format
            formatName
            fileExtension
            fileName
            fileSize
            masterUri
            imageUri
            textUri
            audioUri
            transcriptUri
            summary
            customSummary
            keywords
            bullets
            headlines
            posts
            chapters
            questions
            video {
              width
              height
              duration
              make
              model
              software
              title
              description
              keywords
              author
            }
            audio {
              keywords
              author
              series
              episode
              episodeType
              season
              publisher
              copyright
              genre
              title
              description
              bitrate
              channels
              sampleRate
              bitsPerSample
              duration
            }
            image {
              width
              height
              resolutionX
              resolutionY
              bitsPerComponent
              components
              projectionType
              orientation
              description
              make
              model
              software
              lens
              focalLength
              exposureTime
              fNumber
              iso
              heading
              pitch
            }
            document {
              title
              subject
              summary
              author
              publisher
              description
              keywords
              pageCount
              worksheetCount
              slideCount
              wordCount
              lineCount
              paragraphCount
              isEncrypted
              hasDigitalSignature
            }
          }
          index
          text
          startTime
          endTime
          pageNumber
          frameNumber
        }
        toolCalls {
          id
          name
          arguments
        }
        tokens
        throughput
        completionTime
        timestamp
        modelService
        model
        data
        mimeType
        toolCallId
        toolCallResponse
      }
      specification {
        id
        name
      }
      fallbacks {
        id
        name
      }
      filter {
        dateRange {
          from
          to
        }
        inLast
        creationDateRange {
          from
          to
        }
        createdInLast
        types
        fileTypes
        formats
        fileExtensions
        similarContents {
          id
        }
        contents {
          id
        }
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
        or {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
        and {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
      }
      augmentedFilter {
        dateRange {
          from
          to
        }
        inLast
        creationDateRange {
          from
          to
        }
        createdInLast
        types
        fileTypes
        formats
        fileExtensions
        similarContents {
          id
        }
        contents {
          id
        }
        feeds {
          id
        }
        workflows {
          id
        }
        collections {
          id
        }
        users {
          id
        }
        observations {
          type
          observable {
            id
          }
          states
        }
        or {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
        and {
          feeds {
            id
          }
          workflows {
            id
          }
          collections {
            id
          }
          users {
            id
          }
          observations {
            type
            observable {
              id
            }
            states
          }
        }
      }
    }
  }
}
"""

RETRIEVE_SOURCES_GQL = """
mutation RetrieveSources($prompt: String!, $filter: ContentFilter, $augmentedFilter: ContentFilter, $retrievalStrategy: RetrievalStrategyInput, $rerankingStrategy: RerankingStrategyInput, $correlationId: String) {
  retrieveSources(
    prompt: $prompt
    filter: $filter
    augmentedFilter: $augmentedFilter
    retrievalStrategy: $retrievalStrategy
    rerankingStrategy: $rerankingStrategy
    correlationId: $correlationId
  ) {
    results {
      type
      content {
        id
      }
      text
      metadata
      relevance
      startTime
      endTime
      pageNumber
      frameNumber
    }
  }
}
"""

REVISE_CONTENT_GQL = """
mutation ReviseContent($prompt: String!, $content: EntityReferenceInput!, $id: ID, $specification: EntityReferenceInput, $correlationId: String) {
  reviseContent(
    prompt: $prompt
    content: $content
    id: $id
    specification: $specification
    correlationId: $correlationId
  ) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
  }
}
"""

REVISE_ENCODED_IMAGE_GQL = """
mutation ReviseEncodedImage($prompt: String!, $mimeType: String!, $data: String!, $id: ID, $specification: EntityReferenceInput, $correlationId: String) {
  reviseEncodedImage(
    prompt: $prompt
    mimeType: $mimeType
    data: $data
    id: $id
    specification: $specification
    correlationId: $correlationId
  ) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
  }
}
"""

REVISE_IMAGE_GQL = """
mutation ReviseImage($prompt: String!, $uri: URL!, $id: ID, $specification: EntityReferenceInput, $correlationId: String) {
  reviseImage(
    prompt: $prompt
    uri: $uri
    id: $id
    specification: $specification
    correlationId: $correlationId
  ) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
  }
}
"""

REVISE_TEXT_GQL = """
mutation ReviseText($prompt: String!, $text: String!, $id: ID, $specification: EntityReferenceInput, $correlationId: String) {
  reviseText(
    prompt: $prompt
    text: $text
    id: $id
    specification: $specification
    correlationId: $correlationId
  ) {
    conversation {
      id
    }
    message {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    messageCount
  }
}
"""

SUGGEST_CONVERSATION_GQL = """
mutation SuggestConversation($id: ID!, $count: Int, $prompt: String, $correlationId: String) {
  suggestConversation(
    id: $id
    count: $count
    prompt: $prompt
    correlationId: $correlationId
  ) {
    prompts
  }
}
"""

UPDATE_CONVERSATION_GQL = """
mutation UpdateConversation($conversation: ConversationUpdateInput!) {
  updateConversation(conversation: $conversation) {
    id
    name
    state
    type
  }
}
"""

COUNT_EVENTS_GQL = """
query CountEvents($filter: EventFilter, $correlationId: String) {
  countEvents(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_EVENT_GQL = """
mutation CreateEvent($event: EventInput!) {
  createEvent(event: $event) {
    id
    name
  }
}
"""

DELETE_ALL_EVENTS_GQL = """
mutation DeleteAllEvents($filter: EventFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllEvents(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_EVENT_GQL = """
mutation DeleteEvent($id: ID!) {
  deleteEvent(id: $id) {
    id
    state
  }
}
"""

DELETE_EVENTS_GQL = """
mutation DeleteEvents($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteEvents(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_EVENT_GQL = """
query GetEvent($id: ID!, $correlationId: String) {
  event(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
    startDate
    endDate
    availabilityStartDate
    availabilityEndDate
    price
    minPrice
    maxPrice
    priceCurrency
    isAccessibleForFree
    typicalAgeRange
  }
}
"""

QUERY_EVENTS_GQL = """
query QueryEvents($filter: EventFilter, $correlationId: String) {
  events(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
      startDate
      endDate
      availabilityStartDate
      availabilityEndDate
      price
      minPrice
      maxPrice
      priceCurrency
      isAccessibleForFree
      typicalAgeRange
    }
  }
}
"""

UPDATE_EVENT_GQL = """
mutation UpdateEvent($event: EventUpdateInput!) {
  updateEvent(event: $event) {
    id
    name
  }
}
"""

COUNT_FEEDS_GQL = """
query CountFeeds($filter: FeedFilter, $correlationId: String) {
  countFeeds(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_FEED_GQL = """
mutation CreateFeed($feed: FeedInput!, $correlationId: String) {
  createFeed(feed: $feed, correlationId: $correlationId) {
    id
    name
    state
    type
  }
}
"""

DELETE_ALL_FEEDS_GQL = """
mutation DeleteAllFeeds($filter: FeedFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllFeeds(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_FEED_GQL = """
mutation DeleteFeed($id: ID!) {
  deleteFeed(id: $id) {
    id
    state
  }
}
"""

DELETE_FEEDS_GQL = """
mutation DeleteFeeds($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteFeeds(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

DISABLE_FEED_GQL = """
mutation DisableFeed($id: ID!) {
  disableFeed(id: $id) {
    id
    state
  }
}
"""

ENABLE_FEED_GQL = """
mutation EnableFeed($id: ID!) {
  enableFeed(id: $id) {
    id
    state
  }
}
"""

FEED_EXISTS_GQL = """
query FeedExists($filter: FeedFilter, $correlationId: String) {
  feedExists(filter: $filter, correlationId: $correlationId) {
    result
  }
}
"""

GET_FEED_GQL = """
query GetFeed($id: ID!, $correlationId: String) {
  feed(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    correlationId
    type
    site {
      siteType
      type
      isRecursive
      s3 {
        accessKey
        secretAccessKey
        bucketName
        prefix
        region
      }
      azureBlob {
        storageAccessKey
        accountName
        containerName
        prefix
      }
      azureFile {
        storageAccessKey
        accountName
        shareName
        prefix
      }
      google {
        credentials
        containerName
        prefix
      }
      sharePoint {
        authenticationType
        accountName
        libraryId
        folderId
        tenantId
        clientId
        clientSecret
        refreshToken
      }
      oneDrive {
        folderId
        files
        clientId
        clientSecret
        refreshToken
      }
      googleDrive {
        authenticationType
        folderId
        files
        refreshToken
        clientId
        clientSecret
        serviceAccountJson
      }
      dropbox {
        path
        appKey
        appSecret
        refreshToken
        redirectUri
      }
      box {
        folderId
        clientId
        clientSecret
        refreshToken
        redirectUri
      }
      github {
        uri
        repositoryOwner
        repositoryName
        refreshToken
        personalAccessToken
      }
      readLimit
    }
    email {
      type
      includeAttachments
      google {
        type
        includeSpam
        excludeSentItems
        includeDeletedItems
        inboxOnly
        refreshToken
        clientId
        clientSecret
      }
      microsoft {
        type
        includeSpam
        excludeSentItems
        includeDeletedItems
        inboxOnly
        refreshToken
        clientId
        clientSecret
      }
      readLimit
    }
    issue {
      type
      includeAttachments
      jira {
        uri
        project
        email
        token
        offset
      }
      linear {
        key
        project
      }
      github {
        uri
        repositoryOwner
        repositoryName
        refreshToken
        personalAccessToken
      }
      intercom {
        accessToken
      }
      zendesk {
        subdomain
        accessToken
      }
      trello {
        key
        token
        identifiers
        type
      }
      readLimit
    }
    rss {
      readLimit
      uri
    }
    web {
      readLimit
      uri
      includeFiles
      allowedPaths
      excludedPaths
    }
    search {
      readLimit
      type
      text
    }
    reddit {
      readLimit
      subredditName
    }
    notion {
      readLimit
      token
      identifiers
      type
    }
    intercom {
      readLimit
      accessToken
    }
    zendesk {
      readLimit
      subdomain
      accessToken
    }
    youtube {
      readLimit
      type
      videoName
      videoIdentifiers
      channelIdentifier
      playlistIdentifier
    }
    twitter {
      readLimit
      token
      type
      userName
      query
      includeAttachments
    }
    slack {
      readLimit
      type
      token
      channel
      includeAttachments
    }
    microsoftTeams {
      readLimit
      type
      clientId
      clientSecret
      refreshToken
      teamId
      channelId
    }
    discord {
      readLimit
      type
      token
      channel
      includeAttachments
    }
    error
    lastPostDate
    lastReadDate
    readCount
    workflow {
      id
      name
    }
    schedulePolicy {
      recurrenceType
      repeatInterval
    }
  }
}
"""

GET_SHARE_POINT_CONSENT_URI_GQL = """
query GetSharePointConsentUri($tenantId: ID!) {
  sharePointConsentUri(tenantId: $tenantId) {
    uri
  }
}
"""

IS_FEED_DONE_GQL = """
query IsFeedDone($id: ID!) {
  isFeedDone(id: $id) {
    result
  }
}
"""

QUERY_FEEDS_GQL = """
query QueryFeeds($filter: FeedFilter, $correlationId: String) {
  feeds(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      correlationId
      type
      site {
        siteType
        type
        isRecursive
        s3 {
          accessKey
          secretAccessKey
          bucketName
          prefix
          region
        }
        azureBlob {
          storageAccessKey
          accountName
          containerName
          prefix
        }
        azureFile {
          storageAccessKey
          accountName
          shareName
          prefix
        }
        google {
          credentials
          containerName
          prefix
        }
        sharePoint {
          authenticationType
          accountName
          libraryId
          folderId
          tenantId
          clientId
          clientSecret
          refreshToken
        }
        oneDrive {
          folderId
          files
          clientId
          clientSecret
          refreshToken
        }
        googleDrive {
          authenticationType
          folderId
          files
          refreshToken
          clientId
          clientSecret
          serviceAccountJson
        }
        dropbox {
          path
          appKey
          appSecret
          refreshToken
          redirectUri
        }
        box {
          folderId
          clientId
          clientSecret
          refreshToken
          redirectUri
        }
        github {
          uri
          repositoryOwner
          repositoryName
          refreshToken
          personalAccessToken
        }
        readLimit
      }
      email {
        type
        includeAttachments
        google {
          type
          includeSpam
          excludeSentItems
          includeDeletedItems
          inboxOnly
          refreshToken
          clientId
          clientSecret
        }
        microsoft {
          type
          includeSpam
          excludeSentItems
          includeDeletedItems
          inboxOnly
          refreshToken
          clientId
          clientSecret
        }
        readLimit
      }
      issue {
        type
        includeAttachments
        jira {
          uri
          project
          email
          token
          offset
        }
        linear {
          key
          project
        }
        github {
          uri
          repositoryOwner
          repositoryName
          refreshToken
          personalAccessToken
        }
        intercom {
          accessToken
        }
        zendesk {
          subdomain
          accessToken
        }
        trello {
          key
          token
          identifiers
          type
        }
        readLimit
      }
      rss {
        readLimit
        uri
      }
      web {
        readLimit
        uri
        includeFiles
        allowedPaths
        excludedPaths
      }
      search {
        readLimit
        type
        text
      }
      reddit {
        readLimit
        subredditName
      }
      notion {
        readLimit
        token
        identifiers
        type
      }
      intercom {
        readLimit
        accessToken
      }
      zendesk {
        readLimit
        subdomain
        accessToken
      }
      youtube {
        readLimit
        type
        videoName
        videoIdentifiers
        channelIdentifier
        playlistIdentifier
      }
      twitter {
        readLimit
        token
        type
        userName
        query
        includeAttachments
      }
      slack {
        readLimit
        type
        token
        channel
        includeAttachments
      }
      microsoftTeams {
        readLimit
        type
        clientId
        clientSecret
        refreshToken
        teamId
        channelId
      }
      discord {
        readLimit
        type
        token
        channel
        includeAttachments
      }
      error
      lastPostDate
      lastReadDate
      readCount
      workflow {
        id
        name
      }
      schedulePolicy {
        recurrenceType
        repeatInterval
      }
    }
  }
}
"""

QUERY_LINEAR_PROJECTS_GQL = """
query QueryLinearProjects($properties: LinearProjectsInput!) {
  linearProjects(properties: $properties) {
    results
  }
}
"""

QUERY_MICROSOFT_TEAMS_CHANNELS_GQL = """
query QueryMicrosoftTeamsChannels($properties: MicrosoftTeamsChannelsInput!, $teamId: ID!) {
  microsoftTeamsChannels(properties: $properties, teamId: $teamId) {
    results {
      channelName
      channelId
    }
  }
}
"""

QUERY_MICROSOFT_TEAMS_TEAMS_GQL = """
query QueryMicrosoftTeamsTeams($properties: MicrosoftTeamsTeamsInput!) {
  microsoftTeamsTeams(properties: $properties) {
    results {
      teamName
      teamId
    }
  }
}
"""

QUERY_NOTION_DATABASES_GQL = """
query QueryNotionDatabases($properties: NotionDatabasesInput!) {
  notionDatabases(properties: $properties) {
    results
  }
}
"""

QUERY_NOTION_PAGES_GQL = """
query QueryNotionPages($properties: NotionPagesInput!, $identifier: String!) {
  notionPages(properties: $properties, identifier: $identifier) {
    results
  }
}
"""

QUERY_ONE_DRIVE_FOLDERS_GQL = """
query QueryOneDriveFolders($properties: OneDriveFoldersInput!, $folderId: ID) {
  oneDriveFolders(properties: $properties, folderId: $folderId) {
    results {
      folderName
      folderId
    }
  }
}
"""

QUERY_SHARE_POINT_FOLDERS_GQL = """
query QuerySharePointFolders($properties: SharePointFoldersInput!, $libraryId: ID!, $folderId: ID) {
  sharePointFolders(
    properties: $properties
    libraryId: $libraryId
    folderId: $folderId
  ) {
    accountName
    results {
      folderName
      folderId
    }
  }
}
"""

QUERY_SHARE_POINT_LIBRARIES_GQL = """
query QuerySharePointLibraries($properties: SharePointLibrariesInput!) {
  sharePointLibraries(properties: $properties) {
    accountName
    results {
      libraryName
      libraryId
      siteName
      siteId
    }
  }
}
"""

QUERY_SLACK_CHANNELS_GQL = """
query QuerySlackChannels($properties: SlackChannelsInput!) {
  slackChannels(properties: $properties) {
    results
  }
}
"""

UPDATE_FEED_GQL = """
mutation UpdateFeed($feed: FeedUpdateInput!) {
  updateFeed(feed: $feed) {
    id
    name
    state
    type
  }
}
"""

COUNT_LABELS_GQL = """
query CountLabels($filter: LabelFilter, $correlationId: String) {
  countLabels(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_LABEL_GQL = """
mutation CreateLabel($label: LabelInput!) {
  createLabel(label: $label) {
    id
    name
  }
}
"""

DELETE_ALL_LABELS_GQL = """
mutation DeleteAllLabels($filter: LabelFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllLabels(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_LABEL_GQL = """
mutation DeleteLabel($id: ID!) {
  deleteLabel(id: $id) {
    id
    state
  }
}
"""

DELETE_LABELS_GQL = """
mutation DeleteLabels($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteLabels(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_LABEL_GQL = """
query GetLabel($id: ID!, $correlationId: String) {
  label(id: $id, correlationId: $correlationId) {
    id
    name
    description
    creationDate
    relevance
  }
}
"""

QUERY_LABELS_GQL = """
query QueryLabels($filter: LabelFilter, $correlationId: String) {
  labels(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      description
      creationDate
      relevance
    }
  }
}
"""

UPDATE_LABEL_GQL = """
mutation UpdateLabel($label: LabelUpdateInput!) {
  updateLabel(label: $label) {
    id
    name
  }
}
"""

UPSERT_LABEL_GQL = """
mutation UpsertLabel($label: LabelInput!) {
  upsertLabel(label: $label) {
    id
    name
  }
}
"""

COUNT_MEDICAL_CONDITIONS_GQL = """
query CountMedicalConditions($filter: MedicalConditionFilter, $correlationId: String) {
  countMedicalConditions(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_MEDICAL_CONDITION_GQL = """
mutation CreateMedicalCondition($medicalCondition: MedicalConditionInput!) {
  createMedicalCondition(medicalCondition: $medicalCondition) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_CONDITIONS_GQL = """
mutation DeleteAllMedicalConditions($filter: MedicalConditionFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalConditions(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_CONDITION_GQL = """
mutation DeleteMedicalCondition($id: ID!) {
  deleteMedicalCondition(id: $id) {
    id
    state
  }
}
"""

DELETE_MEDICAL_CONDITIONS_GQL = """
mutation DeleteMedicalConditions($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalConditions(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_MEDICAL_CONDITION_GQL = """
query GetMedicalCondition($id: ID!, $correlationId: String) {
  medicalCondition(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_MEDICAL_CONDITIONS_GQL = """
query QueryMedicalConditions($filter: MedicalConditionFilter, $correlationId: String) {
  medicalConditions(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_MEDICAL_CONDITION_GQL = """
mutation UpdateMedicalCondition($medicalCondition: MedicalConditionUpdateInput!) {
  updateMedicalCondition(medicalCondition: $medicalCondition) {
    id
    name
  }
}
"""

COUNT_MEDICAL_CONTRAINDICATIONS_GQL = """
query CountMedicalContraindications($filter: MedicalContraindicationFilter, $correlationId: String) {
  countMedicalContraindications(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_MEDICAL_CONTRAINDICATION_GQL = """
mutation CreateMedicalContraindication($medicalContraindication: MedicalContraindicationInput!) {
  createMedicalContraindication(medicalContraindication: $medicalContraindication) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_CONTRAINDICATIONS_GQL = """
mutation DeleteAllMedicalContraindications($filter: MedicalContraindicationFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalContraindications(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_CONTRAINDICATION_GQL = """
mutation DeleteMedicalContraindication($id: ID!) {
  deleteMedicalContraindication(id: $id) {
    id
    state
  }
}
"""

DELETE_MEDICAL_CONTRAINDICATIONS_GQL = """
mutation DeleteMedicalContraindications($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalContraindications(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_MEDICAL_CONTRAINDICATION_GQL = """
query GetMedicalContraindication($id: ID!, $correlationId: String) {
  medicalContraindication(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_MEDICAL_CONTRAINDICATIONS_GQL = """
query QueryMedicalContraindications($filter: MedicalContraindicationFilter, $correlationId: String) {
  medicalContraindications(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_MEDICAL_CONTRAINDICATION_GQL = """
mutation UpdateMedicalContraindication($medicalContraindication: MedicalContraindicationUpdateInput!) {
  updateMedicalContraindication(medicalContraindication: $medicalContraindication) {
    id
    name
  }
}
"""

COUNT_MEDICAL_DEVICES_GQL = """
query CountMedicalDevices($filter: MedicalDeviceFilter, $correlationId: String) {
  countMedicalDevices(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_MEDICAL_DEVICE_GQL = """
mutation CreateMedicalDevice($medicalDevice: MedicalDeviceInput!) {
  createMedicalDevice(medicalDevice: $medicalDevice) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_DEVICES_GQL = """
mutation DeleteAllMedicalDevices($filter: MedicalDeviceFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalDevices(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_DEVICE_GQL = """
mutation DeleteMedicalDevice($id: ID!) {
  deleteMedicalDevice(id: $id) {
    id
    state
  }
}
"""

DELETE_MEDICAL_DEVICES_GQL = """
mutation DeleteMedicalDevices($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalDevices(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_MEDICAL_DEVICE_GQL = """
query GetMedicalDevice($id: ID!, $correlationId: String) {
  medicalDevice(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_MEDICAL_DEVICES_GQL = """
query QueryMedicalDevices($filter: MedicalDeviceFilter, $correlationId: String) {
  medicalDevices(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_MEDICAL_DEVICE_GQL = """
mutation UpdateMedicalDevice($medicalDevice: MedicalDeviceUpdateInput!) {
  updateMedicalDevice(medicalDevice: $medicalDevice) {
    id
    name
  }
}
"""

COUNT_MEDICAL_DRUGS_GQL = """
query CountMedicalDrugs($filter: MedicalDrugFilter, $correlationId: String) {
  countMedicalDrugs(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_MEDICAL_DRUG_GQL = """
mutation CreateMedicalDrug($medicalDrug: MedicalDrugInput!) {
  createMedicalDrug(medicalDrug: $medicalDrug) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_DRUGS_GQL = """
mutation DeleteAllMedicalDrugs($filter: MedicalDrugFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalDrugs(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_DRUG_GQL = """
mutation DeleteMedicalDrug($id: ID!) {
  deleteMedicalDrug(id: $id) {
    id
    state
  }
}
"""

DELETE_MEDICAL_DRUGS_GQL = """
mutation DeleteMedicalDrugs($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalDrugs(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_MEDICAL_DRUG_GQL = """
query GetMedicalDrug($id: ID!, $correlationId: String) {
  medicalDrug(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_MEDICAL_DRUGS_GQL = """
query QueryMedicalDrugs($filter: MedicalDrugFilter, $correlationId: String) {
  medicalDrugs(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_MEDICAL_DRUG_GQL = """
mutation UpdateMedicalDrug($medicalDrug: MedicalDrugUpdateInput!) {
  updateMedicalDrug(medicalDrug: $medicalDrug) {
    id
    name
  }
}
"""

COUNT_MEDICAL_DRUG_CLASSES_GQL = """
query CountMedicalDrugClasses($filter: MedicalDrugClassFilter, $correlationId: String) {
  countMedicalDrugClasses(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_MEDICAL_DRUG_CLASS_GQL = """
mutation CreateMedicalDrugClass($medicalDrugClass: MedicalDrugClassInput!) {
  createMedicalDrugClass(medicalDrugClass: $medicalDrugClass) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_DRUG_CLASSES_GQL = """
mutation DeleteAllMedicalDrugClasses($filter: MedicalDrugClassFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalDrugClasses(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_DRUG_CLASS_GQL = """
mutation DeleteMedicalDrugClass($id: ID!) {
  deleteMedicalDrugClass(id: $id) {
    id
    state
  }
}
"""

DELETE_MEDICAL_DRUG_CLASSES_GQL = """
mutation DeleteMedicalDrugClasses($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalDrugClasses(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_MEDICAL_DRUG_CLASS_GQL = """
query GetMedicalDrugClass($id: ID!, $correlationId: String) {
  medicalDrugClass(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_MEDICAL_DRUG_CLASSES_GQL = """
query QueryMedicalDrugClasses($filter: MedicalDrugClassFilter, $correlationId: String) {
  medicalDrugClasses(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_MEDICAL_DRUG_CLASS_GQL = """
mutation UpdateMedicalDrugClass($medicalDrugClass: MedicalDrugClassUpdateInput!) {
  updateMedicalDrugClass(medicalDrugClass: $medicalDrugClass) {
    id
    name
  }
}
"""

COUNT_MEDICAL_GUIDELINES_GQL = """
query CountMedicalGuidelines($filter: MedicalGuidelineFilter, $correlationId: String) {
  countMedicalGuidelines(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_MEDICAL_GUIDELINE_GQL = """
mutation CreateMedicalGuideline($medicalGuideline: MedicalGuidelineInput!) {
  createMedicalGuideline(medicalGuideline: $medicalGuideline) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_GUIDELINES_GQL = """
mutation DeleteAllMedicalGuidelines($filter: MedicalGuidelineFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalGuidelines(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_GUIDELINE_GQL = """
mutation DeleteMedicalGuideline($id: ID!) {
  deleteMedicalGuideline(id: $id) {
    id
    state
  }
}
"""

DELETE_MEDICAL_GUIDELINES_GQL = """
mutation DeleteMedicalGuidelines($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalGuidelines(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_MEDICAL_GUIDELINE_GQL = """
query GetMedicalGuideline($id: ID!, $correlationId: String) {
  medicalGuideline(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_MEDICAL_GUIDELINES_GQL = """
query QueryMedicalGuidelines($filter: MedicalGuidelineFilter, $correlationId: String) {
  medicalGuidelines(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_MEDICAL_GUIDELINE_GQL = """
mutation UpdateMedicalGuideline($medicalGuideline: MedicalGuidelineUpdateInput!) {
  updateMedicalGuideline(medicalGuideline: $medicalGuideline) {
    id
    name
  }
}
"""

COUNT_MEDICAL_INDICATIONS_GQL = """
query CountMedicalIndications($filter: MedicalIndicationFilter, $correlationId: String) {
  countMedicalIndications(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_MEDICAL_INDICATION_GQL = """
mutation CreateMedicalIndication($medicalIndication: MedicalIndicationInput!) {
  createMedicalIndication(medicalIndication: $medicalIndication) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_INDICATIONS_GQL = """
mutation DeleteAllMedicalIndications($filter: MedicalIndicationFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalIndications(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_INDICATION_GQL = """
mutation DeleteMedicalIndication($id: ID!) {
  deleteMedicalIndication(id: $id) {
    id
    state
  }
}
"""

DELETE_MEDICAL_INDICATIONS_GQL = """
mutation DeleteMedicalIndications($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalIndications(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_MEDICAL_INDICATION_GQL = """
query GetMedicalIndication($id: ID!, $correlationId: String) {
  medicalIndication(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_MEDICAL_INDICATIONS_GQL = """
query QueryMedicalIndications($filter: MedicalIndicationFilter, $correlationId: String) {
  medicalIndications(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_MEDICAL_INDICATION_GQL = """
mutation UpdateMedicalIndication($medicalIndication: MedicalIndicationUpdateInput!) {
  updateMedicalIndication(medicalIndication: $medicalIndication) {
    id
    name
  }
}
"""

COUNT_MEDICAL_PROCEDURES_GQL = """
query CountMedicalProcedures($filter: MedicalProcedureFilter, $correlationId: String) {
  countMedicalProcedures(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_MEDICAL_PROCEDURE_GQL = """
mutation CreateMedicalProcedure($medicalProcedure: MedicalProcedureInput!) {
  createMedicalProcedure(medicalProcedure: $medicalProcedure) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_PROCEDURES_GQL = """
mutation DeleteAllMedicalProcedures($filter: MedicalProcedureFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalProcedures(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_PROCEDURE_GQL = """
mutation DeleteMedicalProcedure($id: ID!) {
  deleteMedicalProcedure(id: $id) {
    id
    state
  }
}
"""

DELETE_MEDICAL_PROCEDURES_GQL = """
mutation DeleteMedicalProcedures($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalProcedures(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_MEDICAL_PROCEDURE_GQL = """
query GetMedicalProcedure($id: ID!, $correlationId: String) {
  medicalProcedure(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_MEDICAL_PROCEDURES_GQL = """
query QueryMedicalProcedures($filter: MedicalProcedureFilter, $correlationId: String) {
  medicalProcedures(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_MEDICAL_PROCEDURE_GQL = """
mutation UpdateMedicalProcedure($medicalProcedure: MedicalProcedureUpdateInput!) {
  updateMedicalProcedure(medicalProcedure: $medicalProcedure) {
    id
    name
  }
}
"""

COUNT_MEDICAL_STUDIES_GQL = """
query CountMedicalStudies($filter: MedicalStudyFilter) {
  countMedicalStudies(filter: $filter) {
    count
  }
}
"""

CREATE_MEDICAL_STUDY_GQL = """
mutation CreateMedicalStudy($medicalStudy: MedicalStudyInput!) {
  createMedicalStudy(medicalStudy: $medicalStudy) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_STUDIES_GQL = """
mutation DeleteAllMedicalStudies($filter: MedicalStudyFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalStudies(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_STUDIES_GQL = """
mutation DeleteMedicalStudies($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalStudies(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

DELETE_MEDICAL_STUDY_GQL = """
mutation DeleteMedicalStudy($id: ID!) {
  deleteMedicalStudy(id: $id) {
    id
    state
  }
}
"""

GET_MEDICAL_STUDY_GQL = """
query GetMedicalStudy($id: ID!, $correlationId: String) {
  medicalStudy(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
  }
}
"""

QUERY_MEDICAL_STUDIES_GQL = """
query QueryMedicalStudies($filter: MedicalStudyFilter, $correlationId: String) {
  medicalStudies(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
    }
  }
}
"""

UPDATE_MEDICAL_STUDY_GQL = """
mutation UpdateMedicalStudy($medicalStudy: MedicalStudyUpdateInput!) {
  updateMedicalStudy(medicalStudy: $medicalStudy) {
    id
    name
  }
}
"""

COUNT_MEDICAL_TESTS_GQL = """
query CountMedicalTests($filter: MedicalTestFilter, $correlationId: String) {
  countMedicalTests(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_MEDICAL_TEST_GQL = """
mutation CreateMedicalTest($medicalTest: MedicalTestInput!) {
  createMedicalTest(medicalTest: $medicalTest) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_TESTS_GQL = """
mutation DeleteAllMedicalTests($filter: MedicalTestFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalTests(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_TEST_GQL = """
mutation DeleteMedicalTest($id: ID!) {
  deleteMedicalTest(id: $id) {
    id
    state
  }
}
"""

DELETE_MEDICAL_TESTS_GQL = """
mutation DeleteMedicalTests($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalTests(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_MEDICAL_TEST_GQL = """
query GetMedicalTest($id: ID!, $correlationId: String) {
  medicalTest(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_MEDICAL_TESTS_GQL = """
query QueryMedicalTests($filter: MedicalTestFilter, $correlationId: String) {
  medicalTests(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_MEDICAL_TEST_GQL = """
mutation UpdateMedicalTest($medicalTest: MedicalTestUpdateInput!) {
  updateMedicalTest(medicalTest: $medicalTest) {
    id
    name
  }
}
"""

COUNT_MEDICAL_THERAPIES_GQL = """
query CountMedicalTherapies($filter: MedicalTherapyFilter, $correlationId: String) {
  countMedicalTherapies(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_MEDICAL_THERAPY_GQL = """
mutation CreateMedicalTherapy($medicalTherapy: MedicalTherapyInput!) {
  createMedicalTherapy(medicalTherapy: $medicalTherapy) {
    id
    name
  }
}
"""

DELETE_ALL_MEDICAL_THERAPIES_GQL = """
mutation DeleteAllMedicalTherapies($filter: MedicalTherapyFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllMedicalTherapies(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_MEDICAL_THERAPIES_GQL = """
mutation DeleteMedicalTherapies($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteMedicalTherapies(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

DELETE_MEDICAL_THERAPY_GQL = """
mutation DeleteMedicalTherapy($id: ID!) {
  deleteMedicalTherapy(id: $id) {
    id
    state
  }
}
"""

GET_MEDICAL_THERAPY_GQL = """
query GetMedicalTherapy($id: ID!, $correlationId: String) {
  medicalTherapy(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_MEDICAL_THERAPIES_GQL = """
query QueryMedicalTherapies($filter: MedicalTherapyFilter, $correlationId: String) {
  medicalTherapies(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_MEDICAL_THERAPY_GQL = """
mutation UpdateMedicalTherapy($medicalTherapy: MedicalTherapyUpdateInput!) {
  updateMedicalTherapy(medicalTherapy: $medicalTherapy) {
    id
    name
  }
}
"""

SEND_NOTIFICATION_GQL = """
mutation SendNotification($connector: IntegrationConnectorInput!, $text: String!, $textType: TextTypes) {
  sendNotification(connector: $connector, text: $text, textType: $textType) {
    result
  }
}
"""

CREATE_OBSERVATION_GQL = """
mutation CreateObservation($observation: ObservationInput!) {
  createObservation(observation: $observation) {
    id
    state
  }
}
"""

DELETE_OBSERVATION_GQL = """
mutation DeleteObservation($id: ID!) {
  deleteObservation(id: $id) {
    id
    state
  }
}
"""

UPDATE_OBSERVATION_GQL = """
mutation UpdateObservation($observation: ObservationUpdateInput!) {
  updateObservation(observation: $observation) {
    id
    state
  }
}
"""

COUNT_ORGANIZATIONS_GQL = """
query CountOrganizations($filter: OrganizationFilter, $correlationId: String) {
  countOrganizations(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_ORGANIZATION_GQL = """
mutation CreateOrganization($organization: OrganizationInput!) {
  createOrganization(organization: $organization) {
    id
    name
  }
}
"""

DELETE_ALL_ORGANIZATIONS_GQL = """
mutation DeleteAllOrganizations($filter: OrganizationFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllOrganizations(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_ORGANIZATION_GQL = """
mutation DeleteOrganization($id: ID!) {
  deleteOrganization(id: $id) {
    id
    state
  }
}
"""

DELETE_ORGANIZATIONS_GQL = """
mutation DeleteOrganizations($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteOrganizations(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_ORGANIZATION_GQL = """
query GetOrganization($id: ID!, $correlationId: String) {
  organization(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
    foundingDate
    industries
    revenue
    revenueCurrency
    investment
    investmentCurrency
  }
}
"""

QUERY_ORGANIZATIONS_GQL = """
query QueryOrganizations($filter: OrganizationFilter, $correlationId: String) {
  organizations(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
      foundingDate
      industries
      revenue
      revenueCurrency
      investment
      investmentCurrency
    }
  }
}
"""

UPDATE_ORGANIZATION_GQL = """
mutation UpdateOrganization($organization: OrganizationUpdateInput!) {
  updateOrganization(organization: $organization) {
    id
    name
  }
}
"""

COUNT_PERSONS_GQL = """
query CountPersons($filter: PersonFilter, $correlationId: String) {
  countPersons(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_PERSON_GQL = """
mutation CreatePerson($person: PersonInput!) {
  createPerson(person: $person) {
    id
    name
  }
}
"""

DELETE_ALL_PERSONS_GQL = """
mutation DeleteAllPersons($filter: PersonFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllPersons(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_PERSON_GQL = """
mutation DeletePerson($id: ID!) {
  deletePerson(id: $id) {
    id
    state
  }
}
"""

DELETE_PERSONS_GQL = """
mutation DeletePersons($ids: [ID!]!, $isSynchronous: Boolean) {
  deletePersons(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_PERSON_GQL = """
query GetPerson($id: ID!, $correlationId: String) {
  person(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
    email
    givenName
    familyName
    phoneNumber
    birthDate
    title
    occupation
    education
  }
}
"""

QUERY_PERSONS_GQL = """
query QueryPersons($filter: PersonFilter, $correlationId: String) {
  persons(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
      email
      givenName
      familyName
      phoneNumber
      birthDate
      title
      occupation
      education
    }
  }
}
"""

UPDATE_PERSON_GQL = """
mutation UpdatePerson($person: PersonUpdateInput!) {
  updatePerson(person: $person) {
    id
    name
  }
}
"""

COUNT_PLACES_GQL = """
query CountPlaces($filter: PlaceFilter, $correlationId: String) {
  countPlaces(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_PLACE_GQL = """
mutation CreatePlace($place: PlaceInput!) {
  createPlace(place: $place) {
    id
    name
  }
}
"""

DELETE_ALL_PLACES_GQL = """
mutation DeleteAllPlaces($filter: PlaceFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllPlaces(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_PLACE_GQL = """
mutation DeletePlace($id: ID!) {
  deletePlace(id: $id) {
    id
    state
  }
}
"""

DELETE_PLACES_GQL = """
mutation DeletePlaces($ids: [ID!]!, $isSynchronous: Boolean) {
  deletePlaces(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_PLACE_GQL = """
query GetPlace($id: ID!, $correlationId: String) {
  place(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
  }
}
"""

QUERY_PLACES_GQL = """
query QueryPlaces($filter: PlaceFilter, $correlationId: String) {
  places(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
    }
  }
}
"""

UPDATE_PLACE_GQL = """
mutation UpdatePlace($place: PlaceUpdateInput!) {
  updatePlace(place: $place) {
    id
    name
  }
}
"""

COUNT_PRODUCTS_GQL = """
query CountProducts($filter: ProductFilter, $correlationId: String) {
  countProducts(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_PRODUCT_GQL = """
mutation CreateProduct($product: ProductInput!) {
  createProduct(product: $product) {
    id
    name
  }
}
"""

DELETE_ALL_PRODUCTS_GQL = """
mutation DeleteAllProducts($filter: ProductFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllProducts(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_PRODUCT_GQL = """
mutation DeleteProduct($id: ID!) {
  deleteProduct(id: $id) {
    id
    state
  }
}
"""

DELETE_PRODUCTS_GQL = """
mutation DeleteProducts($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteProducts(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_PRODUCT_GQL = """
query GetProduct($id: ID!, $correlationId: String) {
  product(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    address {
      streetAddress
      city
      region
      country
      postalCode
    }
    manufacturer
    model
    brand
    upc
    sku
    releaseDate
    productionDate
  }
}
"""

QUERY_PRODUCTS_GQL = """
query QueryProducts($filter: ProductFilter, $correlationId: String) {
  products(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      address {
        streetAddress
        city
        region
        country
        postalCode
      }
      manufacturer
      model
      brand
      upc
      sku
      releaseDate
      productionDate
    }
  }
}
"""

UPDATE_PRODUCT_GQL = """
mutation UpdateProduct($product: ProductUpdateInput!) {
  updateProduct(product: $product) {
    id
    name
  }
}
"""

GET_PROJECT_GQL = """
query GetProject {
  project {
    id
    name
    creationDate
    modifiedDate
    state
    environmentType
    platform
    region
    credits
    lastCreditsDate
    workflow {
      id
      name
    }
    specification {
      id
      name
    }
    embeddings {
      textSpecification {
        id
      }
      imageSpecification {
        id
      }
    }
    quota {
      storage
      contents
      credits
      feeds
      posts
      conversations
    }
    callbackUri
  }
}
"""

LOOKUP_CREDITS_GQL = """
query LookupCredits($correlationId: String!) {
  lookupCredits(correlationId: $correlationId) {
    correlationId
    ownerId
    credits
    storageRatio
    computeRatio
    embeddingRatio
    completionRatio
    generationRatio
    ingestionRatio
    indexingRatio
    preparationRatio
    extractionRatio
    classificationRatio
    enrichmentRatio
    publishingRatio
    searchRatio
    conversationRatio
  }
}
"""

LOOKUP_USAGE_GQL = """
query LookupUsage($correlationId: String!) {
  lookupUsage(correlationId: $correlationId) {
    id
    correlationId
    date
    credits
    name
    metric
    workflow
    entityType
    entityId
    projectId
    ownerId
    uri
    duration
    throughput
    contentType
    fileType
    modelService
    modelName
    processorName
    prompt
    promptTokens
    completion
    completionTokens
    tokens
    count
    operation
    operationType
    request
    variables
    response
  }
}
"""

QUERY_CREDITS_GQL = """
query QueryCredits($startDate: DateTime!, $duration: TimeSpan!) {
  credits(startDate: $startDate, duration: $duration) {
    correlationId
    ownerId
    credits
    storageRatio
    computeRatio
    embeddingRatio
    completionRatio
    generationRatio
    ingestionRatio
    indexingRatio
    preparationRatio
    extractionRatio
    classificationRatio
    enrichmentRatio
    publishingRatio
    searchRatio
    conversationRatio
  }
}
"""

QUERY_TOKENS_GQL = """
query QueryTokens($startDate: DateTime!, $duration: TimeSpan!) {
  tokens(startDate: $startDate, duration: $duration) {
    correlationId
    ownerId
    embeddingInputTokens
    embeddingModelServices
    completionInputTokens
    completionOutputTokens
    completionModelServices
    preparationInputTokens
    preparationOutputTokens
    preparationModelServices
    extractionInputTokens
    extractionOutputTokens
    extractionModelServices
    generationInputTokens
    generationOutputTokens
    generationModelServices
  }
}
"""

QUERY_USAGE_GQL = """
query QueryUsage($startDate: DateTime!, $duration: TimeSpan!, $names: [String!], $excludedNames: [String!], $offset: Int, $limit: Int) {
  usage(
    startDate: $startDate
    duration: $duration
    names: $names
    excludedNames: $excludedNames
    offset: $offset
    limit: $limit
  ) {
    id
    correlationId
    date
    credits
    name
    metric
    workflow
    entityType
    entityId
    projectId
    ownerId
    uri
    duration
    throughput
    contentType
    fileType
    modelService
    modelName
    processorName
    prompt
    promptTokens
    completion
    completionTokens
    tokens
    count
    operation
    operationType
    request
    variables
    response
  }
}
"""

UPDATE_PROJECT_GQL = """
mutation UpdateProject($project: ProjectUpdateInput!) {
  updateProject(project: $project) {
    id
    name
  }
}
"""

COUNT_REPOS_GQL = """
query CountRepos($filter: RepoFilter, $correlationId: String) {
  countRepos(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_REPO_GQL = """
mutation CreateRepo($repo: RepoInput!) {
  createRepo(repo: $repo) {
    id
    name
  }
}
"""

DELETE_ALL_REPOS_GQL = """
mutation DeleteAllRepos($filter: RepoFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllRepos(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_REPO_GQL = """
mutation DeleteRepo($id: ID!) {
  deleteRepo(id: $id) {
    id
    state
  }
}
"""

DELETE_REPOS_GQL = """
mutation DeleteRepos($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteRepos(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_REPO_GQL = """
query GetRepo($id: ID!, $correlationId: String) {
  repo(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
  }
}
"""

QUERY_REPOS_GQL = """
query QueryRepos($filter: RepoFilter, $correlationId: String) {
  repos(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
    }
  }
}
"""

UPDATE_REPO_GQL = """
mutation UpdateRepo($repo: RepoUpdateInput!) {
  updateRepo(repo: $repo) {
    id
    name
  }
}
"""

MAP_WEB_GQL = """
query MapWeb($uri: URL!, $allowedPaths: [String!], $excludedPaths: [String!], $correlationId: String) {
  mapWeb(
    uri: $uri
    allowedPaths: $allowedPaths
    excludedPaths: $excludedPaths
    correlationId: $correlationId
  ) {
    results
  }
}
"""

SEARCH_WEB_GQL = """
query SearchWeb($text: String!, $service: SearchServiceTypes, $limit: Int, $correlationId: String) {
  searchWeb(
    text: $text
    service: $service
    limit: $limit
    correlationId: $correlationId
  ) {
    results {
      uri
      text
      title
      score
    }
  }
}
"""

COUNT_SOFTWARES_GQL = """
query CountSoftwares($filter: SoftwareFilter, $correlationId: String) {
  countSoftwares(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_SOFTWARE_GQL = """
mutation CreateSoftware($software: SoftwareInput!) {
  createSoftware(software: $software) {
    id
    name
  }
}
"""

DELETE_ALL_SOFTWARES_GQL = """
mutation DeleteAllSoftwares($filter: SoftwareFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllSoftwares(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_SOFTWARE_GQL = """
mutation DeleteSoftware($id: ID!) {
  deleteSoftware(id: $id) {
    id
    state
  }
}
"""

DELETE_SOFTWARES_GQL = """
mutation DeleteSoftwares($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteSoftwares(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_SOFTWARE_GQL = """
query GetSoftware($id: ID!, $correlationId: String) {
  software(id: $id, correlationId: $correlationId) {
    id
    name
    alternateNames
    creationDate
    uri
    description
    identifier
    thing
    relevance
    releaseDate
    developer
  }
}
"""

QUERY_SOFTWARES_GQL = """
query QuerySoftwares($filter: SoftwareFilter, $correlationId: String) {
  softwares(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      alternateNames
      creationDate
      uri
      description
      identifier
      thing
      relevance
      releaseDate
      developer
    }
  }
}
"""

UPDATE_SOFTWARE_GQL = """
mutation UpdateSoftware($software: SoftwareUpdateInput!) {
  updateSoftware(software: $software) {
    id
    name
  }
}
"""

COUNT_SPECIFICATIONS_GQL = """
query CountSpecifications($filter: SpecificationFilter, $correlationId: String) {
  countSpecifications(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_SPECIFICATION_GQL = """
mutation CreateSpecification($specification: SpecificationInput!) {
  createSpecification(specification: $specification) {
    id
    name
    state
    type
    serviceType
  }
}
"""

DELETE_ALL_SPECIFICATIONS_GQL = """
mutation DeleteAllSpecifications($filter: SpecificationFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllSpecifications(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_SPECIFICATION_GQL = """
mutation DeleteSpecification($id: ID!) {
  deleteSpecification(id: $id) {
    id
    state
  }
}
"""

DELETE_SPECIFICATIONS_GQL = """
mutation DeleteSpecifications($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteSpecifications(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_SPECIFICATION_GQL = """
query GetSpecification($id: ID!, $correlationId: String) {
  specification(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    type
    serviceType
    systemPrompt
    customGuidance
    customInstructions
    searchType
    numberSimilar
    strategy {
      type
      messageLimit
      embedCitations
      flattenCitations
      enableFacets
      messagesWeight
      contentsWeight
    }
    promptStrategy {
      type
    }
    retrievalStrategy {
      type
      contentLimit
      disableFallback
    }
    rerankingStrategy {
      serviceType
      threshold
    }
    graphStrategy {
      type
      generateGraph
      observableLimit
    }
    revisionStrategy {
      type
      customRevision
      count
    }
    azureAI {
      tokenLimit
      completionTokenLimit
      key
      endpoint
      temperature
      probability
      chunkTokenLimit
    }
    openAI {
      tokenLimit
      completionTokenLimit
      model
      key
      endpoint
      modelName
      temperature
      probability
      chunkTokenLimit
      detailLevel
      reasoningEffort
    }
    azureOpenAI {
      tokenLimit
      completionTokenLimit
      model
      key
      endpoint
      deploymentName
      temperature
      probability
      chunkTokenLimit
    }
    cohere {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      temperature
      probability
      chunkTokenLimit
    }
    anthropic {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      temperature
      probability
      enableThinking
      thinkingTokenLimit
    }
    google {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      temperature
      probability
      chunkTokenLimit
      enableThinking
      thinkingTokenLimit
    }
    replicate {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      temperature
      probability
    }
    mistral {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      endpoint
      temperature
      probability
      chunkTokenLimit
    }
    bedrock {
      tokenLimit
      completionTokenLimit
      model
      accessKey
      secretAccessKey
      modelName
      temperature
      probability
    }
    groq {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      endpoint
      temperature
      probability
    }
    cerebras {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      endpoint
      temperature
      probability
    }
    deepseek {
      tokenLimit
      completionTokenLimit
      model
      key
      modelName
      temperature
      probability
    }
    jina {
      model
      key
      modelName
      chunkTokenLimit
    }
    voyage {
      model
      key
      modelName
      chunkTokenLimit
    }
  }
}
"""

PROMPT_SPECIFICATIONS_GQL = """
mutation PromptSpecifications($prompt: String!, $ids: [ID!]!) {
  promptSpecifications(prompt: $prompt, ids: $ids) {
    specification {
      id
    }
    messages {
      role
      author
      message
      citations {
        content {
          id
          name
          state
          originalDate
          identifier
          uri
          type
          fileType
          mimeType
          format
          formatName
          fileExtension
          fileName
          fileSize
          masterUri
          imageUri
          textUri
          audioUri
          transcriptUri
          summary
          customSummary
          keywords
          bullets
          headlines
          posts
          chapters
          questions
          video {
            width
            height
            duration
            make
            model
            software
            title
            description
            keywords
            author
          }
          audio {
            keywords
            author
            series
            episode
            episodeType
            season
            publisher
            copyright
            genre
            title
            description
            bitrate
            channels
            sampleRate
            bitsPerSample
            duration
          }
          image {
            width
            height
            resolutionX
            resolutionY
            bitsPerComponent
            components
            projectionType
            orientation
            description
            make
            model
            software
            lens
            focalLength
            exposureTime
            fNumber
            iso
            heading
            pitch
          }
          document {
            title
            subject
            summary
            author
            publisher
            description
            keywords
            pageCount
            worksheetCount
            slideCount
            wordCount
            lineCount
            paragraphCount
            isEncrypted
            hasDigitalSignature
          }
        }
        index
        text
        startTime
        endTime
        pageNumber
        frameNumber
      }
      toolCalls {
        id
        name
        arguments
      }
      tokens
      throughput
      completionTime
      timestamp
      modelService
      model
      data
      mimeType
      toolCallId
      toolCallResponse
    }
    error
  }
}
"""

QUERY_MODELS_GQL = """
query QueryModels($filter: ModelFilter) {
  models(filter: $filter) {
    results {
      uri
      name
      type
      serviceType
      model
      modelType
      description
      availableOn
      features {
        keyFeatures
        strengths
        useCases
      }
      metadata {
        multilingual
        multimodal
        knowledgeCutoff
        promptCostPerMillion
        completionCostPerMillion
        embeddingsCostPerMillion
        rerankingCostPerMillion
        contextWindowTokens
        maxOutputTokens
      }
    }
  }
}
"""

QUERY_SPECIFICATIONS_GQL = """
query QuerySpecifications($filter: SpecificationFilter, $correlationId: String) {
  specifications(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      type
      serviceType
      systemPrompt
      customGuidance
      customInstructions
      searchType
      numberSimilar
      strategy {
        type
        messageLimit
        embedCitations
        flattenCitations
        enableFacets
        messagesWeight
        contentsWeight
      }
      promptStrategy {
        type
      }
      retrievalStrategy {
        type
        contentLimit
        disableFallback
      }
      rerankingStrategy {
        serviceType
        threshold
      }
      graphStrategy {
        type
        generateGraph
        observableLimit
      }
      revisionStrategy {
        type
        customRevision
        count
      }
      azureAI {
        tokenLimit
        completionTokenLimit
        key
        endpoint
        temperature
        probability
        chunkTokenLimit
      }
      openAI {
        tokenLimit
        completionTokenLimit
        model
        key
        endpoint
        modelName
        temperature
        probability
        chunkTokenLimit
        detailLevel
        reasoningEffort
      }
      azureOpenAI {
        tokenLimit
        completionTokenLimit
        model
        key
        endpoint
        deploymentName
        temperature
        probability
        chunkTokenLimit
      }
      cohere {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        temperature
        probability
        chunkTokenLimit
      }
      anthropic {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        temperature
        probability
        enableThinking
        thinkingTokenLimit
      }
      google {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        temperature
        probability
        chunkTokenLimit
        enableThinking
        thinkingTokenLimit
      }
      replicate {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        temperature
        probability
      }
      mistral {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        endpoint
        temperature
        probability
        chunkTokenLimit
      }
      bedrock {
        tokenLimit
        completionTokenLimit
        model
        accessKey
        secretAccessKey
        modelName
        temperature
        probability
      }
      groq {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        endpoint
        temperature
        probability
      }
      cerebras {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        endpoint
        temperature
        probability
      }
      deepseek {
        tokenLimit
        completionTokenLimit
        model
        key
        modelName
        temperature
        probability
      }
      jina {
        model
        key
        modelName
        chunkTokenLimit
      }
      voyage {
        model
        key
        modelName
        chunkTokenLimit
      }
    }
  }
}
"""

SPECIFICATION_EXISTS_GQL = """
query SpecificationExists($filter: SpecificationFilter, $correlationId: String) {
  specificationExists(filter: $filter, correlationId: $correlationId) {
    result
  }
}
"""

UPDATE_SPECIFICATION_GQL = """
mutation UpdateSpecification($specification: SpecificationUpdateInput!) {
  updateSpecification(specification: $specification) {
    id
    name
    state
    type
    serviceType
  }
}
"""

UPSERT_SPECIFICATION_GQL = """
mutation UpsertSpecification($specification: SpecificationInput!) {
  upsertSpecification(specification: $specification) {
    id
    name
    state
    type
    serviceType
  }
}
"""

COUNT_USERS_GQL = """
query CountUsers($filter: UserFilter, $correlationId: String) {
  countUsers(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_USER_GQL = """
mutation CreateUser($user: UserInput!) {
  createUser(user: $user) {
    id
    name
    state
    type
    identifier
  }
}
"""

DELETE_USER_GQL = """
mutation DeleteUser($id: ID!) {
  deleteUser(id: $id) {
    id
    state
  }
}
"""

DISABLE_USER_GQL = """
mutation DisableUser($id: ID!) {
  disableUser(id: $id) {
    id
    state
  }
}
"""

ENABLE_USER_GQL = """
mutation EnableUser($id: ID!) {
  enableUser(id: $id) {
    id
    state
  }
}
"""

GET_USER_GQL = """
query GetUser {
  user {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    type
    identifier
    connectors {
      id
      name
      state
      type
      authentication {
        type
        microsoft {
          tenantId
          clientId
          clientSecret
        }
        google {
          clientId
          clientSecret
        }
      }
      integration {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
    }
  }
}
"""

QUERY_USERS_GQL = """
query QueryUsers($filter: UserFilter, $correlationId: String) {
  users(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      type
      identifier
      connectors {
        id
        name
        state
        type
        authentication {
          type
          microsoft {
            tenantId
            clientId
            clientSecret
          }
          google {
            clientId
            clientSecret
          }
        }
        integration {
          type
          uri
          slack {
            token
            channel
          }
          email {
            from
            subject
            to
          }
          twitter {
            consumerKey
            consumerSecret
            accessTokenKey
            accessTokenSecret
          }
        }
      }
    }
  }
}
"""

UPDATE_USER_GQL = """
mutation UpdateUser($user: UserUpdateInput!) {
  updateUser(user: $user) {
    id
    name
    state
    type
    identifier
  }
}
"""

COUNT_WORKFLOWS_GQL = """
query CountWorkflows($filter: WorkflowFilter, $correlationId: String) {
  countWorkflows(filter: $filter, correlationId: $correlationId) {
    count
  }
}
"""

CREATE_WORKFLOW_GQL = """
mutation CreateWorkflow($workflow: WorkflowInput!) {
  createWorkflow(workflow: $workflow) {
    id
    name
    state
    ingestion {
      if {
        types
        fileTypes
        formats
        fileExtensions
        allowedPaths
        excludedPaths
      }
      collections {
        id
      }
      observations {
        type
        observable {
          id
          name
        }
      }
      enableEmailCollections
    }
    indexing {
      jobs {
        connector {
          type
          contentType
          fileType
        }
      }
    }
    preparation {
      enableUnblockedCapture
      disableSmartCapture
      summarizations {
        type
        specification {
          id
        }
        tokens
        items
        prompt
      }
      jobs {
        connector {
          type
          fileTypes
          azureDocument {
            version
            model
            endpoint
            key
          }
          deepgram {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          assemblyAI {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          page {
            enableScreenshot
          }
          document {
            includeImages
          }
          email {
            includeAttachments
          }
          modelDocument {
            specification {
              id
            }
          }
          mistral {
            key
          }
        }
      }
    }
    extraction {
      jobs {
        connector {
          type
          contentTypes
          fileTypes
          extractedTypes
          extractedCount
          azureText {
            confidenceThreshold
            enablePII
          }
          azureImage {
            confidenceThreshold
          }
          modelImage {
            specification {
              id
            }
          }
          modelText {
            specification {
              id
            }
          }
        }
      }
    }
    classification {
      jobs {
        connector {
          type
          contentType
          fileType
          model {
            specification {
              id
            }
            rules {
              then
              if
            }
          }
          regex {
            rules {
              then
              type
              path
              matches
            }
          }
        }
      }
    }
    enrichment {
      link {
        enableCrawling
        allowedDomains
        excludedDomains
        allowedPaths
        excludedPaths
        allowedLinks
        excludedLinks
        allowedFiles
        excludedFiles
        allowContentDomain
        maximumLinks
      }
      jobs {
        connector {
          type
          enrichedTypes
          fhir {
            endpoint
          }
          diffbot {
            key
          }
        }
      }
    }
    storage {
      policy {
        type
        allowDuplicates
      }
    }
    actions {
      connector {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
    }
  }
}
"""

DELETE_ALL_WORKFLOWS_GQL = """
mutation DeleteAllWorkflows($filter: WorkflowFilter, $isSynchronous: Boolean, $correlationId: String) {
  deleteAllWorkflows(
    filter: $filter
    isSynchronous: $isSynchronous
    correlationId: $correlationId
  ) {
    id
    state
  }
}
"""

DELETE_WORKFLOW_GQL = """
mutation DeleteWorkflow($id: ID!) {
  deleteWorkflow(id: $id) {
    id
    state
  }
}
"""

DELETE_WORKFLOWS_GQL = """
mutation DeleteWorkflows($ids: [ID!]!, $isSynchronous: Boolean) {
  deleteWorkflows(ids: $ids, isSynchronous: $isSynchronous) {
    id
    state
  }
}
"""

GET_WORKFLOW_GQL = """
query GetWorkflow($id: ID!, $correlationId: String) {
  workflow(id: $id, correlationId: $correlationId) {
    id
    name
    creationDate
    relevance
    owner {
      id
    }
    state
    ingestion {
      if {
        types
        fileTypes
        formats
        fileExtensions
        allowedPaths
        excludedPaths
      }
      collections {
        id
      }
      observations {
        type
        observable {
          id
          name
        }
      }
      enableEmailCollections
    }
    indexing {
      jobs {
        connector {
          type
          contentType
          fileType
        }
      }
    }
    preparation {
      enableUnblockedCapture
      disableSmartCapture
      summarizations {
        type
        specification {
          id
        }
        tokens
        items
        prompt
      }
      jobs {
        connector {
          type
          fileTypes
          azureDocument {
            version
            model
            endpoint
            key
          }
          deepgram {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          assemblyAI {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          page {
            enableScreenshot
          }
          document {
            includeImages
          }
          email {
            includeAttachments
          }
          modelDocument {
            specification {
              id
            }
          }
          mistral {
            key
          }
        }
      }
    }
    extraction {
      jobs {
        connector {
          type
          contentTypes
          fileTypes
          extractedTypes
          extractedCount
          azureText {
            confidenceThreshold
            enablePII
          }
          azureImage {
            confidenceThreshold
          }
          modelImage {
            specification {
              id
            }
          }
          modelText {
            specification {
              id
            }
          }
        }
      }
    }
    classification {
      jobs {
        connector {
          type
          contentType
          fileType
          model {
            specification {
              id
            }
            rules {
              then
              if
            }
          }
          regex {
            rules {
              then
              type
              path
              matches
            }
          }
        }
      }
    }
    enrichment {
      link {
        enableCrawling
        allowedDomains
        excludedDomains
        allowedPaths
        excludedPaths
        allowedLinks
        excludedLinks
        allowedFiles
        excludedFiles
        allowContentDomain
        maximumLinks
      }
      jobs {
        connector {
          type
          enrichedTypes
          fhir {
            endpoint
          }
          diffbot {
            key
          }
        }
      }
    }
    storage {
      policy {
        type
        allowDuplicates
      }
    }
    actions {
      connector {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
    }
  }
}
"""

QUERY_WORKFLOWS_GQL = """
query QueryWorkflows($filter: WorkflowFilter, $correlationId: String) {
  workflows(filter: $filter, correlationId: $correlationId) {
    results {
      id
      name
      creationDate
      relevance
      owner {
        id
      }
      state
      ingestion {
        if {
          types
          fileTypes
          formats
          fileExtensions
          allowedPaths
          excludedPaths
        }
        collections {
          id
        }
        observations {
          type
          observable {
            id
            name
          }
        }
        enableEmailCollections
      }
      indexing {
        jobs {
          connector {
            type
            contentType
            fileType
          }
        }
      }
      preparation {
        enableUnblockedCapture
        disableSmartCapture
        summarizations {
          type
          specification {
            id
          }
          tokens
          items
          prompt
        }
        jobs {
          connector {
            type
            fileTypes
            azureDocument {
              version
              model
              endpoint
              key
            }
            deepgram {
              model
              key
              enableRedaction
              enableSpeakerDiarization
              detectLanguage
              language
            }
            assemblyAI {
              model
              key
              enableRedaction
              enableSpeakerDiarization
              detectLanguage
              language
            }
            page {
              enableScreenshot
            }
            document {
              includeImages
            }
            email {
              includeAttachments
            }
            modelDocument {
              specification {
                id
              }
            }
            mistral {
              key
            }
          }
        }
      }
      extraction {
        jobs {
          connector {
            type
            contentTypes
            fileTypes
            extractedTypes
            extractedCount
            azureText {
              confidenceThreshold
              enablePII
            }
            azureImage {
              confidenceThreshold
            }
            modelImage {
              specification {
                id
              }
            }
            modelText {
              specification {
                id
              }
            }
          }
        }
      }
      classification {
        jobs {
          connector {
            type
            contentType
            fileType
            model {
              specification {
                id
              }
              rules {
                then
                if
              }
            }
            regex {
              rules {
                then
                type
                path
                matches
              }
            }
          }
        }
      }
      enrichment {
        link {
          enableCrawling
          allowedDomains
          excludedDomains
          allowedPaths
          excludedPaths
          allowedLinks
          excludedLinks
          allowedFiles
          excludedFiles
          allowContentDomain
          maximumLinks
        }
        jobs {
          connector {
            type
            enrichedTypes
            fhir {
              endpoint
            }
            diffbot {
              key
            }
          }
        }
      }
      storage {
        policy {
          type
          allowDuplicates
        }
      }
      actions {
        connector {
          type
          uri
          slack {
            token
            channel
          }
          email {
            from
            subject
            to
          }
          twitter {
            consumerKey
            consumerSecret
            accessTokenKey
            accessTokenSecret
          }
        }
      }
    }
  }
}
"""

UPDATE_WORKFLOW_GQL = """
mutation UpdateWorkflow($workflow: WorkflowUpdateInput!) {
  updateWorkflow(workflow: $workflow) {
    id
    name
    state
    ingestion {
      if {
        types
        fileTypes
        formats
        fileExtensions
        allowedPaths
        excludedPaths
      }
      collections {
        id
      }
      observations {
        type
        observable {
          id
          name
        }
      }
      enableEmailCollections
    }
    indexing {
      jobs {
        connector {
          type
          contentType
          fileType
        }
      }
    }
    preparation {
      enableUnblockedCapture
      disableSmartCapture
      summarizations {
        type
        specification {
          id
        }
        tokens
        items
        prompt
      }
      jobs {
        connector {
          type
          fileTypes
          azureDocument {
            version
            model
            endpoint
            key
          }
          deepgram {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          assemblyAI {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          page {
            enableScreenshot
          }
          document {
            includeImages
          }
          email {
            includeAttachments
          }
          modelDocument {
            specification {
              id
            }
          }
          mistral {
            key
          }
        }
      }
    }
    extraction {
      jobs {
        connector {
          type
          contentTypes
          fileTypes
          extractedTypes
          extractedCount
          azureText {
            confidenceThreshold
            enablePII
          }
          azureImage {
            confidenceThreshold
          }
          modelImage {
            specification {
              id
            }
          }
          modelText {
            specification {
              id
            }
          }
        }
      }
    }
    classification {
      jobs {
        connector {
          type
          contentType
          fileType
          model {
            specification {
              id
            }
            rules {
              then
              if
            }
          }
          regex {
            rules {
              then
              type
              path
              matches
            }
          }
        }
      }
    }
    enrichment {
      link {
        enableCrawling
        allowedDomains
        excludedDomains
        allowedPaths
        excludedPaths
        allowedLinks
        excludedLinks
        allowedFiles
        excludedFiles
        allowContentDomain
        maximumLinks
      }
      jobs {
        connector {
          type
          enrichedTypes
          fhir {
            endpoint
          }
          diffbot {
            key
          }
        }
      }
    }
    storage {
      policy {
        type
        allowDuplicates
      }
    }
    actions {
      connector {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
    }
  }
}
"""

UPSERT_WORKFLOW_GQL = """
mutation UpsertWorkflow($workflow: WorkflowInput!) {
  upsertWorkflow(workflow: $workflow) {
    id
    name
    state
    ingestion {
      if {
        types
        fileTypes
        formats
        fileExtensions
        allowedPaths
        excludedPaths
      }
      collections {
        id
      }
      observations {
        type
        observable {
          id
          name
        }
      }
      enableEmailCollections
    }
    indexing {
      jobs {
        connector {
          type
          contentType
          fileType
        }
      }
    }
    preparation {
      enableUnblockedCapture
      disableSmartCapture
      summarizations {
        type
        specification {
          id
        }
        tokens
        items
        prompt
      }
      jobs {
        connector {
          type
          fileTypes
          azureDocument {
            version
            model
            endpoint
            key
          }
          deepgram {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          assemblyAI {
            model
            key
            enableRedaction
            enableSpeakerDiarization
            detectLanguage
            language
          }
          page {
            enableScreenshot
          }
          document {
            includeImages
          }
          email {
            includeAttachments
          }
          modelDocument {
            specification {
              id
            }
          }
          mistral {
            key
          }
        }
      }
    }
    extraction {
      jobs {
        connector {
          type
          contentTypes
          fileTypes
          extractedTypes
          extractedCount
          azureText {
            confidenceThreshold
            enablePII
          }
          azureImage {
            confidenceThreshold
          }
          modelImage {
            specification {
              id
            }
          }
          modelText {
            specification {
              id
            }
          }
        }
      }
    }
    classification {
      jobs {
        connector {
          type
          contentType
          fileType
          model {
            specification {
              id
            }
            rules {
              then
              if
            }
          }
          regex {
            rules {
              then
              type
              path
              matches
            }
          }
        }
      }
    }
    enrichment {
      link {
        enableCrawling
        allowedDomains
        excludedDomains
        allowedPaths
        excludedPaths
        allowedLinks
        excludedLinks
        allowedFiles
        excludedFiles
        allowContentDomain
        maximumLinks
      }
      jobs {
        connector {
          type
          enrichedTypes
          fhir {
            endpoint
          }
          diffbot {
            key
          }
        }
      }
    }
    storage {
      policy {
        type
        allowDuplicates
      }
    }
    actions {
      connector {
        type
        uri
        slack {
          token
          channel
        }
        email {
          from
          subject
          to
        }
        twitter {
          consumerKey
          consumerSecret
          accessTokenKey
          accessTokenSecret
        }
      }
    }
  }
}
"""

WORKFLOW_EXISTS_GQL = """
query WorkflowExists($filter: WorkflowFilter, $correlationId: String) {
  workflowExists(filter: $filter, correlationId: $correlationId) {
    result
  }
}
"""



================================================
FILE: graphlit_api/prompt.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    OrientationTypes,
)


class Prompt(BaseModel):
    prompt: Optional["PromptPrompt"]


class PromptPrompt(BaseModel):
    specification: Optional["PromptPromptSpecification"]
    messages: Optional[List[Optional["PromptPromptMessages"]]]
    error: Optional[str]


class PromptPromptSpecification(BaseModel):
    id: str


class PromptPromptMessages(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[List[Optional["PromptPromptMessagesCitations"]]]
    tool_calls: Optional[List[Optional["PromptPromptMessagesToolCalls"]]] = Field(
        alias="toolCalls"
    )
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class PromptPromptMessagesCitations(BaseModel):
    content: Optional["PromptPromptMessagesCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class PromptPromptMessagesCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["PromptPromptMessagesCitationsContentVideo"]
    audio: Optional["PromptPromptMessagesCitationsContentAudio"]
    image: Optional["PromptPromptMessagesCitationsContentImage"]
    document: Optional["PromptPromptMessagesCitationsContentDocument"]


class PromptPromptMessagesCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class PromptPromptMessagesCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class PromptPromptMessagesCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class PromptPromptMessagesCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class PromptPromptMessagesToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


Prompt.model_rebuild()
PromptPrompt.model_rebuild()
PromptPromptMessages.model_rebuild()
PromptPromptMessagesCitations.model_rebuild()
PromptPromptMessagesCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/prompt_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentFacetTypes,
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    EntityTypes,
    FacetValueTypes,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    ObservableTypes,
    OrientationTypes,
)


class PromptConversation(BaseModel):
    prompt_conversation: Optional["PromptConversationPromptConversation"] = Field(
        alias="promptConversation"
    )


class PromptConversationPromptConversation(BaseModel):
    conversation: Optional["PromptConversationPromptConversationConversation"]
    message: Optional["PromptConversationPromptConversationMessage"]
    message_count: Optional[int] = Field(alias="messageCount")
    facets: Optional[List[Optional["PromptConversationPromptConversationFacets"]]]
    graph: Optional["PromptConversationPromptConversationGraph"]
    details: Optional["PromptConversationPromptConversationDetails"]


class PromptConversationPromptConversationConversation(BaseModel):
    id: str


class PromptConversationPromptConversationMessage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[Optional["PromptConversationPromptConversationMessageCitations"]]
    ]
    tool_calls: Optional[
        List[Optional["PromptConversationPromptConversationMessageToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class PromptConversationPromptConversationMessageCitations(BaseModel):
    content: Optional["PromptConversationPromptConversationMessageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class PromptConversationPromptConversationMessageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["PromptConversationPromptConversationMessageCitationsContentVideo"]
    audio: Optional["PromptConversationPromptConversationMessageCitationsContentAudio"]
    image: Optional["PromptConversationPromptConversationMessageCitationsContentImage"]
    document: Optional[
        "PromptConversationPromptConversationMessageCitationsContentDocument"
    ]


class PromptConversationPromptConversationMessageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class PromptConversationPromptConversationMessageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class PromptConversationPromptConversationMessageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class PromptConversationPromptConversationMessageCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class PromptConversationPromptConversationMessageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


class PromptConversationPromptConversationFacets(BaseModel):
    type: Optional[FacetValueTypes]
    value: Optional[str]
    range: Optional["PromptConversationPromptConversationFacetsRange"]
    count: Optional[Any]
    facet: Optional[ContentFacetTypes]
    observable: Optional["PromptConversationPromptConversationFacetsObservable"]


class PromptConversationPromptConversationFacetsRange(BaseModel):
    from_: Optional[str] = Field(alias="from")
    to: Optional[str]


class PromptConversationPromptConversationFacetsObservable(BaseModel):
    type: Optional[ObservableTypes]
    observable: Optional[
        "PromptConversationPromptConversationFacetsObservableObservable"
    ]


class PromptConversationPromptConversationFacetsObservableObservable(BaseModel):
    id: str
    name: Optional[str]


class PromptConversationPromptConversationGraph(BaseModel):
    nodes: Optional[List[Optional["PromptConversationPromptConversationGraphNodes"]]]
    edges: Optional[List[Optional["PromptConversationPromptConversationGraphEdges"]]]


class PromptConversationPromptConversationGraphNodes(BaseModel):
    id: str
    name: str
    type: EntityTypes
    metadata: Optional[str]


class PromptConversationPromptConversationGraphEdges(BaseModel):
    from_: str = Field(alias="from")
    to: str
    relation: Optional[str]


class PromptConversationPromptConversationDetails(BaseModel):
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    supports_tool_calling: Optional[bool] = Field(alias="supportsToolCalling")
    source_count: Optional[int] = Field(alias="sourceCount")
    observable_count: Optional[int] = Field(alias="observableCount")
    tool_count: Optional[int] = Field(alias="toolCount")
    rendered_source_count: Optional[int] = Field(alias="renderedSourceCount")
    rendered_observable_count: Optional[int] = Field(alias="renderedObservableCount")
    rendered_tool_count: Optional[int] = Field(alias="renderedToolCount")
    ranked_source_count: Optional[int] = Field(alias="rankedSourceCount")
    ranked_observable_count: Optional[int] = Field(alias="rankedObservableCount")
    ranked_tool_count: Optional[int] = Field(alias="rankedToolCount")
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    sources: Optional[str]
    formatted_sources: Optional[str] = Field(alias="formattedSources")
    formatted_observables: Optional[str] = Field(alias="formattedObservables")
    formatted_instructions: Optional[str] = Field(alias="formattedInstructions")
    formatted_tools: Optional[str] = Field(alias="formattedTools")
    specification: Optional[str]
    messages: Optional[
        List[Optional["PromptConversationPromptConversationDetailsMessages"]]
    ]


class PromptConversationPromptConversationDetailsMessages(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[Optional["PromptConversationPromptConversationDetailsMessagesCitations"]]
    ]
    tool_calls: Optional[
        List[Optional["PromptConversationPromptConversationDetailsMessagesToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class PromptConversationPromptConversationDetailsMessagesCitations(BaseModel):
    content: Optional[
        "PromptConversationPromptConversationDetailsMessagesCitationsContent"
    ]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class PromptConversationPromptConversationDetailsMessagesCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional[
        "PromptConversationPromptConversationDetailsMessagesCitationsContentVideo"
    ]
    audio: Optional[
        "PromptConversationPromptConversationDetailsMessagesCitationsContentAudio"
    ]
    image: Optional[
        "PromptConversationPromptConversationDetailsMessagesCitationsContentImage"
    ]
    document: Optional[
        "PromptConversationPromptConversationDetailsMessagesCitationsContentDocument"
    ]


class PromptConversationPromptConversationDetailsMessagesCitationsContentVideo(
    BaseModel
):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class PromptConversationPromptConversationDetailsMessagesCitationsContentAudio(
    BaseModel
):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class PromptConversationPromptConversationDetailsMessagesCitationsContentImage(
    BaseModel
):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class PromptConversationPromptConversationDetailsMessagesCitationsContentDocument(
    BaseModel
):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class PromptConversationPromptConversationDetailsMessagesToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


PromptConversation.model_rebuild()
PromptConversationPromptConversation.model_rebuild()
PromptConversationPromptConversationMessage.model_rebuild()
PromptConversationPromptConversationMessageCitations.model_rebuild()
PromptConversationPromptConversationMessageCitationsContent.model_rebuild()
PromptConversationPromptConversationFacets.model_rebuild()
PromptConversationPromptConversationFacetsObservable.model_rebuild()
PromptConversationPromptConversationGraph.model_rebuild()
PromptConversationPromptConversationDetails.model_rebuild()
PromptConversationPromptConversationDetailsMessages.model_rebuild()
PromptConversationPromptConversationDetailsMessagesCitations.model_rebuild()
PromptConversationPromptConversationDetailsMessagesCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/prompt_specifications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    OrientationTypes,
)


class PromptSpecifications(BaseModel):
    prompt_specifications: Optional[
        List[Optional["PromptSpecificationsPromptSpecifications"]]
    ] = Field(alias="promptSpecifications")


class PromptSpecificationsPromptSpecifications(BaseModel):
    specification: Optional["PromptSpecificationsPromptSpecificationsSpecification"]
    messages: Optional[
        List[Optional["PromptSpecificationsPromptSpecificationsMessages"]]
    ]
    error: Optional[str]


class PromptSpecificationsPromptSpecificationsSpecification(BaseModel):
    id: str


class PromptSpecificationsPromptSpecificationsMessages(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[Optional["PromptSpecificationsPromptSpecificationsMessagesCitations"]]
    ]
    tool_calls: Optional[
        List[Optional["PromptSpecificationsPromptSpecificationsMessagesToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class PromptSpecificationsPromptSpecificationsMessagesCitations(BaseModel):
    content: Optional[
        "PromptSpecificationsPromptSpecificationsMessagesCitationsContent"
    ]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class PromptSpecificationsPromptSpecificationsMessagesCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional[
        "PromptSpecificationsPromptSpecificationsMessagesCitationsContentVideo"
    ]
    audio: Optional[
        "PromptSpecificationsPromptSpecificationsMessagesCitationsContentAudio"
    ]
    image: Optional[
        "PromptSpecificationsPromptSpecificationsMessagesCitationsContentImage"
    ]
    document: Optional[
        "PromptSpecificationsPromptSpecificationsMessagesCitationsContentDocument"
    ]


class PromptSpecificationsPromptSpecificationsMessagesCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class PromptSpecificationsPromptSpecificationsMessagesCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class PromptSpecificationsPromptSpecificationsMessagesCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class PromptSpecificationsPromptSpecificationsMessagesCitationsContentDocument(
    BaseModel
):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class PromptSpecificationsPromptSpecificationsMessagesToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


PromptSpecifications.model_rebuild()
PromptSpecificationsPromptSpecifications.model_rebuild()
PromptSpecificationsPromptSpecificationsMessages.model_rebuild()
PromptSpecificationsPromptSpecificationsMessagesCitations.model_rebuild()
PromptSpecificationsPromptSpecificationsMessagesCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/publish_contents.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    OrientationTypes,
    TextTypes,
)


class PublishContents(BaseModel):
    publish_contents: Optional["PublishContentsPublishContents"] = Field(
        alias="publishContents"
    )


class PublishContentsPublishContents(BaseModel):
    contents: Optional[List[Optional["PublishContentsPublishContentsContents"]]]
    details: Optional["PublishContentsPublishContentsDetails"]


class PublishContentsPublishContentsContents(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    markdown: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["PublishContentsPublishContentsContentsVideo"]
    audio: Optional["PublishContentsPublishContentsContentsAudio"]
    image: Optional["PublishContentsPublishContentsContentsImage"]
    document: Optional["PublishContentsPublishContentsContentsDocument"]


class PublishContentsPublishContentsContentsVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class PublishContentsPublishContentsContentsAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class PublishContentsPublishContentsContentsImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class PublishContentsPublishContentsContentsDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class PublishContentsPublishContentsDetails(BaseModel):
    contents: Optional[List["PublishContentsPublishContentsDetailsContents"]]
    summaries: Optional[List[str]]
    text: Optional[str]
    text_type: Optional[TextTypes] = Field(alias="textType")
    summary_specification: Optional[str] = Field(alias="summarySpecification")
    publish_specification: Optional[str] = Field(alias="publishSpecification")
    summary_time: Optional[Any] = Field(alias="summaryTime")
    publish_time: Optional[Any] = Field(alias="publishTime")


class PublishContentsPublishContentsDetailsContents(BaseModel):
    id: str


PublishContents.model_rebuild()
PublishContentsPublishContents.model_rebuild()
PublishContentsPublishContentsContents.model_rebuild()
PublishContentsPublishContentsDetails.model_rebuild()



================================================
FILE: graphlit_api/publish_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    OrientationTypes,
    TextTypes,
)


class PublishConversation(BaseModel):
    publish_conversation: Optional["PublishConversationPublishConversation"] = Field(
        alias="publishConversation"
    )


class PublishConversationPublishConversation(BaseModel):
    contents: Optional[List[Optional["PublishConversationPublishConversationContents"]]]
    details: Optional["PublishConversationPublishConversationDetails"]


class PublishConversationPublishConversationContents(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    markdown: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["PublishConversationPublishConversationContentsVideo"]
    audio: Optional["PublishConversationPublishConversationContentsAudio"]
    image: Optional["PublishConversationPublishConversationContentsImage"]
    document: Optional["PublishConversationPublishConversationContentsDocument"]


class PublishConversationPublishConversationContentsVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class PublishConversationPublishConversationContentsAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class PublishConversationPublishConversationContentsImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class PublishConversationPublishConversationContentsDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class PublishConversationPublishConversationDetails(BaseModel):
    contents: Optional[List["PublishConversationPublishConversationDetailsContents"]]
    summaries: Optional[List[str]]
    text: Optional[str]
    text_type: Optional[TextTypes] = Field(alias="textType")
    summary_specification: Optional[str] = Field(alias="summarySpecification")
    publish_specification: Optional[str] = Field(alias="publishSpecification")
    summary_time: Optional[Any] = Field(alias="summaryTime")
    publish_time: Optional[Any] = Field(alias="publishTime")


class PublishConversationPublishConversationDetailsContents(BaseModel):
    id: str


PublishConversation.model_rebuild()
PublishConversationPublishConversation.model_rebuild()
PublishConversationPublishConversationContents.model_rebuild()
PublishConversationPublishConversationDetails.model_rebuild()



================================================
FILE: graphlit_api/publish_text.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    OrientationTypes,
    TextTypes,
)


class PublishText(BaseModel):
    publish_text: Optional["PublishTextPublishText"] = Field(alias="publishText")


class PublishTextPublishText(BaseModel):
    contents: Optional[List[Optional["PublishTextPublishTextContents"]]]
    details: Optional["PublishTextPublishTextDetails"]


class PublishTextPublishTextContents(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    markdown: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["PublishTextPublishTextContentsVideo"]
    audio: Optional["PublishTextPublishTextContentsAudio"]
    image: Optional["PublishTextPublishTextContentsImage"]
    document: Optional["PublishTextPublishTextContentsDocument"]


class PublishTextPublishTextContentsVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class PublishTextPublishTextContentsAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class PublishTextPublishTextContentsImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class PublishTextPublishTextContentsDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class PublishTextPublishTextDetails(BaseModel):
    contents: Optional[List["PublishTextPublishTextDetailsContents"]]
    summaries: Optional[List[str]]
    text: Optional[str]
    text_type: Optional[TextTypes] = Field(alias="textType")
    summary_specification: Optional[str] = Field(alias="summarySpecification")
    publish_specification: Optional[str] = Field(alias="publishSpecification")
    summary_time: Optional[Any] = Field(alias="summaryTime")
    publish_time: Optional[Any] = Field(alias="publishTime")


class PublishTextPublishTextDetailsContents(BaseModel):
    id: str


PublishText.model_rebuild()
PublishTextPublishText.model_rebuild()
PublishTextPublishTextContents.model_rebuild()
PublishTextPublishTextDetails.model_rebuild()



================================================
FILE: graphlit_api/query_alerts.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AlertTypes,
    ContentPublishingServiceTypes,
    ContentTypes,
    ElevenLabsModels,
    EntityState,
    FileTypes,
    IntegrationServiceTypes,
    ObservableTypes,
    OpenAIImageModels,
)


class QueryAlerts(BaseModel):
    alerts: Optional["QueryAlertsAlerts"]


class QueryAlertsAlerts(BaseModel):
    results: Optional[List[Optional["QueryAlertsAlertsResults"]]]


class QueryAlertsAlertsResults(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "QueryAlertsAlertsResultsOwner"
    state: EntityState
    correlation_id: Optional[str] = Field(alias="correlationId")
    type: AlertTypes
    summary_prompt: Optional[str] = Field(alias="summaryPrompt")
    publish_prompt: str = Field(alias="publishPrompt")
    filter: Optional["QueryAlertsAlertsResultsFilter"]
    integration: "QueryAlertsAlertsResultsIntegration"
    publishing: "QueryAlertsAlertsResultsPublishing"
    summary_specification: Optional["QueryAlertsAlertsResultsSummarySpecification"] = (
        Field(alias="summarySpecification")
    )
    publish_specification: Optional["QueryAlertsAlertsResultsPublishSpecification"] = (
        Field(alias="publishSpecification")
    )
    last_alert_date: Optional[Any] = Field(alias="lastAlertDate")


class QueryAlertsAlertsResultsOwner(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilter(BaseModel):
    date_range: Optional["QueryAlertsAlertsResultsFilterDateRange"] = Field(
        alias="dateRange"
    )
    in_last: Optional[Any] = Field(alias="inLast")
    creation_date_range: Optional["QueryAlertsAlertsResultsFilterCreationDateRange"] = (
        Field(alias="creationDateRange")
    )
    created_in_last: Optional[Any] = Field(alias="createdInLast")
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[Optional[FileTypes]]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    similar_contents: Optional[
        List["QueryAlertsAlertsResultsFilterSimilarContents"]
    ] = Field(alias="similarContents")
    contents: Optional[List["QueryAlertsAlertsResultsFilterContents"]]
    feeds: Optional[List["QueryAlertsAlertsResultsFilterFeeds"]]
    workflows: Optional[List["QueryAlertsAlertsResultsFilterWorkflows"]]
    collections: Optional[List["QueryAlertsAlertsResultsFilterCollections"]]
    users: Optional[List["QueryAlertsAlertsResultsFilterUsers"]]
    observations: Optional[List["QueryAlertsAlertsResultsFilterObservations"]]
    or_: Optional[List["QueryAlertsAlertsResultsFilterOr"]] = Field(alias="or")
    and_: Optional[List["QueryAlertsAlertsResultsFilterAnd"]] = Field(alias="and")


class QueryAlertsAlertsResultsFilterDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class QueryAlertsAlertsResultsFilterCreationDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class QueryAlertsAlertsResultsFilterSimilarContents(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterContents(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterFeeds(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterWorkflows(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterCollections(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterUsers(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterObservations(BaseModel):
    type: ObservableTypes
    observable: "QueryAlertsAlertsResultsFilterObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class QueryAlertsAlertsResultsFilterObservationsObservable(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterOr(BaseModel):
    feeds: Optional[List["QueryAlertsAlertsResultsFilterOrFeeds"]]
    workflows: Optional[List["QueryAlertsAlertsResultsFilterOrWorkflows"]]
    collections: Optional[List["QueryAlertsAlertsResultsFilterOrCollections"]]
    users: Optional[List["QueryAlertsAlertsResultsFilterOrUsers"]]
    observations: Optional[List["QueryAlertsAlertsResultsFilterOrObservations"]]


class QueryAlertsAlertsResultsFilterOrFeeds(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterOrWorkflows(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterOrCollections(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterOrUsers(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterOrObservations(BaseModel):
    type: ObservableTypes
    observable: "QueryAlertsAlertsResultsFilterOrObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class QueryAlertsAlertsResultsFilterOrObservationsObservable(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterAnd(BaseModel):
    feeds: Optional[List["QueryAlertsAlertsResultsFilterAndFeeds"]]
    workflows: Optional[List["QueryAlertsAlertsResultsFilterAndWorkflows"]]
    collections: Optional[List["QueryAlertsAlertsResultsFilterAndCollections"]]
    users: Optional[List["QueryAlertsAlertsResultsFilterAndUsers"]]
    observations: Optional[List["QueryAlertsAlertsResultsFilterAndObservations"]]


class QueryAlertsAlertsResultsFilterAndFeeds(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterAndWorkflows(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterAndCollections(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterAndUsers(BaseModel):
    id: str


class QueryAlertsAlertsResultsFilterAndObservations(BaseModel):
    type: ObservableTypes
    observable: "QueryAlertsAlertsResultsFilterAndObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class QueryAlertsAlertsResultsFilterAndObservationsObservable(BaseModel):
    id: str


class QueryAlertsAlertsResultsIntegration(BaseModel):
    type: IntegrationServiceTypes
    uri: Optional[str]
    slack: Optional["QueryAlertsAlertsResultsIntegrationSlack"]
    email: Optional["QueryAlertsAlertsResultsIntegrationEmail"]
    twitter: Optional["QueryAlertsAlertsResultsIntegrationTwitter"]


class QueryAlertsAlertsResultsIntegrationSlack(BaseModel):
    token: str
    channel: str


class QueryAlertsAlertsResultsIntegrationEmail(BaseModel):
    from_: str = Field(alias="from")
    subject: str
    to: List[str]


class QueryAlertsAlertsResultsIntegrationTwitter(BaseModel):
    consumer_key: str = Field(alias="consumerKey")
    consumer_secret: str = Field(alias="consumerSecret")
    access_token_key: str = Field(alias="accessTokenKey")
    access_token_secret: str = Field(alias="accessTokenSecret")


class QueryAlertsAlertsResultsPublishing(BaseModel):
    type: ContentPublishingServiceTypes
    eleven_labs: Optional["QueryAlertsAlertsResultsPublishingElevenLabs"] = Field(
        alias="elevenLabs"
    )
    open_ai_image: Optional["QueryAlertsAlertsResultsPublishingOpenAiImage"] = Field(
        alias="openAIImage"
    )


class QueryAlertsAlertsResultsPublishingElevenLabs(BaseModel):
    model: Optional[ElevenLabsModels]
    voice: Optional[str]


class QueryAlertsAlertsResultsPublishingOpenAiImage(BaseModel):
    model: Optional[OpenAIImageModels]
    count: Optional[int]
    seed: Optional["QueryAlertsAlertsResultsPublishingOpenAiImageSeed"]


class QueryAlertsAlertsResultsPublishingOpenAiImageSeed(BaseModel):
    id: str


class QueryAlertsAlertsResultsSummarySpecification(BaseModel):
    id: str


class QueryAlertsAlertsResultsPublishSpecification(BaseModel):
    id: str


QueryAlerts.model_rebuild()
QueryAlertsAlerts.model_rebuild()
QueryAlertsAlertsResults.model_rebuild()
QueryAlertsAlertsResultsFilter.model_rebuild()
QueryAlertsAlertsResultsFilterObservations.model_rebuild()
QueryAlertsAlertsResultsFilterOr.model_rebuild()
QueryAlertsAlertsResultsFilterOrObservations.model_rebuild()
QueryAlertsAlertsResultsFilterAnd.model_rebuild()
QueryAlertsAlertsResultsFilterAndObservations.model_rebuild()
QueryAlertsAlertsResultsIntegration.model_rebuild()
QueryAlertsAlertsResultsPublishing.model_rebuild()
QueryAlertsAlertsResultsPublishingOpenAiImage.model_rebuild()



================================================
FILE: graphlit_api/query_categories.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryCategories(BaseModel):
    categories: Optional["QueryCategoriesCategories"]


class QueryCategoriesCategories(BaseModel):
    results: Optional[List[Optional["QueryCategoriesCategoriesResults"]]]


class QueryCategoriesCategoriesResults(BaseModel):
    id: str
    name: str
    description: Optional[str]
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]


QueryCategories.model_rebuild()
QueryCategoriesCategories.model_rebuild()



================================================
FILE: graphlit_api/query_collections.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import CollectionTypes, EntityState


class QueryCollections(BaseModel):
    collections: Optional["QueryCollectionsCollections"]


class QueryCollectionsCollections(BaseModel):
    results: Optional[List[Optional["QueryCollectionsCollectionsResults"]]]


class QueryCollectionsCollectionsResults(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "QueryCollectionsCollectionsResultsOwner"
    state: EntityState
    type: Optional[CollectionTypes]
    contents: Optional[List[Optional["QueryCollectionsCollectionsResultsContents"]]]


class QueryCollectionsCollectionsResultsOwner(BaseModel):
    id: str


class QueryCollectionsCollectionsResultsContents(BaseModel):
    id: str
    name: str


QueryCollections.model_rebuild()
QueryCollectionsCollections.model_rebuild()
QueryCollectionsCollectionsResults.model_rebuild()



================================================
FILE: graphlit_api/query_contents.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    LinkTypes,
    MailImportance,
    MailPriority,
    MailSensitivity,
    ObservableTypes,
    OccurrenceTypes,
    OrientationTypes,
    TextRoles,
)


class QueryContents(BaseModel):
    contents: Optional["QueryContentsContents"]


class QueryContentsContents(BaseModel):
    results: Optional[List[Optional["QueryContentsContentsResults"]]]


class QueryContentsContentsResults(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "QueryContentsContentsResultsOwner"
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    finished_date: Optional[Any] = Field(alias="finishedDate")
    workflow_duration: Optional[Any] = Field(alias="workflowDuration")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    address: Optional["QueryContentsContentsResultsAddress"]
    location: Optional["QueryContentsContentsResultsLocation"]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["QueryContentsContentsResultsVideo"]
    audio: Optional["QueryContentsContentsResultsAudio"]
    image: Optional["QueryContentsContentsResultsImage"]
    document: Optional["QueryContentsContentsResultsDocument"]
    email: Optional["QueryContentsContentsResultsEmail"]
    issue: Optional["QueryContentsContentsResultsIssue"]
    package: Optional["QueryContentsContentsResultsPackage"]
    language: Optional["QueryContentsContentsResultsLanguage"]
    feed: Optional["QueryContentsContentsResultsFeed"]
    collections: Optional[List[Optional["QueryContentsContentsResultsCollections"]]]
    links: Optional[List["QueryContentsContentsResultsLinks"]]
    observations: Optional[List[Optional["QueryContentsContentsResultsObservations"]]]
    workflow: Optional["QueryContentsContentsResultsWorkflow"]
    pages: Optional[List["QueryContentsContentsResultsPages"]]
    segments: Optional[List["QueryContentsContentsResultsSegments"]]
    frames: Optional[List["QueryContentsContentsResultsFrames"]]
    error: Optional[str]


class QueryContentsContentsResultsOwner(BaseModel):
    id: str


class QueryContentsContentsResultsAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


class QueryContentsContentsResultsLocation(BaseModel):
    latitude: Optional[float]
    longitude: Optional[float]


class QueryContentsContentsResultsVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class QueryContentsContentsResultsAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class QueryContentsContentsResultsImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class QueryContentsContentsResultsDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class QueryContentsContentsResultsEmail(BaseModel):
    identifier: Optional[str]
    thread_identifier: Optional[str] = Field(alias="threadIdentifier")
    subject: Optional[str]
    labels: Optional[List[Optional[str]]]
    sensitivity: Optional[MailSensitivity]
    priority: Optional[MailPriority]
    importance: Optional[MailImportance]
    from_: Optional[List[Optional["QueryContentsContentsResultsEmailFrom"]]] = Field(
        alias="from"
    )
    to: Optional[List[Optional["QueryContentsContentsResultsEmailTo"]]]
    cc: Optional[List[Optional["QueryContentsContentsResultsEmailCc"]]]
    bcc: Optional[List[Optional["QueryContentsContentsResultsEmailBcc"]]]


class QueryContentsContentsResultsEmailFrom(BaseModel):
    name: Optional[str]
    email: Optional[str]
    given_name: Optional[str] = Field(alias="givenName")
    family_name: Optional[str] = Field(alias="familyName")


class QueryContentsContentsResultsEmailTo(BaseModel):
    name: Optional[str]
    email: Optional[str]
    given_name: Optional[str] = Field(alias="givenName")
    family_name: Optional[str] = Field(alias="familyName")


class QueryContentsContentsResultsEmailCc(BaseModel):
    name: Optional[str]
    email: Optional[str]
    given_name: Optional[str] = Field(alias="givenName")
    family_name: Optional[str] = Field(alias="familyName")


class QueryContentsContentsResultsEmailBcc(BaseModel):
    name: Optional[str]
    email: Optional[str]
    given_name: Optional[str] = Field(alias="givenName")
    family_name: Optional[str] = Field(alias="familyName")


class QueryContentsContentsResultsIssue(BaseModel):
    identifier: Optional[str]
    title: Optional[str]
    project: Optional[str]
    team: Optional[str]
    status: Optional[str]
    priority: Optional[str]
    type: Optional[str]
    labels: Optional[List[Optional[str]]]


class QueryContentsContentsResultsPackage(BaseModel):
    file_count: Optional[int] = Field(alias="fileCount")
    folder_count: Optional[int] = Field(alias="folderCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")


class QueryContentsContentsResultsLanguage(BaseModel):
    languages: Optional[List[Optional[str]]]


class QueryContentsContentsResultsFeed(BaseModel):
    id: str
    name: str


class QueryContentsContentsResultsCollections(BaseModel):
    id: str
    name: str


class QueryContentsContentsResultsLinks(BaseModel):
    uri: Optional[Any]
    link_type: Optional[LinkTypes] = Field(alias="linkType")


class QueryContentsContentsResultsObservations(BaseModel):
    id: str
    type: ObservableTypes
    observable: "QueryContentsContentsResultsObservationsObservable"
    related: Optional["QueryContentsContentsResultsObservationsRelated"]
    related_type: Optional[ObservableTypes] = Field(alias="relatedType")
    relation: Optional[str]
    occurrences: Optional[
        List[Optional["QueryContentsContentsResultsObservationsOccurrences"]]
    ]
    state: EntityState


class QueryContentsContentsResultsObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class QueryContentsContentsResultsObservationsRelated(BaseModel):
    id: str
    name: Optional[str]


class QueryContentsContentsResultsObservationsOccurrences(BaseModel):
    type: Optional[OccurrenceTypes]
    confidence: Optional[float]
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_index: Optional[int] = Field(alias="pageIndex")
    bounding_box: Optional[
        "QueryContentsContentsResultsObservationsOccurrencesBoundingBox"
    ] = Field(alias="boundingBox")


class QueryContentsContentsResultsObservationsOccurrencesBoundingBox(BaseModel):
    left: Optional[float]
    top: Optional[float]
    width: Optional[float]
    height: Optional[float]


class QueryContentsContentsResultsWorkflow(BaseModel):
    id: str
    name: str


class QueryContentsContentsResultsPages(BaseModel):
    index: Optional[int]
    text: Optional[str]
    relevance: Optional[float]
    images: Optional[List[Optional["QueryContentsContentsResultsPagesImages"]]]
    chunks: Optional[List[Optional["QueryContentsContentsResultsPagesChunks"]]]


class QueryContentsContentsResultsPagesImages(BaseModel):
    id: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    data: Optional[str]
    left: Optional[int]
    right: Optional[int]
    top: Optional[int]
    bottom: Optional[int]


class QueryContentsContentsResultsPagesChunks(BaseModel):
    index: Optional[int]
    page_index: Optional[int] = Field(alias="pageIndex")
    row_index: Optional[int] = Field(alias="rowIndex")
    column_index: Optional[int] = Field(alias="columnIndex")
    confidence: Optional[float]
    text: Optional[str]
    role: Optional[TextRoles]
    language: Optional[str]
    relevance: Optional[float]


class QueryContentsContentsResultsSegments(BaseModel):
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    text: Optional[str]
    relevance: Optional[float]


class QueryContentsContentsResultsFrames(BaseModel):
    index: Optional[int]
    description: Optional[str]
    text: Optional[str]
    relevance: Optional[float]


QueryContents.model_rebuild()
QueryContentsContents.model_rebuild()
QueryContentsContentsResults.model_rebuild()
QueryContentsContentsResultsEmail.model_rebuild()
QueryContentsContentsResultsObservations.model_rebuild()
QueryContentsContentsResultsObservationsOccurrences.model_rebuild()
QueryContentsContentsResultsPages.model_rebuild()



================================================
FILE: graphlit_api/query_contents_facets.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import ContentFacetTypes, FacetValueTypes, ObservableTypes


class QueryContentsFacets(BaseModel):
    contents: Optional["QueryContentsFacetsContents"]


class QueryContentsFacetsContents(BaseModel):
    facets: Optional[List[Optional["QueryContentsFacetsContentsFacets"]]]


class QueryContentsFacetsContentsFacets(BaseModel):
    facet: Optional[ContentFacetTypes]
    count: Optional[Any]
    type: Optional[FacetValueTypes]
    value: Optional[str]
    range: Optional["QueryContentsFacetsContentsFacetsRange"]
    observable: Optional["QueryContentsFacetsContentsFacetsObservable"]


class QueryContentsFacetsContentsFacetsRange(BaseModel):
    from_: Optional[str] = Field(alias="from")
    to: Optional[str]


class QueryContentsFacetsContentsFacetsObservable(BaseModel):
    type: Optional[ObservableTypes]
    observable: Optional["QueryContentsFacetsContentsFacetsObservableObservable"]


class QueryContentsFacetsContentsFacetsObservableObservable(BaseModel):
    id: str
    name: Optional[str]


QueryContentsFacets.model_rebuild()
QueryContentsFacetsContents.model_rebuild()
QueryContentsFacetsContentsFacets.model_rebuild()
QueryContentsFacetsContentsFacetsObservable.model_rebuild()



================================================
FILE: graphlit_api/query_contents_graph.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityTypes


class QueryContentsGraph(BaseModel):
    contents: Optional["QueryContentsGraphContents"]


class QueryContentsGraphContents(BaseModel):
    graph: Optional["QueryContentsGraphContentsGraph"]


class QueryContentsGraphContentsGraph(BaseModel):
    nodes: Optional[List[Optional["QueryContentsGraphContentsGraphNodes"]]]
    edges: Optional[List[Optional["QueryContentsGraphContentsGraphEdges"]]]


class QueryContentsGraphContentsGraphNodes(BaseModel):
    id: str
    name: str
    type: EntityTypes
    metadata: Optional[str]


class QueryContentsGraphContentsGraphEdges(BaseModel):
    from_: str = Field(alias="from")
    to: str
    relation: Optional[str]


QueryContentsGraph.model_rebuild()
QueryContentsGraphContents.model_rebuild()
QueryContentsGraphContentsGraph.model_rebuild()



================================================
FILE: graphlit_api/query_conversations.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    ConversationTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    ObservableTypes,
    OrientationTypes,
)


class QueryConversations(BaseModel):
    conversations: Optional["QueryConversationsConversations"]


class QueryConversationsConversations(BaseModel):
    results: Optional[List[Optional["QueryConversationsConversationsResults"]]]


class QueryConversationsConversationsResults(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "QueryConversationsConversationsResultsOwner"
    state: EntityState
    correlation_id: Optional[str] = Field(alias="correlationId")
    type: Optional[ConversationTypes]
    messages: Optional[List[Optional["QueryConversationsConversationsResultsMessages"]]]
    specification: Optional["QueryConversationsConversationsResultsSpecification"]
    fallbacks: Optional[
        List[Optional["QueryConversationsConversationsResultsFallbacks"]]
    ]
    filter: Optional["QueryConversationsConversationsResultsFilter"]
    augmented_filter: Optional[
        "QueryConversationsConversationsResultsAugmentedFilter"
    ] = Field(alias="augmentedFilter")


class QueryConversationsConversationsResultsOwner(BaseModel):
    id: str


class QueryConversationsConversationsResultsMessages(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[Optional["QueryConversationsConversationsResultsMessagesCitations"]]
    ]
    tool_calls: Optional[
        List[Optional["QueryConversationsConversationsResultsMessagesToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class QueryConversationsConversationsResultsMessagesCitations(BaseModel):
    content: Optional["QueryConversationsConversationsResultsMessagesCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class QueryConversationsConversationsResultsMessagesCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional[
        "QueryConversationsConversationsResultsMessagesCitationsContentVideo"
    ]
    audio: Optional[
        "QueryConversationsConversationsResultsMessagesCitationsContentAudio"
    ]
    image: Optional[
        "QueryConversationsConversationsResultsMessagesCitationsContentImage"
    ]
    document: Optional[
        "QueryConversationsConversationsResultsMessagesCitationsContentDocument"
    ]


class QueryConversationsConversationsResultsMessagesCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class QueryConversationsConversationsResultsMessagesCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class QueryConversationsConversationsResultsMessagesCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class QueryConversationsConversationsResultsMessagesCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class QueryConversationsConversationsResultsMessagesToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


class QueryConversationsConversationsResultsSpecification(BaseModel):
    id: str
    name: str


class QueryConversationsConversationsResultsFallbacks(BaseModel):
    id: str
    name: str


class QueryConversationsConversationsResultsFilter(BaseModel):
    date_range: Optional["QueryConversationsConversationsResultsFilterDateRange"] = (
        Field(alias="dateRange")
    )
    in_last: Optional[Any] = Field(alias="inLast")
    creation_date_range: Optional[
        "QueryConversationsConversationsResultsFilterCreationDateRange"
    ] = Field(alias="creationDateRange")
    created_in_last: Optional[Any] = Field(alias="createdInLast")
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[Optional[FileTypes]]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    similar_contents: Optional[
        List["QueryConversationsConversationsResultsFilterSimilarContents"]
    ] = Field(alias="similarContents")
    contents: Optional[List["QueryConversationsConversationsResultsFilterContents"]]
    feeds: Optional[List["QueryConversationsConversationsResultsFilterFeeds"]]
    workflows: Optional[List["QueryConversationsConversationsResultsFilterWorkflows"]]
    collections: Optional[
        List["QueryConversationsConversationsResultsFilterCollections"]
    ]
    users: Optional[List["QueryConversationsConversationsResultsFilterUsers"]]
    observations: Optional[
        List["QueryConversationsConversationsResultsFilterObservations"]
    ]
    or_: Optional[List["QueryConversationsConversationsResultsFilterOr"]] = Field(
        alias="or"
    )
    and_: Optional[List["QueryConversationsConversationsResultsFilterAnd"]] = Field(
        alias="and"
    )


class QueryConversationsConversationsResultsFilterDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class QueryConversationsConversationsResultsFilterCreationDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class QueryConversationsConversationsResultsFilterSimilarContents(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterContents(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterFeeds(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterWorkflows(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterCollections(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterUsers(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterObservations(BaseModel):
    type: ObservableTypes
    observable: "QueryConversationsConversationsResultsFilterObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class QueryConversationsConversationsResultsFilterObservationsObservable(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterOr(BaseModel):
    feeds: Optional[List["QueryConversationsConversationsResultsFilterOrFeeds"]]
    workflows: Optional[List["QueryConversationsConversationsResultsFilterOrWorkflows"]]
    collections: Optional[
        List["QueryConversationsConversationsResultsFilterOrCollections"]
    ]
    users: Optional[List["QueryConversationsConversationsResultsFilterOrUsers"]]
    observations: Optional[
        List["QueryConversationsConversationsResultsFilterOrObservations"]
    ]


class QueryConversationsConversationsResultsFilterOrFeeds(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterOrWorkflows(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterOrCollections(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterOrUsers(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterOrObservations(BaseModel):
    type: ObservableTypes
    observable: "QueryConversationsConversationsResultsFilterOrObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class QueryConversationsConversationsResultsFilterOrObservationsObservable(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterAnd(BaseModel):
    feeds: Optional[List["QueryConversationsConversationsResultsFilterAndFeeds"]]
    workflows: Optional[
        List["QueryConversationsConversationsResultsFilterAndWorkflows"]
    ]
    collections: Optional[
        List["QueryConversationsConversationsResultsFilterAndCollections"]
    ]
    users: Optional[List["QueryConversationsConversationsResultsFilterAndUsers"]]
    observations: Optional[
        List["QueryConversationsConversationsResultsFilterAndObservations"]
    ]


class QueryConversationsConversationsResultsFilterAndFeeds(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterAndWorkflows(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterAndCollections(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterAndUsers(BaseModel):
    id: str


class QueryConversationsConversationsResultsFilterAndObservations(BaseModel):
    type: ObservableTypes
    observable: "QueryConversationsConversationsResultsFilterAndObservationsObservable"
    states: Optional[List[Optional[EntityState]]]


class QueryConversationsConversationsResultsFilterAndObservationsObservable(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilter(BaseModel):
    date_range: Optional[
        "QueryConversationsConversationsResultsAugmentedFilterDateRange"
    ] = Field(alias="dateRange")
    in_last: Optional[Any] = Field(alias="inLast")
    creation_date_range: Optional[
        "QueryConversationsConversationsResultsAugmentedFilterCreationDateRange"
    ] = Field(alias="creationDateRange")
    created_in_last: Optional[Any] = Field(alias="createdInLast")
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[Optional[FileTypes]]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    similar_contents: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterSimilarContents"]
    ] = Field(alias="similarContents")
    contents: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterContents"]
    ]
    feeds: Optional[List["QueryConversationsConversationsResultsAugmentedFilterFeeds"]]
    workflows: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterWorkflows"]
    ]
    collections: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterCollections"]
    ]
    users: Optional[List["QueryConversationsConversationsResultsAugmentedFilterUsers"]]
    observations: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterObservations"]
    ]
    or_: Optional[List["QueryConversationsConversationsResultsAugmentedFilterOr"]] = (
        Field(alias="or")
    )
    and_: Optional[List["QueryConversationsConversationsResultsAugmentedFilterAnd"]] = (
        Field(alias="and")
    )


class QueryConversationsConversationsResultsAugmentedFilterDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class QueryConversationsConversationsResultsAugmentedFilterCreationDateRange(BaseModel):
    from_: Optional[Any] = Field(alias="from")
    to: Optional[Any]


class QueryConversationsConversationsResultsAugmentedFilterSimilarContents(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterContents(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterFeeds(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterWorkflows(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterCollections(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterUsers(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterObservations(BaseModel):
    type: ObservableTypes
    observable: (
        "QueryConversationsConversationsResultsAugmentedFilterObservationsObservable"
    )
    states: Optional[List[Optional[EntityState]]]


class QueryConversationsConversationsResultsAugmentedFilterObservationsObservable(
    BaseModel
):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterOr(BaseModel):
    feeds: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterOrFeeds"]
    ]
    workflows: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterOrWorkflows"]
    ]
    collections: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterOrCollections"]
    ]
    users: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterOrUsers"]
    ]
    observations: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterOrObservations"]
    ]


class QueryConversationsConversationsResultsAugmentedFilterOrFeeds(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterOrWorkflows(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterOrCollections(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterOrUsers(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterOrObservations(BaseModel):
    type: ObservableTypes
    observable: (
        "QueryConversationsConversationsResultsAugmentedFilterOrObservationsObservable"
    )
    states: Optional[List[Optional[EntityState]]]


class QueryConversationsConversationsResultsAugmentedFilterOrObservationsObservable(
    BaseModel
):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterAnd(BaseModel):
    feeds: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterAndFeeds"]
    ]
    workflows: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterAndWorkflows"]
    ]
    collections: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterAndCollections"]
    ]
    users: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterAndUsers"]
    ]
    observations: Optional[
        List["QueryConversationsConversationsResultsAugmentedFilterAndObservations"]
    ]


class QueryConversationsConversationsResultsAugmentedFilterAndFeeds(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterAndWorkflows(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterAndCollections(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterAndUsers(BaseModel):
    id: str


class QueryConversationsConversationsResultsAugmentedFilterAndObservations(BaseModel):
    type: ObservableTypes
    observable: (
        "QueryConversationsConversationsResultsAugmentedFilterAndObservationsObservable"
    )
    states: Optional[List[Optional[EntityState]]]


class QueryConversationsConversationsResultsAugmentedFilterAndObservationsObservable(
    BaseModel
):
    id: str


QueryConversations.model_rebuild()
QueryConversationsConversations.model_rebuild()
QueryConversationsConversationsResults.model_rebuild()
QueryConversationsConversationsResultsMessages.model_rebuild()
QueryConversationsConversationsResultsMessagesCitations.model_rebuild()
QueryConversationsConversationsResultsMessagesCitationsContent.model_rebuild()
QueryConversationsConversationsResultsFilter.model_rebuild()
QueryConversationsConversationsResultsFilterObservations.model_rebuild()
QueryConversationsConversationsResultsFilterOr.model_rebuild()
QueryConversationsConversationsResultsFilterOrObservations.model_rebuild()
QueryConversationsConversationsResultsFilterAnd.model_rebuild()
QueryConversationsConversationsResultsFilterAndObservations.model_rebuild()
QueryConversationsConversationsResultsAugmentedFilter.model_rebuild()
QueryConversationsConversationsResultsAugmentedFilterObservations.model_rebuild()
QueryConversationsConversationsResultsAugmentedFilterOr.model_rebuild()
QueryConversationsConversationsResultsAugmentedFilterOrObservations.model_rebuild()
QueryConversationsConversationsResultsAugmentedFilterAnd.model_rebuild()
QueryConversationsConversationsResultsAugmentedFilterAndObservations.model_rebuild()



================================================
FILE: graphlit_api/query_credits.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryCredits(BaseModel):
    credits: Optional["QueryCreditsCredits"]


class QueryCreditsCredits(BaseModel):
    correlation_id: Optional[str] = Field(alias="correlationId")
    owner_id: Optional[str] = Field(alias="ownerId")
    credits: Optional[Any]
    storage_ratio: Optional[Any] = Field(alias="storageRatio")
    compute_ratio: Optional[Any] = Field(alias="computeRatio")
    embedding_ratio: Optional[Any] = Field(alias="embeddingRatio")
    completion_ratio: Optional[Any] = Field(alias="completionRatio")
    generation_ratio: Optional[Any] = Field(alias="generationRatio")
    ingestion_ratio: Optional[Any] = Field(alias="ingestionRatio")
    indexing_ratio: Optional[Any] = Field(alias="indexingRatio")
    preparation_ratio: Optional[Any] = Field(alias="preparationRatio")
    extraction_ratio: Optional[Any] = Field(alias="extractionRatio")
    classification_ratio: Optional[Any] = Field(alias="classificationRatio")
    enrichment_ratio: Optional[Any] = Field(alias="enrichmentRatio")
    publishing_ratio: Optional[Any] = Field(alias="publishingRatio")
    search_ratio: Optional[Any] = Field(alias="searchRatio")
    conversation_ratio: Optional[Any] = Field(alias="conversationRatio")


QueryCredits.model_rebuild()



================================================
FILE: graphlit_api/query_events.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryEvents(BaseModel):
    events: Optional["QueryEventsEvents"]


class QueryEventsEvents(BaseModel):
    results: Optional[List[Optional["QueryEventsEventsResults"]]]


class QueryEventsEventsResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["QueryEventsEventsResultsAddress"]
    start_date: Optional[Any] = Field(alias="startDate")
    end_date: Optional[Any] = Field(alias="endDate")
    availability_start_date: Optional[Any] = Field(alias="availabilityStartDate")
    availability_end_date: Optional[Any] = Field(alias="availabilityEndDate")
    price: Optional[Any]
    min_price: Optional[Any] = Field(alias="minPrice")
    max_price: Optional[Any] = Field(alias="maxPrice")
    price_currency: Optional[str] = Field(alias="priceCurrency")
    is_accessible_for_free: Optional[bool] = Field(alias="isAccessibleForFree")
    typical_age_range: Optional[str] = Field(alias="typicalAgeRange")


class QueryEventsEventsResultsAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


QueryEvents.model_rebuild()
QueryEventsEvents.model_rebuild()
QueryEventsEventsResults.model_rebuild()



================================================
FILE: graphlit_api/query_feeds.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    EmailListingTypes,
    EntityState,
    FeedListingTypes,
    FeedServiceTypes,
    FeedTypes,
    GoogleDriveAuthenticationTypes,
    NotionTypes,
    SearchServiceTypes,
    SharePointAuthenticationTypes,
    SiteTypes,
    TimedPolicyRecurrenceTypes,
    TrelloTypes,
    TwitterListingTypes,
    YouTubeTypes,
)


class QueryFeeds(BaseModel):
    feeds: Optional["QueryFeedsFeeds"]


class QueryFeedsFeeds(BaseModel):
    results: Optional[List[Optional["QueryFeedsFeedsResults"]]]


class QueryFeedsFeedsResults(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "QueryFeedsFeedsResultsOwner"
    state: EntityState
    correlation_id: Optional[str] = Field(alias="correlationId")
    type: FeedTypes
    site: Optional["QueryFeedsFeedsResultsSite"]
    email: Optional["QueryFeedsFeedsResultsEmail"]
    issue: Optional["QueryFeedsFeedsResultsIssue"]
    rss: Optional["QueryFeedsFeedsResultsRss"]
    web: Optional["QueryFeedsFeedsResultsWeb"]
    search: Optional["QueryFeedsFeedsResultsSearch"]
    reddit: Optional["QueryFeedsFeedsResultsReddit"]
    notion: Optional["QueryFeedsFeedsResultsNotion"]
    intercom: Optional["QueryFeedsFeedsResultsIntercom"]
    zendesk: Optional["QueryFeedsFeedsResultsZendesk"]
    youtube: Optional["QueryFeedsFeedsResultsYoutube"]
    twitter: Optional["QueryFeedsFeedsResultsTwitter"]
    slack: Optional["QueryFeedsFeedsResultsSlack"]
    microsoft_teams: Optional["QueryFeedsFeedsResultsMicrosoftTeams"] = Field(
        alias="microsoftTeams"
    )
    discord: Optional["QueryFeedsFeedsResultsDiscord"]
    error: Optional[str]
    last_post_date: Optional[Any] = Field(alias="lastPostDate")
    last_read_date: Optional[Any] = Field(alias="lastReadDate")
    read_count: Optional[int] = Field(alias="readCount")
    workflow: Optional["QueryFeedsFeedsResultsWorkflow"]
    schedule_policy: Optional["QueryFeedsFeedsResultsSchedulePolicy"] = Field(
        alias="schedulePolicy"
    )


class QueryFeedsFeedsResultsOwner(BaseModel):
    id: str


class QueryFeedsFeedsResultsSite(BaseModel):
    site_type: SiteTypes = Field(alias="siteType")
    type: FeedServiceTypes
    is_recursive: Optional[bool] = Field(alias="isRecursive")
    s_3: Optional["QueryFeedsFeedsResultsSiteS3"] = Field(alias="s3")
    azure_blob: Optional["QueryFeedsFeedsResultsSiteAzureBlob"] = Field(
        alias="azureBlob"
    )
    azure_file: Optional["QueryFeedsFeedsResultsSiteAzureFile"] = Field(
        alias="azureFile"
    )
    google: Optional["QueryFeedsFeedsResultsSiteGoogle"]
    share_point: Optional["QueryFeedsFeedsResultsSiteSharePoint"] = Field(
        alias="sharePoint"
    )
    one_drive: Optional["QueryFeedsFeedsResultsSiteOneDrive"] = Field(alias="oneDrive")
    google_drive: Optional["QueryFeedsFeedsResultsSiteGoogleDrive"] = Field(
        alias="googleDrive"
    )
    dropbox: Optional["QueryFeedsFeedsResultsSiteDropbox"]
    box: Optional["QueryFeedsFeedsResultsSiteBox"]
    github: Optional["QueryFeedsFeedsResultsSiteGithub"]
    read_limit: Optional[int] = Field(alias="readLimit")


class QueryFeedsFeedsResultsSiteS3(BaseModel):
    access_key: Optional[str] = Field(alias="accessKey")
    secret_access_key: Optional[str] = Field(alias="secretAccessKey")
    bucket_name: Optional[str] = Field(alias="bucketName")
    prefix: Optional[str]
    region: Optional[str]


class QueryFeedsFeedsResultsSiteAzureBlob(BaseModel):
    storage_access_key: Optional[str] = Field(alias="storageAccessKey")
    account_name: Optional[str] = Field(alias="accountName")
    container_name: Optional[str] = Field(alias="containerName")
    prefix: Optional[str]


class QueryFeedsFeedsResultsSiteAzureFile(BaseModel):
    storage_access_key: Optional[str] = Field(alias="storageAccessKey")
    account_name: Optional[str] = Field(alias="accountName")
    share_name: Optional[str] = Field(alias="shareName")
    prefix: Optional[str]


class QueryFeedsFeedsResultsSiteGoogle(BaseModel):
    credentials: Optional[str]
    container_name: Optional[str] = Field(alias="containerName")
    prefix: Optional[str]


class QueryFeedsFeedsResultsSiteSharePoint(BaseModel):
    authentication_type: SharePointAuthenticationTypes = Field(
        alias="authenticationType"
    )
    account_name: str = Field(alias="accountName")
    library_id: str = Field(alias="libraryId")
    folder_id: Optional[str] = Field(alias="folderId")
    tenant_id: Optional[str] = Field(alias="tenantId")
    client_id: Optional[str] = Field(alias="clientId")
    client_secret: Optional[str] = Field(alias="clientSecret")
    refresh_token: Optional[str] = Field(alias="refreshToken")


class QueryFeedsFeedsResultsSiteOneDrive(BaseModel):
    folder_id: Optional[str] = Field(alias="folderId")
    files: Optional[List[Optional[str]]]
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")
    refresh_token: str = Field(alias="refreshToken")


class QueryFeedsFeedsResultsSiteGoogleDrive(BaseModel):
    authentication_type: Optional[GoogleDriveAuthenticationTypes] = Field(
        alias="authenticationType"
    )
    folder_id: Optional[str] = Field(alias="folderId")
    files: Optional[List[Optional[str]]]
    refresh_token: Optional[str] = Field(alias="refreshToken")
    client_id: Optional[str] = Field(alias="clientId")
    client_secret: Optional[str] = Field(alias="clientSecret")
    service_account_json: Optional[str] = Field(alias="serviceAccountJson")


class QueryFeedsFeedsResultsSiteDropbox(BaseModel):
    path: Optional[str]
    app_key: str = Field(alias="appKey")
    app_secret: str = Field(alias="appSecret")
    refresh_token: str = Field(alias="refreshToken")
    redirect_uri: str = Field(alias="redirectUri")


class QueryFeedsFeedsResultsSiteBox(BaseModel):
    folder_id: Optional[str] = Field(alias="folderId")
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")
    refresh_token: str = Field(alias="refreshToken")
    redirect_uri: str = Field(alias="redirectUri")


class QueryFeedsFeedsResultsSiteGithub(BaseModel):
    uri: Optional[Any]
    repository_owner: str = Field(alias="repositoryOwner")
    repository_name: str = Field(alias="repositoryName")
    refresh_token: Optional[str] = Field(alias="refreshToken")
    personal_access_token: Optional[str] = Field(alias="personalAccessToken")


class QueryFeedsFeedsResultsEmail(BaseModel):
    type: FeedServiceTypes
    include_attachments: Optional[bool] = Field(alias="includeAttachments")
    google: Optional["QueryFeedsFeedsResultsEmailGoogle"]
    microsoft: Optional["QueryFeedsFeedsResultsEmailMicrosoft"]
    read_limit: Optional[int] = Field(alias="readLimit")


class QueryFeedsFeedsResultsEmailGoogle(BaseModel):
    type: Optional[EmailListingTypes]
    include_spam: Optional[bool] = Field(alias="includeSpam")
    exclude_sent_items: Optional[bool] = Field(alias="excludeSentItems")
    include_deleted_items: Optional[bool] = Field(alias="includeDeletedItems")
    inbox_only: Optional[bool] = Field(alias="inboxOnly")
    refresh_token: Optional[str] = Field(alias="refreshToken")
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class QueryFeedsFeedsResultsEmailMicrosoft(BaseModel):
    type: Optional[EmailListingTypes]
    include_spam: Optional[bool] = Field(alias="includeSpam")
    exclude_sent_items: Optional[bool] = Field(alias="excludeSentItems")
    include_deleted_items: Optional[bool] = Field(alias="includeDeletedItems")
    inbox_only: Optional[bool] = Field(alias="inboxOnly")
    refresh_token: str = Field(alias="refreshToken")
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class QueryFeedsFeedsResultsIssue(BaseModel):
    type: FeedServiceTypes
    include_attachments: Optional[bool] = Field(alias="includeAttachments")
    jira: Optional["QueryFeedsFeedsResultsIssueJira"]
    linear: Optional["QueryFeedsFeedsResultsIssueLinear"]
    github: Optional["QueryFeedsFeedsResultsIssueGithub"]
    intercom: Optional["QueryFeedsFeedsResultsIssueIntercom"]
    zendesk: Optional["QueryFeedsFeedsResultsIssueZendesk"]
    trello: Optional["QueryFeedsFeedsResultsIssueTrello"]
    read_limit: Optional[int] = Field(alias="readLimit")


class QueryFeedsFeedsResultsIssueJira(BaseModel):
    uri: Any
    project: str
    email: str
    token: str
    offset: Optional[Any]


class QueryFeedsFeedsResultsIssueLinear(BaseModel):
    key: str
    project: str


class QueryFeedsFeedsResultsIssueGithub(BaseModel):
    uri: Optional[Any]
    repository_owner: str = Field(alias="repositoryOwner")
    repository_name: str = Field(alias="repositoryName")
    refresh_token: Optional[str] = Field(alias="refreshToken")
    personal_access_token: Optional[str] = Field(alias="personalAccessToken")


class QueryFeedsFeedsResultsIssueIntercom(BaseModel):
    access_token: str = Field(alias="accessToken")


class QueryFeedsFeedsResultsIssueZendesk(BaseModel):
    subdomain: str
    access_token: str = Field(alias="accessToken")


class QueryFeedsFeedsResultsIssueTrello(BaseModel):
    key: str
    token: str
    identifiers: List[str]
    type: TrelloTypes


class QueryFeedsFeedsResultsRss(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    uri: Any


class QueryFeedsFeedsResultsWeb(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    uri: Any
    include_files: Optional[bool] = Field(alias="includeFiles")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")


class QueryFeedsFeedsResultsSearch(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    type: Optional[SearchServiceTypes]
    text: str


class QueryFeedsFeedsResultsReddit(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    subreddit_name: str = Field(alias="subredditName")


class QueryFeedsFeedsResultsNotion(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    token: str
    identifiers: List[str]
    type: NotionTypes


class QueryFeedsFeedsResultsIntercom(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    access_token: str = Field(alias="accessToken")


class QueryFeedsFeedsResultsZendesk(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    subdomain: str
    access_token: str = Field(alias="accessToken")


class QueryFeedsFeedsResultsYoutube(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    type: YouTubeTypes
    video_name: Optional[str] = Field(alias="videoName")
    video_identifiers: Optional[List[str]] = Field(alias="videoIdentifiers")
    channel_identifier: Optional[str] = Field(alias="channelIdentifier")
    playlist_identifier: Optional[str] = Field(alias="playlistIdentifier")


class QueryFeedsFeedsResultsTwitter(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    token: str
    type: Optional[TwitterListingTypes]
    user_name: Optional[str] = Field(alias="userName")
    query: Optional[str]
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class QueryFeedsFeedsResultsSlack(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    type: Optional[FeedListingTypes]
    token: str
    channel: str
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class QueryFeedsFeedsResultsMicrosoftTeams(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    type: Optional[FeedListingTypes]
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")
    refresh_token: str = Field(alias="refreshToken")
    team_id: str = Field(alias="teamId")
    channel_id: str = Field(alias="channelId")


class QueryFeedsFeedsResultsDiscord(BaseModel):
    read_limit: Optional[int] = Field(alias="readLimit")
    type: Optional[FeedListingTypes]
    token: str
    channel: str
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class QueryFeedsFeedsResultsWorkflow(BaseModel):
    id: str
    name: str


class QueryFeedsFeedsResultsSchedulePolicy(BaseModel):
    recurrence_type: Optional[TimedPolicyRecurrenceTypes] = Field(
        alias="recurrenceType"
    )
    repeat_interval: Optional[Any] = Field(alias="repeatInterval")


QueryFeeds.model_rebuild()
QueryFeedsFeeds.model_rebuild()
QueryFeedsFeedsResults.model_rebuild()
QueryFeedsFeedsResultsSite.model_rebuild()
QueryFeedsFeedsResultsEmail.model_rebuild()
QueryFeedsFeedsResultsIssue.model_rebuild()



================================================
FILE: graphlit_api/query_labels.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryLabels(BaseModel):
    labels: Optional["QueryLabelsLabels"]


class QueryLabelsLabels(BaseModel):
    results: Optional[List[Optional["QueryLabelsLabelsResults"]]]


class QueryLabelsLabelsResults(BaseModel):
    id: str
    name: str
    description: Optional[str]
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]


QueryLabels.model_rebuild()
QueryLabelsLabels.model_rebuild()



================================================
FILE: graphlit_api/query_linear_projects.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryLinearProjects(BaseModel):
    linear_projects: Optional["QueryLinearProjectsLinearProjects"] = Field(
        alias="linearProjects"
    )


class QueryLinearProjectsLinearProjects(BaseModel):
    results: Optional[List[str]]


QueryLinearProjects.model_rebuild()



================================================
FILE: graphlit_api/query_medical_conditions.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalConditions(BaseModel):
    medical_conditions: Optional["QueryMedicalConditionsMedicalConditions"] = Field(
        alias="medicalConditions"
    )


class QueryMedicalConditionsMedicalConditions(BaseModel):
    results: Optional[List[Optional["QueryMedicalConditionsMedicalConditionsResults"]]]


class QueryMedicalConditionsMedicalConditionsResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryMedicalConditions.model_rebuild()
QueryMedicalConditionsMedicalConditions.model_rebuild()



================================================
FILE: graphlit_api/query_medical_contraindications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalContraindications(BaseModel):
    medical_contraindications: Optional[
        "QueryMedicalContraindicationsMedicalContraindications"
    ] = Field(alias="medicalContraindications")


class QueryMedicalContraindicationsMedicalContraindications(BaseModel):
    results: Optional[
        List[Optional["QueryMedicalContraindicationsMedicalContraindicationsResults"]]
    ]


class QueryMedicalContraindicationsMedicalContraindicationsResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryMedicalContraindications.model_rebuild()
QueryMedicalContraindicationsMedicalContraindications.model_rebuild()



================================================
FILE: graphlit_api/query_medical_devices.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalDevices(BaseModel):
    medical_devices: Optional["QueryMedicalDevicesMedicalDevices"] = Field(
        alias="medicalDevices"
    )


class QueryMedicalDevicesMedicalDevices(BaseModel):
    results: Optional[List[Optional["QueryMedicalDevicesMedicalDevicesResults"]]]


class QueryMedicalDevicesMedicalDevicesResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryMedicalDevices.model_rebuild()
QueryMedicalDevicesMedicalDevices.model_rebuild()



================================================
FILE: graphlit_api/query_medical_drug_classes.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalDrugClasses(BaseModel):
    medical_drug_classes: Optional["QueryMedicalDrugClassesMedicalDrugClasses"] = Field(
        alias="medicalDrugClasses"
    )


class QueryMedicalDrugClassesMedicalDrugClasses(BaseModel):
    results: Optional[
        List[Optional["QueryMedicalDrugClassesMedicalDrugClassesResults"]]
    ]


class QueryMedicalDrugClassesMedicalDrugClassesResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryMedicalDrugClasses.model_rebuild()
QueryMedicalDrugClassesMedicalDrugClasses.model_rebuild()



================================================
FILE: graphlit_api/query_medical_drugs.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalDrugs(BaseModel):
    medical_drugs: Optional["QueryMedicalDrugsMedicalDrugs"] = Field(
        alias="medicalDrugs"
    )


class QueryMedicalDrugsMedicalDrugs(BaseModel):
    results: Optional[List[Optional["QueryMedicalDrugsMedicalDrugsResults"]]]


class QueryMedicalDrugsMedicalDrugsResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryMedicalDrugs.model_rebuild()
QueryMedicalDrugsMedicalDrugs.model_rebuild()



================================================
FILE: graphlit_api/query_medical_guidelines.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalGuidelines(BaseModel):
    medical_guidelines: Optional["QueryMedicalGuidelinesMedicalGuidelines"] = Field(
        alias="medicalGuidelines"
    )


class QueryMedicalGuidelinesMedicalGuidelines(BaseModel):
    results: Optional[List[Optional["QueryMedicalGuidelinesMedicalGuidelinesResults"]]]


class QueryMedicalGuidelinesMedicalGuidelinesResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryMedicalGuidelines.model_rebuild()
QueryMedicalGuidelinesMedicalGuidelines.model_rebuild()



================================================
FILE: graphlit_api/query_medical_indications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalIndications(BaseModel):
    medical_indications: Optional["QueryMedicalIndicationsMedicalIndications"] = Field(
        alias="medicalIndications"
    )


class QueryMedicalIndicationsMedicalIndications(BaseModel):
    results: Optional[
        List[Optional["QueryMedicalIndicationsMedicalIndicationsResults"]]
    ]


class QueryMedicalIndicationsMedicalIndicationsResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryMedicalIndications.model_rebuild()
QueryMedicalIndicationsMedicalIndications.model_rebuild()



================================================
FILE: graphlit_api/query_medical_procedures.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalProcedures(BaseModel):
    medical_procedures: Optional["QueryMedicalProceduresMedicalProcedures"] = Field(
        alias="medicalProcedures"
    )


class QueryMedicalProceduresMedicalProcedures(BaseModel):
    results: Optional[List[Optional["QueryMedicalProceduresMedicalProceduresResults"]]]


class QueryMedicalProceduresMedicalProceduresResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryMedicalProcedures.model_rebuild()
QueryMedicalProceduresMedicalProcedures.model_rebuild()



================================================
FILE: graphlit_api/query_medical_studies.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalStudies(BaseModel):
    medical_studies: Optional["QueryMedicalStudiesMedicalStudies"] = Field(
        alias="medicalStudies"
    )


class QueryMedicalStudiesMedicalStudies(BaseModel):
    results: Optional[List[Optional["QueryMedicalStudiesMedicalStudiesResults"]]]


class QueryMedicalStudiesMedicalStudiesResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["QueryMedicalStudiesMedicalStudiesResultsAddress"]


class QueryMedicalStudiesMedicalStudiesResultsAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


QueryMedicalStudies.model_rebuild()
QueryMedicalStudiesMedicalStudies.model_rebuild()
QueryMedicalStudiesMedicalStudiesResults.model_rebuild()



================================================
FILE: graphlit_api/query_medical_tests.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalTests(BaseModel):
    medical_tests: Optional["QueryMedicalTestsMedicalTests"] = Field(
        alias="medicalTests"
    )


class QueryMedicalTestsMedicalTests(BaseModel):
    results: Optional[List[Optional["QueryMedicalTestsMedicalTestsResults"]]]


class QueryMedicalTestsMedicalTestsResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryMedicalTests.model_rebuild()
QueryMedicalTestsMedicalTests.model_rebuild()



================================================
FILE: graphlit_api/query_medical_therapies.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMedicalTherapies(BaseModel):
    medical_therapies: Optional["QueryMedicalTherapiesMedicalTherapies"] = Field(
        alias="medicalTherapies"
    )


class QueryMedicalTherapiesMedicalTherapies(BaseModel):
    results: Optional[List[Optional["QueryMedicalTherapiesMedicalTherapiesResults"]]]


class QueryMedicalTherapiesMedicalTherapiesResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryMedicalTherapies.model_rebuild()
QueryMedicalTherapiesMedicalTherapies.model_rebuild()



================================================
FILE: graphlit_api/query_microsoft_teams_channels.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMicrosoftTeamsChannels(BaseModel):
    microsoft_teams_channels: Optional[
        "QueryMicrosoftTeamsChannelsMicrosoftTeamsChannels"
    ] = Field(alias="microsoftTeamsChannels")


class QueryMicrosoftTeamsChannelsMicrosoftTeamsChannels(BaseModel):
    results: Optional[
        List[Optional["QueryMicrosoftTeamsChannelsMicrosoftTeamsChannelsResults"]]
    ]


class QueryMicrosoftTeamsChannelsMicrosoftTeamsChannelsResults(BaseModel):
    channel_name: Optional[str] = Field(alias="channelName")
    channel_id: Optional[str] = Field(alias="channelId")


QueryMicrosoftTeamsChannels.model_rebuild()
QueryMicrosoftTeamsChannelsMicrosoftTeamsChannels.model_rebuild()



================================================
FILE: graphlit_api/query_microsoft_teams_teams.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryMicrosoftTeamsTeams(BaseModel):
    microsoft_teams_teams: Optional["QueryMicrosoftTeamsTeamsMicrosoftTeamsTeams"] = (
        Field(alias="microsoftTeamsTeams")
    )


class QueryMicrosoftTeamsTeamsMicrosoftTeamsTeams(BaseModel):
    results: Optional[
        List[Optional["QueryMicrosoftTeamsTeamsMicrosoftTeamsTeamsResults"]]
    ]


class QueryMicrosoftTeamsTeamsMicrosoftTeamsTeamsResults(BaseModel):
    team_name: Optional[str] = Field(alias="teamName")
    team_id: Optional[str] = Field(alias="teamId")


QueryMicrosoftTeamsTeams.model_rebuild()
QueryMicrosoftTeamsTeamsMicrosoftTeamsTeams.model_rebuild()



================================================
FILE: graphlit_api/query_models.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import ModelServiceTypes, ModelTypes


class QueryModels(BaseModel):
    models: Optional["QueryModelsModels"]


class QueryModelsModels(BaseModel):
    results: Optional[List["QueryModelsModelsResults"]]


class QueryModelsModelsResults(BaseModel):
    uri: Optional[Any]
    name: str
    type: Optional[ModelTypes]
    service_type: Optional[ModelServiceTypes] = Field(alias="serviceType")
    model: Optional[str]
    model_type: Optional[str] = Field(alias="modelType")
    description: Optional[str]
    available_on: Optional[List[Optional[str]]] = Field(alias="availableOn")
    features: Optional["QueryModelsModelsResultsFeatures"]
    metadata: Optional["QueryModelsModelsResultsMetadata"]


class QueryModelsModelsResultsFeatures(BaseModel):
    key_features: Optional[List[Optional[str]]] = Field(alias="keyFeatures")
    strengths: Optional[List[Optional[str]]]
    use_cases: Optional[List[Optional[str]]] = Field(alias="useCases")


class QueryModelsModelsResultsMetadata(BaseModel):
    multilingual: Optional[bool]
    multimodal: Optional[bool]
    knowledge_cutoff: Optional[Any] = Field(alias="knowledgeCutoff")
    prompt_cost_per_million: Optional[float] = Field(alias="promptCostPerMillion")
    completion_cost_per_million: Optional[float] = Field(
        alias="completionCostPerMillion"
    )
    embeddings_cost_per_million: Optional[float] = Field(
        alias="embeddingsCostPerMillion"
    )
    reranking_cost_per_million: Optional[float] = Field(alias="rerankingCostPerMillion")
    context_window_tokens: Optional[int] = Field(alias="contextWindowTokens")
    max_output_tokens: Optional[int] = Field(alias="maxOutputTokens")


QueryModels.model_rebuild()
QueryModelsModels.model_rebuild()
QueryModelsModelsResults.model_rebuild()



================================================
FILE: graphlit_api/query_notion_databases.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryNotionDatabases(BaseModel):
    notion_databases: Optional["QueryNotionDatabasesNotionDatabases"] = Field(
        alias="notionDatabases"
    )


class QueryNotionDatabasesNotionDatabases(BaseModel):
    results: Optional[List[str]]


QueryNotionDatabases.model_rebuild()



================================================
FILE: graphlit_api/query_notion_pages.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryNotionPages(BaseModel):
    notion_pages: Optional["QueryNotionPagesNotionPages"] = Field(alias="notionPages")


class QueryNotionPagesNotionPages(BaseModel):
    results: Optional[List[str]]


QueryNotionPages.model_rebuild()



================================================
FILE: graphlit_api/query_one_drive_folders.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryOneDriveFolders(BaseModel):
    one_drive_folders: Optional["QueryOneDriveFoldersOneDriveFolders"] = Field(
        alias="oneDriveFolders"
    )


class QueryOneDriveFoldersOneDriveFolders(BaseModel):
    results: Optional[List[Optional["QueryOneDriveFoldersOneDriveFoldersResults"]]]


class QueryOneDriveFoldersOneDriveFoldersResults(BaseModel):
    folder_name: Optional[str] = Field(alias="folderName")
    folder_id: Optional[str] = Field(alias="folderId")


QueryOneDriveFolders.model_rebuild()
QueryOneDriveFoldersOneDriveFolders.model_rebuild()



================================================
FILE: graphlit_api/query_organizations.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryOrganizations(BaseModel):
    organizations: Optional["QueryOrganizationsOrganizations"]


class QueryOrganizationsOrganizations(BaseModel):
    results: Optional[List[Optional["QueryOrganizationsOrganizationsResults"]]]


class QueryOrganizationsOrganizationsResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["QueryOrganizationsOrganizationsResultsAddress"]
    founding_date: Optional[Any] = Field(alias="foundingDate")
    industries: Optional[List[Optional[str]]]
    revenue: Optional[Any]
    revenue_currency: Optional[str] = Field(alias="revenueCurrency")
    investment: Optional[Any]
    investment_currency: Optional[str] = Field(alias="investmentCurrency")


class QueryOrganizationsOrganizationsResultsAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


QueryOrganizations.model_rebuild()
QueryOrganizationsOrganizations.model_rebuild()
QueryOrganizationsOrganizationsResults.model_rebuild()



================================================
FILE: graphlit_api/query_persons.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryPersons(BaseModel):
    persons: Optional["QueryPersonsPersons"]


class QueryPersonsPersons(BaseModel):
    results: Optional[List[Optional["QueryPersonsPersonsResults"]]]


class QueryPersonsPersonsResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["QueryPersonsPersonsResultsAddress"]
    email: Optional[str]
    given_name: Optional[str] = Field(alias="givenName")
    family_name: Optional[str] = Field(alias="familyName")
    phone_number: Optional[str] = Field(alias="phoneNumber")
    birth_date: Optional[Any] = Field(alias="birthDate")
    title: Optional[str]
    occupation: Optional[str]
    education: Optional[str]


class QueryPersonsPersonsResultsAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


QueryPersons.model_rebuild()
QueryPersonsPersons.model_rebuild()
QueryPersonsPersonsResults.model_rebuild()



================================================
FILE: graphlit_api/query_places.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryPlaces(BaseModel):
    places: Optional["QueryPlacesPlaces"]


class QueryPlacesPlaces(BaseModel):
    results: Optional[List[Optional["QueryPlacesPlacesResults"]]]


class QueryPlacesPlacesResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["QueryPlacesPlacesResultsAddress"]


class QueryPlacesPlacesResultsAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


QueryPlaces.model_rebuild()
QueryPlacesPlaces.model_rebuild()
QueryPlacesPlacesResults.model_rebuild()



================================================
FILE: graphlit_api/query_products.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryProducts(BaseModel):
    products: Optional["QueryProductsProducts"]


class QueryProductsProducts(BaseModel):
    results: Optional[List[Optional["QueryProductsProductsResults"]]]


class QueryProductsProductsResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    address: Optional["QueryProductsProductsResultsAddress"]
    manufacturer: Optional[str]
    model: Optional[str]
    brand: Optional[str]
    upc: Optional[str]
    sku: Optional[str]
    release_date: Optional[Any] = Field(alias="releaseDate")
    production_date: Optional[Any] = Field(alias="productionDate")


class QueryProductsProductsResultsAddress(BaseModel):
    street_address: Optional[str] = Field(alias="streetAddress")
    city: Optional[str]
    region: Optional[str]
    country: Optional[str]
    postal_code: Optional[str] = Field(alias="postalCode")


QueryProducts.model_rebuild()
QueryProductsProducts.model_rebuild()
QueryProductsProductsResults.model_rebuild()



================================================
FILE: graphlit_api/query_repos.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryRepos(BaseModel):
    repos: Optional["QueryReposRepos"]


class QueryReposRepos(BaseModel):
    results: Optional[List[Optional["QueryReposReposResults"]]]


class QueryReposReposResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]


QueryRepos.model_rebuild()
QueryReposRepos.model_rebuild()



================================================
FILE: graphlit_api/query_share_point_folders.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class QuerySharePointFolders(BaseModel):
    share_point_folders: Optional["QuerySharePointFoldersSharePointFolders"] = Field(
        alias="sharePointFolders"
    )


class QuerySharePointFoldersSharePointFolders(BaseModel):
    account_name: Optional[str] = Field(alias="accountName")
    results: Optional[List[Optional["QuerySharePointFoldersSharePointFoldersResults"]]]


class QuerySharePointFoldersSharePointFoldersResults(BaseModel):
    folder_name: Optional[str] = Field(alias="folderName")
    folder_id: Optional[str] = Field(alias="folderId")


QuerySharePointFolders.model_rebuild()
QuerySharePointFoldersSharePointFolders.model_rebuild()



================================================
FILE: graphlit_api/query_share_point_libraries.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class QuerySharePointLibraries(BaseModel):
    share_point_libraries: Optional["QuerySharePointLibrariesSharePointLibraries"] = (
        Field(alias="sharePointLibraries")
    )


class QuerySharePointLibrariesSharePointLibraries(BaseModel):
    account_name: Optional[str] = Field(alias="accountName")
    results: Optional[
        List[Optional["QuerySharePointLibrariesSharePointLibrariesResults"]]
    ]


class QuerySharePointLibrariesSharePointLibrariesResults(BaseModel):
    library_name: Optional[str] = Field(alias="libraryName")
    library_id: Optional[str] = Field(alias="libraryId")
    site_name: Optional[str] = Field(alias="siteName")
    site_id: Optional[str] = Field(alias="siteId")


QuerySharePointLibraries.model_rebuild()
QuerySharePointLibrariesSharePointLibraries.model_rebuild()



================================================
FILE: graphlit_api/query_slack_channels.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class QuerySlackChannels(BaseModel):
    slack_channels: Optional["QuerySlackChannelsSlackChannels"] = Field(
        alias="slackChannels"
    )


class QuerySlackChannelsSlackChannels(BaseModel):
    results: Optional[List[str]]


QuerySlackChannels.model_rebuild()



================================================
FILE: graphlit_api/query_softwares.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class QuerySoftwares(BaseModel):
    softwares: Optional["QuerySoftwaresSoftwares"]


class QuerySoftwaresSoftwares(BaseModel):
    results: Optional[List[Optional["QuerySoftwaresSoftwaresResults"]]]


class QuerySoftwaresSoftwaresResults(BaseModel):
    id: str
    name: str
    alternate_names: Optional[List[Optional[str]]] = Field(alias="alternateNames")
    creation_date: Any = Field(alias="creationDate")
    uri: Optional[Any]
    description: Optional[str]
    identifier: Optional[str]
    thing: Optional[str]
    relevance: Optional[float]
    release_date: Optional[Any] = Field(alias="releaseDate")
    developer: Optional[str]


QuerySoftwares.model_rebuild()
QuerySoftwaresSoftwares.model_rebuild()



================================================
FILE: graphlit_api/query_specifications.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AnthropicModels,
    AzureOpenAIModels,
    BedrockModels,
    CerebrasModels,
    CohereModels,
    ConversationSearchTypes,
    ConversationStrategyTypes,
    DeepseekModels,
    EntityState,
    GoogleModels,
    GraphStrategyTypes,
    GroqModels,
    JinaModels,
    MistralModels,
    ModelServiceTypes,
    OpenAIModels,
    OpenAIReasoningEffortLevels,
    OpenAIVisionDetailLevels,
    PromptStrategyTypes,
    ReplicateModels,
    RerankingModelServiceTypes,
    RetrievalStrategyTypes,
    RevisionStrategyTypes,
    SpecificationTypes,
    VoyageModels,
)


class QuerySpecifications(BaseModel):
    specifications: Optional["QuerySpecificationsSpecifications"]


class QuerySpecificationsSpecifications(BaseModel):
    results: Optional[List[Optional["QuerySpecificationsSpecificationsResults"]]]


class QuerySpecificationsSpecificationsResults(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "QuerySpecificationsSpecificationsResultsOwner"
    state: EntityState
    type: Optional[SpecificationTypes]
    service_type: Optional[ModelServiceTypes] = Field(alias="serviceType")
    system_prompt: Optional[str] = Field(alias="systemPrompt")
    custom_guidance: Optional[str] = Field(alias="customGuidance")
    custom_instructions: Optional[str] = Field(alias="customInstructions")
    search_type: Optional[ConversationSearchTypes] = Field(alias="searchType")
    number_similar: Optional[int] = Field(alias="numberSimilar")
    strategy: Optional["QuerySpecificationsSpecificationsResultsStrategy"]
    prompt_strategy: Optional[
        "QuerySpecificationsSpecificationsResultsPromptStrategy"
    ] = Field(alias="promptStrategy")
    retrieval_strategy: Optional[
        "QuerySpecificationsSpecificationsResultsRetrievalStrategy"
    ] = Field(alias="retrievalStrategy")
    reranking_strategy: Optional[
        "QuerySpecificationsSpecificationsResultsRerankingStrategy"
    ] = Field(alias="rerankingStrategy")
    graph_strategy: Optional[
        "QuerySpecificationsSpecificationsResultsGraphStrategy"
    ] = Field(alias="graphStrategy")
    revision_strategy: Optional[
        "QuerySpecificationsSpecificationsResultsRevisionStrategy"
    ] = Field(alias="revisionStrategy")
    azure_ai: Optional["QuerySpecificationsSpecificationsResultsAzureAi"] = Field(
        alias="azureAI"
    )
    open_ai: Optional["QuerySpecificationsSpecificationsResultsOpenAi"] = Field(
        alias="openAI"
    )
    azure_open_ai: Optional["QuerySpecificationsSpecificationsResultsAzureOpenAi"] = (
        Field(alias="azureOpenAI")
    )
    cohere: Optional["QuerySpecificationsSpecificationsResultsCohere"]
    anthropic: Optional["QuerySpecificationsSpecificationsResultsAnthropic"]
    google: Optional["QuerySpecificationsSpecificationsResultsGoogle"]
    replicate: Optional["QuerySpecificationsSpecificationsResultsReplicate"]
    mistral: Optional["QuerySpecificationsSpecificationsResultsMistral"]
    bedrock: Optional["QuerySpecificationsSpecificationsResultsBedrock"]
    groq: Optional["QuerySpecificationsSpecificationsResultsGroq"]
    cerebras: Optional["QuerySpecificationsSpecificationsResultsCerebras"]
    deepseek: Optional["QuerySpecificationsSpecificationsResultsDeepseek"]
    jina: Optional["QuerySpecificationsSpecificationsResultsJina"]
    voyage: Optional["QuerySpecificationsSpecificationsResultsVoyage"]


class QuerySpecificationsSpecificationsResultsOwner(BaseModel):
    id: str


class QuerySpecificationsSpecificationsResultsStrategy(BaseModel):
    type: Optional[ConversationStrategyTypes]
    message_limit: Optional[int] = Field(alias="messageLimit")
    embed_citations: Optional[bool] = Field(alias="embedCitations")
    flatten_citations: Optional[bool] = Field(alias="flattenCitations")
    enable_facets: Optional[bool] = Field(alias="enableFacets")
    messages_weight: Optional[float] = Field(alias="messagesWeight")
    contents_weight: Optional[float] = Field(alias="contentsWeight")


class QuerySpecificationsSpecificationsResultsPromptStrategy(BaseModel):
    type: PromptStrategyTypes


class QuerySpecificationsSpecificationsResultsRetrievalStrategy(BaseModel):
    type: RetrievalStrategyTypes
    content_limit: Optional[int] = Field(alias="contentLimit")
    disable_fallback: Optional[bool] = Field(alias="disableFallback")


class QuerySpecificationsSpecificationsResultsRerankingStrategy(BaseModel):
    service_type: RerankingModelServiceTypes = Field(alias="serviceType")
    threshold: Optional[float]


class QuerySpecificationsSpecificationsResultsGraphStrategy(BaseModel):
    type: GraphStrategyTypes
    generate_graph: Optional[bool] = Field(alias="generateGraph")
    observable_limit: Optional[int] = Field(alias="observableLimit")


class QuerySpecificationsSpecificationsResultsRevisionStrategy(BaseModel):
    type: RevisionStrategyTypes
    custom_revision: Optional[str] = Field(alias="customRevision")
    count: Optional[int]


class QuerySpecificationsSpecificationsResultsAzureAi(BaseModel):
    token_limit: int = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    key: str
    endpoint: Any
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


class QuerySpecificationsSpecificationsResultsOpenAi(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: OpenAIModels
    key: Optional[str]
    endpoint: Optional[Any]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")
    detail_level: Optional[OpenAIVisionDetailLevels] = Field(alias="detailLevel")
    reasoning_effort: Optional[OpenAIReasoningEffortLevels] = Field(
        alias="reasoningEffort"
    )


class QuerySpecificationsSpecificationsResultsAzureOpenAi(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: AzureOpenAIModels
    key: Optional[str]
    endpoint: Optional[Any]
    deployment_name: Optional[str] = Field(alias="deploymentName")
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


class QuerySpecificationsSpecificationsResultsCohere(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: CohereModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


class QuerySpecificationsSpecificationsResultsAnthropic(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: AnthropicModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]
    enable_thinking: Optional[bool] = Field(alias="enableThinking")
    thinking_token_limit: Optional[int] = Field(alias="thinkingTokenLimit")


class QuerySpecificationsSpecificationsResultsGoogle(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: GoogleModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")
    enable_thinking: Optional[bool] = Field(alias="enableThinking")
    thinking_token_limit: Optional[int] = Field(alias="thinkingTokenLimit")


class QuerySpecificationsSpecificationsResultsReplicate(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: ReplicateModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]


class QuerySpecificationsSpecificationsResultsMistral(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: MistralModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    endpoint: Optional[Any]
    temperature: Optional[float]
    probability: Optional[float]
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


class QuerySpecificationsSpecificationsResultsBedrock(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: BedrockModels
    access_key: Optional[str] = Field(alias="accessKey")
    secret_access_key: Optional[str] = Field(alias="secretAccessKey")
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]


class QuerySpecificationsSpecificationsResultsGroq(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: GroqModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    endpoint: Optional[Any]
    temperature: Optional[float]
    probability: Optional[float]


class QuerySpecificationsSpecificationsResultsCerebras(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: CerebrasModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    endpoint: Optional[Any]
    temperature: Optional[float]
    probability: Optional[float]


class QuerySpecificationsSpecificationsResultsDeepseek(BaseModel):
    token_limit: Optional[int] = Field(alias="tokenLimit")
    completion_token_limit: Optional[int] = Field(alias="completionTokenLimit")
    model: DeepseekModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    temperature: Optional[float]
    probability: Optional[float]


class QuerySpecificationsSpecificationsResultsJina(BaseModel):
    model: JinaModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


class QuerySpecificationsSpecificationsResultsVoyage(BaseModel):
    model: VoyageModels
    key: Optional[str]
    model_name: Optional[str] = Field(alias="modelName")
    chunk_token_limit: Optional[int] = Field(alias="chunkTokenLimit")


QuerySpecifications.model_rebuild()
QuerySpecificationsSpecifications.model_rebuild()
QuerySpecificationsSpecificationsResults.model_rebuild()



================================================
FILE: graphlit_api/query_tokens.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class QueryTokens(BaseModel):
    tokens: Optional["QueryTokensTokens"]


class QueryTokensTokens(BaseModel):
    correlation_id: Optional[str] = Field(alias="correlationId")
    owner_id: Optional[str] = Field(alias="ownerId")
    embedding_input_tokens: Optional[int] = Field(alias="embeddingInputTokens")
    embedding_model_services: Optional[List[Optional[str]]] = Field(
        alias="embeddingModelServices"
    )
    completion_input_tokens: Optional[int] = Field(alias="completionInputTokens")
    completion_output_tokens: Optional[int] = Field(alias="completionOutputTokens")
    completion_model_services: Optional[List[Optional[str]]] = Field(
        alias="completionModelServices"
    )
    preparation_input_tokens: Optional[int] = Field(alias="preparationInputTokens")
    preparation_output_tokens: Optional[int] = Field(alias="preparationOutputTokens")
    preparation_model_services: Optional[List[Optional[str]]] = Field(
        alias="preparationModelServices"
    )
    extraction_input_tokens: Optional[int] = Field(alias="extractionInputTokens")
    extraction_output_tokens: Optional[int] = Field(alias="extractionOutputTokens")
    extraction_model_services: Optional[List[Optional[str]]] = Field(
        alias="extractionModelServices"
    )
    generation_input_tokens: Optional[int] = Field(alias="generationInputTokens")
    generation_output_tokens: Optional[int] = Field(alias="generationOutputTokens")
    generation_model_services: Optional[List[Optional[str]]] = Field(
        alias="generationModelServices"
    )


QueryTokens.model_rebuild()



================================================
FILE: graphlit_api/query_usage.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import BillableMetrics, ContentTypes, EntityTypes, FileTypes, OperationTypes


class QueryUsage(BaseModel):
    usage: Optional[List[Optional["QueryUsageUsage"]]]


class QueryUsageUsage(BaseModel):
    id: Optional[str]
    correlation_id: Optional[str] = Field(alias="correlationId")
    date: Any
    credits: Optional[Any]
    name: str
    metric: Optional[BillableMetrics]
    workflow: Optional[str]
    entity_type: Optional[EntityTypes] = Field(alias="entityType")
    entity_id: Optional[str] = Field(alias="entityId")
    project_id: str = Field(alias="projectId")
    owner_id: str = Field(alias="ownerId")
    uri: Optional[str]
    duration: Optional[Any]
    throughput: Optional[float]
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")
    model_service: Optional[str] = Field(alias="modelService")
    model_name: Optional[str] = Field(alias="modelName")
    processor_name: Optional[str] = Field(alias="processorName")
    prompt: Optional[str]
    prompt_tokens: Optional[int] = Field(alias="promptTokens")
    completion: Optional[str]
    completion_tokens: Optional[int] = Field(alias="completionTokens")
    tokens: Optional[int]
    count: Optional[int]
    operation: Optional[str]
    operation_type: Optional[OperationTypes] = Field(alias="operationType")
    request: Optional[str]
    variables: Optional[str]
    response: Optional[str]


QueryUsage.model_rebuild()



================================================
FILE: graphlit_api/query_users.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AuthenticationServiceTypes,
    ConnectorTypes,
    EntityState,
    IntegrationServiceTypes,
    UserTypes,
)


class QueryUsers(BaseModel):
    users: Optional["QueryUsersUsers"]


class QueryUsersUsers(BaseModel):
    results: Optional[List[Optional["QueryUsersUsersResults"]]]


class QueryUsersUsersResults(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "QueryUsersUsersResultsOwner"
    state: EntityState
    type: Optional[UserTypes]
    identifier: str
    connectors: Optional[List[Optional["QueryUsersUsersResultsConnectors"]]]


class QueryUsersUsersResultsOwner(BaseModel):
    id: str


class QueryUsersUsersResultsConnectors(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ConnectorTypes]
    authentication: Optional["QueryUsersUsersResultsConnectorsAuthentication"]
    integration: Optional["QueryUsersUsersResultsConnectorsIntegration"]


class QueryUsersUsersResultsConnectorsAuthentication(BaseModel):
    type: AuthenticationServiceTypes
    microsoft: Optional["QueryUsersUsersResultsConnectorsAuthenticationMicrosoft"]
    google: Optional["QueryUsersUsersResultsConnectorsAuthenticationGoogle"]


class QueryUsersUsersResultsConnectorsAuthenticationMicrosoft(BaseModel):
    tenant_id: str = Field(alias="tenantId")
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class QueryUsersUsersResultsConnectorsAuthenticationGoogle(BaseModel):
    client_id: str = Field(alias="clientId")
    client_secret: str = Field(alias="clientSecret")


class QueryUsersUsersResultsConnectorsIntegration(BaseModel):
    type: IntegrationServiceTypes
    uri: Optional[str]
    slack: Optional["QueryUsersUsersResultsConnectorsIntegrationSlack"]
    email: Optional["QueryUsersUsersResultsConnectorsIntegrationEmail"]
    twitter: Optional["QueryUsersUsersResultsConnectorsIntegrationTwitter"]


class QueryUsersUsersResultsConnectorsIntegrationSlack(BaseModel):
    token: str
    channel: str


class QueryUsersUsersResultsConnectorsIntegrationEmail(BaseModel):
    from_: str = Field(alias="from")
    subject: str
    to: List[str]


class QueryUsersUsersResultsConnectorsIntegrationTwitter(BaseModel):
    consumer_key: str = Field(alias="consumerKey")
    consumer_secret: str = Field(alias="consumerSecret")
    access_token_key: str = Field(alias="accessTokenKey")
    access_token_secret: str = Field(alias="accessTokenSecret")


QueryUsers.model_rebuild()
QueryUsersUsers.model_rebuild()
QueryUsersUsersResults.model_rebuild()
QueryUsersUsersResultsConnectors.model_rebuild()
QueryUsersUsersResultsConnectorsAuthentication.model_rebuild()
QueryUsersUsersResultsConnectorsIntegration.model_rebuild()



================================================
FILE: graphlit_api/query_workflows.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AssemblyAIModels,
    AzureDocumentIntelligenceModels,
    AzureDocumentIntelligenceVersions,
    ContentClassificationServiceTypes,
    ContentIndexingServiceTypes,
    ContentTypes,
    DeepgramModels,
    EntityEnrichmentServiceTypes,
    EntityExtractionServiceTypes,
    EntityState,
    FilePreparationServiceTypes,
    FileTypes,
    IntegrationServiceTypes,
    LinkTypes,
    ObservableTypes,
    RegexSourceTypes,
    StoragePolicyTypes,
    SummarizationTypes,
)


class QueryWorkflows(BaseModel):
    workflows: Optional["QueryWorkflowsWorkflows"]


class QueryWorkflowsWorkflows(BaseModel):
    results: Optional[List[Optional["QueryWorkflowsWorkflowsResults"]]]


class QueryWorkflowsWorkflowsResults(BaseModel):
    id: str
    name: str
    creation_date: Any = Field(alias="creationDate")
    relevance: Optional[float]
    owner: "QueryWorkflowsWorkflowsResultsOwner"
    state: EntityState
    ingestion: Optional["QueryWorkflowsWorkflowsResultsIngestion"]
    indexing: Optional["QueryWorkflowsWorkflowsResultsIndexing"]
    preparation: Optional["QueryWorkflowsWorkflowsResultsPreparation"]
    extraction: Optional["QueryWorkflowsWorkflowsResultsExtraction"]
    classification: Optional["QueryWorkflowsWorkflowsResultsClassification"]
    enrichment: Optional["QueryWorkflowsWorkflowsResultsEnrichment"]
    storage: Optional["QueryWorkflowsWorkflowsResultsStorage"]
    actions: Optional[List[Optional["QueryWorkflowsWorkflowsResultsActions"]]]


class QueryWorkflowsWorkflowsResultsOwner(BaseModel):
    id: str


class QueryWorkflowsWorkflowsResultsIngestion(BaseModel):
    if_: Optional["QueryWorkflowsWorkflowsResultsIngestionIf"] = Field(alias="if")
    collections: Optional[
        List[Optional["QueryWorkflowsWorkflowsResultsIngestionCollections"]]
    ]
    observations: Optional[
        List[Optional["QueryWorkflowsWorkflowsResultsIngestionObservations"]]
    ]
    enable_email_collections: Optional[bool] = Field(alias="enableEmailCollections")


class QueryWorkflowsWorkflowsResultsIngestionIf(BaseModel):
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")


class QueryWorkflowsWorkflowsResultsIngestionCollections(BaseModel):
    id: str


class QueryWorkflowsWorkflowsResultsIngestionObservations(BaseModel):
    type: ObservableTypes
    observable: "QueryWorkflowsWorkflowsResultsIngestionObservationsObservable"


class QueryWorkflowsWorkflowsResultsIngestionObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class QueryWorkflowsWorkflowsResultsIndexing(BaseModel):
    jobs: Optional[List[Optional["QueryWorkflowsWorkflowsResultsIndexingJobs"]]]


class QueryWorkflowsWorkflowsResultsIndexingJobs(BaseModel):
    connector: Optional["QueryWorkflowsWorkflowsResultsIndexingJobsConnector"]


class QueryWorkflowsWorkflowsResultsIndexingJobsConnector(BaseModel):
    type: Optional[ContentIndexingServiceTypes]
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")


class QueryWorkflowsWorkflowsResultsPreparation(BaseModel):
    enable_unblocked_capture: Optional[bool] = Field(alias="enableUnblockedCapture")
    disable_smart_capture: Optional[bool] = Field(alias="disableSmartCapture")
    summarizations: Optional[
        List[Optional["QueryWorkflowsWorkflowsResultsPreparationSummarizations"]]
    ]
    jobs: Optional[List[Optional["QueryWorkflowsWorkflowsResultsPreparationJobs"]]]


class QueryWorkflowsWorkflowsResultsPreparationSummarizations(BaseModel):
    type: SummarizationTypes
    specification: Optional[
        "QueryWorkflowsWorkflowsResultsPreparationSummarizationsSpecification"
    ]
    tokens: Optional[int]
    items: Optional[int]
    prompt: Optional[str]


class QueryWorkflowsWorkflowsResultsPreparationSummarizationsSpecification(BaseModel):
    id: str


class QueryWorkflowsWorkflowsResultsPreparationJobs(BaseModel):
    connector: Optional["QueryWorkflowsWorkflowsResultsPreparationJobsConnector"]


class QueryWorkflowsWorkflowsResultsPreparationJobsConnector(BaseModel):
    type: FilePreparationServiceTypes
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    azure_document: Optional[
        "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorAzureDocument"
    ] = Field(alias="azureDocument")
    deepgram: Optional["QueryWorkflowsWorkflowsResultsPreparationJobsConnectorDeepgram"]
    assembly_ai: Optional[
        "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorAssemblyAi"
    ] = Field(alias="assemblyAI")
    page: Optional["QueryWorkflowsWorkflowsResultsPreparationJobsConnectorPage"]
    document: Optional["QueryWorkflowsWorkflowsResultsPreparationJobsConnectorDocument"]
    email: Optional["QueryWorkflowsWorkflowsResultsPreparationJobsConnectorEmail"]
    model_document: Optional[
        "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorModelDocument"
    ] = Field(alias="modelDocument")
    mistral: Optional["QueryWorkflowsWorkflowsResultsPreparationJobsConnectorMistral"]


class QueryWorkflowsWorkflowsResultsPreparationJobsConnectorAzureDocument(BaseModel):
    version: Optional[AzureDocumentIntelligenceVersions]
    model: Optional[AzureDocumentIntelligenceModels]
    endpoint: Optional[Any]
    key: Optional[str]


class QueryWorkflowsWorkflowsResultsPreparationJobsConnectorDeepgram(BaseModel):
    model: Optional[DeepgramModels]
    key: Optional[str]
    enable_redaction: Optional[bool] = Field(alias="enableRedaction")
    enable_speaker_diarization: Optional[bool] = Field(alias="enableSpeakerDiarization")
    detect_language: Optional[bool] = Field(alias="detectLanguage")
    language: Optional[str]


class QueryWorkflowsWorkflowsResultsPreparationJobsConnectorAssemblyAi(BaseModel):
    model: Optional[AssemblyAIModels]
    key: Optional[str]
    enable_redaction: Optional[bool] = Field(alias="enableRedaction")
    enable_speaker_diarization: Optional[bool] = Field(alias="enableSpeakerDiarization")
    detect_language: Optional[bool] = Field(alias="detectLanguage")
    language: Optional[str]


class QueryWorkflowsWorkflowsResultsPreparationJobsConnectorPage(BaseModel):
    enable_screenshot: Optional[bool] = Field(alias="enableScreenshot")


class QueryWorkflowsWorkflowsResultsPreparationJobsConnectorDocument(BaseModel):
    include_images: Optional[bool] = Field(alias="includeImages")


class QueryWorkflowsWorkflowsResultsPreparationJobsConnectorEmail(BaseModel):
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class QueryWorkflowsWorkflowsResultsPreparationJobsConnectorModelDocument(BaseModel):
    specification: Optional[
        "QueryWorkflowsWorkflowsResultsPreparationJobsConnectorModelDocumentSpecification"
    ]


class QueryWorkflowsWorkflowsResultsPreparationJobsConnectorModelDocumentSpecification(
    BaseModel
):
    id: str


class QueryWorkflowsWorkflowsResultsPreparationJobsConnectorMistral(BaseModel):
    key: Optional[str]


class QueryWorkflowsWorkflowsResultsExtraction(BaseModel):
    jobs: Optional[List[Optional["QueryWorkflowsWorkflowsResultsExtractionJobs"]]]


class QueryWorkflowsWorkflowsResultsExtractionJobs(BaseModel):
    connector: Optional["QueryWorkflowsWorkflowsResultsExtractionJobsConnector"]


class QueryWorkflowsWorkflowsResultsExtractionJobsConnector(BaseModel):
    type: EntityExtractionServiceTypes
    content_types: Optional[List[ContentTypes]] = Field(alias="contentTypes")
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    extracted_types: Optional[List[ObservableTypes]] = Field(alias="extractedTypes")
    extracted_count: Optional[int] = Field(alias="extractedCount")
    azure_text: Optional[
        "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorAzureText"
    ] = Field(alias="azureText")
    azure_image: Optional[
        "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorAzureImage"
    ] = Field(alias="azureImage")
    model_image: Optional[
        "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelImage"
    ] = Field(alias="modelImage")
    model_text: Optional[
        "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelText"
    ] = Field(alias="modelText")


class QueryWorkflowsWorkflowsResultsExtractionJobsConnectorAzureText(BaseModel):
    confidence_threshold: Optional[float] = Field(alias="confidenceThreshold")
    enable_pii: Optional[bool] = Field(alias="enablePII")


class QueryWorkflowsWorkflowsResultsExtractionJobsConnectorAzureImage(BaseModel):
    confidence_threshold: Optional[float] = Field(alias="confidenceThreshold")


class QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelImage(BaseModel):
    specification: Optional[
        "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelImageSpecification"
    ]


class QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelImageSpecification(
    BaseModel
):
    id: str


class QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelText(BaseModel):
    specification: Optional[
        "QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelTextSpecification"
    ]


class QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelTextSpecification(
    BaseModel
):
    id: str


class QueryWorkflowsWorkflowsResultsClassification(BaseModel):
    jobs: Optional[List[Optional["QueryWorkflowsWorkflowsResultsClassificationJobs"]]]


class QueryWorkflowsWorkflowsResultsClassificationJobs(BaseModel):
    connector: Optional["QueryWorkflowsWorkflowsResultsClassificationJobsConnector"]


class QueryWorkflowsWorkflowsResultsClassificationJobsConnector(BaseModel):
    type: ContentClassificationServiceTypes
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")
    model: Optional["QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModel"]
    regex: Optional["QueryWorkflowsWorkflowsResultsClassificationJobsConnectorRegex"]


class QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModel(BaseModel):
    specification: Optional[
        "QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModelSpecification"
    ]
    rules: Optional[
        List[
            Optional[
                "QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModelRules"
            ]
        ]
    ]


class QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModelSpecification(
    BaseModel
):
    id: str


class QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModelRules(BaseModel):
    then: Optional[str]
    if_: Optional[str] = Field(alias="if")


class QueryWorkflowsWorkflowsResultsClassificationJobsConnectorRegex(BaseModel):
    rules: Optional[
        List[
            Optional[
                "QueryWorkflowsWorkflowsResultsClassificationJobsConnectorRegexRules"
            ]
        ]
    ]


class QueryWorkflowsWorkflowsResultsClassificationJobsConnectorRegexRules(BaseModel):
    then: Optional[str]
    type: Optional[RegexSourceTypes]
    path: Optional[str]
    matches: Optional[str]


class QueryWorkflowsWorkflowsResultsEnrichment(BaseModel):
    link: Optional["QueryWorkflowsWorkflowsResultsEnrichmentLink"]
    jobs: Optional[List[Optional["QueryWorkflowsWorkflowsResultsEnrichmentJobs"]]]


class QueryWorkflowsWorkflowsResultsEnrichmentLink(BaseModel):
    enable_crawling: Optional[bool] = Field(alias="enableCrawling")
    allowed_domains: Optional[List[str]] = Field(alias="allowedDomains")
    excluded_domains: Optional[List[str]] = Field(alias="excludedDomains")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")
    allowed_links: Optional[List[LinkTypes]] = Field(alias="allowedLinks")
    excluded_links: Optional[List[LinkTypes]] = Field(alias="excludedLinks")
    allowed_files: Optional[List[FileTypes]] = Field(alias="allowedFiles")
    excluded_files: Optional[List[FileTypes]] = Field(alias="excludedFiles")
    allow_content_domain: Optional[bool] = Field(alias="allowContentDomain")
    maximum_links: Optional[int] = Field(alias="maximumLinks")


class QueryWorkflowsWorkflowsResultsEnrichmentJobs(BaseModel):
    connector: Optional["QueryWorkflowsWorkflowsResultsEnrichmentJobsConnector"]


class QueryWorkflowsWorkflowsResultsEnrichmentJobsConnector(BaseModel):
    type: Optional[EntityEnrichmentServiceTypes]
    enriched_types: Optional[List[Optional[ObservableTypes]]] = Field(
        alias="enrichedTypes"
    )
    fhir: Optional["QueryWorkflowsWorkflowsResultsEnrichmentJobsConnectorFhir"]
    diffbot: Optional["QueryWorkflowsWorkflowsResultsEnrichmentJobsConnectorDiffbot"]


class QueryWorkflowsWorkflowsResultsEnrichmentJobsConnectorFhir(BaseModel):
    endpoint: Optional[Any]


class QueryWorkflowsWorkflowsResultsEnrichmentJobsConnectorDiffbot(BaseModel):
    key: Optional[Any]


class QueryWorkflowsWorkflowsResultsStorage(BaseModel):
    policy: Optional["QueryWorkflowsWorkflowsResultsStoragePolicy"]


class QueryWorkflowsWorkflowsResultsStoragePolicy(BaseModel):
    type: Optional[StoragePolicyTypes]
    allow_duplicates: Optional[bool] = Field(alias="allowDuplicates")


class QueryWorkflowsWorkflowsResultsActions(BaseModel):
    connector: Optional["QueryWorkflowsWorkflowsResultsActionsConnector"]


class QueryWorkflowsWorkflowsResultsActionsConnector(BaseModel):
    type: IntegrationServiceTypes
    uri: Optional[str]
    slack: Optional["QueryWorkflowsWorkflowsResultsActionsConnectorSlack"]
    email: Optional["QueryWorkflowsWorkflowsResultsActionsConnectorEmail"]
    twitter: Optional["QueryWorkflowsWorkflowsResultsActionsConnectorTwitter"]


class QueryWorkflowsWorkflowsResultsActionsConnectorSlack(BaseModel):
    token: str
    channel: str


class QueryWorkflowsWorkflowsResultsActionsConnectorEmail(BaseModel):
    from_: str = Field(alias="from")
    subject: str
    to: List[str]


class QueryWorkflowsWorkflowsResultsActionsConnectorTwitter(BaseModel):
    consumer_key: str = Field(alias="consumerKey")
    consumer_secret: str = Field(alias="consumerSecret")
    access_token_key: str = Field(alias="accessTokenKey")
    access_token_secret: str = Field(alias="accessTokenSecret")


QueryWorkflows.model_rebuild()
QueryWorkflowsWorkflows.model_rebuild()
QueryWorkflowsWorkflowsResults.model_rebuild()
QueryWorkflowsWorkflowsResultsIngestion.model_rebuild()
QueryWorkflowsWorkflowsResultsIngestionObservations.model_rebuild()
QueryWorkflowsWorkflowsResultsIndexing.model_rebuild()
QueryWorkflowsWorkflowsResultsIndexingJobs.model_rebuild()
QueryWorkflowsWorkflowsResultsPreparation.model_rebuild()
QueryWorkflowsWorkflowsResultsPreparationSummarizations.model_rebuild()
QueryWorkflowsWorkflowsResultsPreparationJobs.model_rebuild()
QueryWorkflowsWorkflowsResultsPreparationJobsConnector.model_rebuild()
QueryWorkflowsWorkflowsResultsPreparationJobsConnectorModelDocument.model_rebuild()
QueryWorkflowsWorkflowsResultsExtraction.model_rebuild()
QueryWorkflowsWorkflowsResultsExtractionJobs.model_rebuild()
QueryWorkflowsWorkflowsResultsExtractionJobsConnector.model_rebuild()
QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelImage.model_rebuild()
QueryWorkflowsWorkflowsResultsExtractionJobsConnectorModelText.model_rebuild()
QueryWorkflowsWorkflowsResultsClassification.model_rebuild()
QueryWorkflowsWorkflowsResultsClassificationJobs.model_rebuild()
QueryWorkflowsWorkflowsResultsClassificationJobsConnector.model_rebuild()
QueryWorkflowsWorkflowsResultsClassificationJobsConnectorModel.model_rebuild()
QueryWorkflowsWorkflowsResultsClassificationJobsConnectorRegex.model_rebuild()
QueryWorkflowsWorkflowsResultsEnrichment.model_rebuild()
QueryWorkflowsWorkflowsResultsEnrichmentJobs.model_rebuild()
QueryWorkflowsWorkflowsResultsEnrichmentJobsConnector.model_rebuild()
QueryWorkflowsWorkflowsResultsStorage.model_rebuild()
QueryWorkflowsWorkflowsResultsActions.model_rebuild()
QueryWorkflowsWorkflowsResultsActionsConnector.model_rebuild()



================================================
FILE: graphlit_api/remove_contents_from_collection.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import CollectionTypes, EntityState


class RemoveContentsFromCollection(BaseModel):
    remove_contents_from_collection: Optional[
        "RemoveContentsFromCollectionRemoveContentsFromCollection"
    ] = Field(alias="removeContentsFromCollection")


class RemoveContentsFromCollectionRemoveContentsFromCollection(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[CollectionTypes]
    contents: Optional[
        List[
            Optional["RemoveContentsFromCollectionRemoveContentsFromCollectionContents"]
        ]
    ]


class RemoveContentsFromCollectionRemoveContentsFromCollectionContents(BaseModel):
    id: str
    name: str


RemoveContentsFromCollection.model_rebuild()
RemoveContentsFromCollectionRemoveContentsFromCollection.model_rebuild()



================================================
FILE: graphlit_api/retrieve_sources.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import ContentSourceTypes


class RetrieveSources(BaseModel):
    retrieve_sources: Optional["RetrieveSourcesRetrieveSources"] = Field(
        alias="retrieveSources"
    )


class RetrieveSourcesRetrieveSources(BaseModel):
    results: Optional[List[Optional["RetrieveSourcesRetrieveSourcesResults"]]]


class RetrieveSourcesRetrieveSourcesResults(BaseModel):
    type: Optional[ContentSourceTypes]
    content: "RetrieveSourcesRetrieveSourcesResultsContent"
    text: str
    metadata: Optional[str]
    relevance: float
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class RetrieveSourcesRetrieveSourcesResultsContent(BaseModel):
    id: str


RetrieveSources.model_rebuild()
RetrieveSourcesRetrieveSources.model_rebuild()
RetrieveSourcesRetrieveSourcesResults.model_rebuild()



================================================
FILE: graphlit_api/revise_content.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    OrientationTypes,
)


class ReviseContent(BaseModel):
    revise_content: Optional["ReviseContentReviseContent"] = Field(
        alias="reviseContent"
    )


class ReviseContentReviseContent(BaseModel):
    conversation: Optional["ReviseContentReviseContentConversation"]
    message: Optional["ReviseContentReviseContentMessage"]
    message_count: Optional[int] = Field(alias="messageCount")


class ReviseContentReviseContentConversation(BaseModel):
    id: str


class ReviseContentReviseContentMessage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[List[Optional["ReviseContentReviseContentMessageCitations"]]]
    tool_calls: Optional[
        List[Optional["ReviseContentReviseContentMessageToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class ReviseContentReviseContentMessageCitations(BaseModel):
    content: Optional["ReviseContentReviseContentMessageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class ReviseContentReviseContentMessageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["ReviseContentReviseContentMessageCitationsContentVideo"]
    audio: Optional["ReviseContentReviseContentMessageCitationsContentAudio"]
    image: Optional["ReviseContentReviseContentMessageCitationsContentImage"]
    document: Optional["ReviseContentReviseContentMessageCitationsContentDocument"]


class ReviseContentReviseContentMessageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class ReviseContentReviseContentMessageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class ReviseContentReviseContentMessageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class ReviseContentReviseContentMessageCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class ReviseContentReviseContentMessageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


ReviseContent.model_rebuild()
ReviseContentReviseContent.model_rebuild()
ReviseContentReviseContentMessage.model_rebuild()
ReviseContentReviseContentMessageCitations.model_rebuild()
ReviseContentReviseContentMessageCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/revise_encoded_image.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    OrientationTypes,
)


class ReviseEncodedImage(BaseModel):
    revise_encoded_image: Optional["ReviseEncodedImageReviseEncodedImage"] = Field(
        alias="reviseEncodedImage"
    )


class ReviseEncodedImageReviseEncodedImage(BaseModel):
    conversation: Optional["ReviseEncodedImageReviseEncodedImageConversation"]
    message: Optional["ReviseEncodedImageReviseEncodedImageMessage"]
    message_count: Optional[int] = Field(alias="messageCount")


class ReviseEncodedImageReviseEncodedImageConversation(BaseModel):
    id: str


class ReviseEncodedImageReviseEncodedImageMessage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[
        List[Optional["ReviseEncodedImageReviseEncodedImageMessageCitations"]]
    ]
    tool_calls: Optional[
        List[Optional["ReviseEncodedImageReviseEncodedImageMessageToolCalls"]]
    ] = Field(alias="toolCalls")
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class ReviseEncodedImageReviseEncodedImageMessageCitations(BaseModel):
    content: Optional["ReviseEncodedImageReviseEncodedImageMessageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class ReviseEncodedImageReviseEncodedImageMessageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["ReviseEncodedImageReviseEncodedImageMessageCitationsContentVideo"]
    audio: Optional["ReviseEncodedImageReviseEncodedImageMessageCitationsContentAudio"]
    image: Optional["ReviseEncodedImageReviseEncodedImageMessageCitationsContentImage"]
    document: Optional[
        "ReviseEncodedImageReviseEncodedImageMessageCitationsContentDocument"
    ]


class ReviseEncodedImageReviseEncodedImageMessageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class ReviseEncodedImageReviseEncodedImageMessageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class ReviseEncodedImageReviseEncodedImageMessageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class ReviseEncodedImageReviseEncodedImageMessageCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class ReviseEncodedImageReviseEncodedImageMessageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


ReviseEncodedImage.model_rebuild()
ReviseEncodedImageReviseEncodedImage.model_rebuild()
ReviseEncodedImageReviseEncodedImageMessage.model_rebuild()
ReviseEncodedImageReviseEncodedImageMessageCitations.model_rebuild()
ReviseEncodedImageReviseEncodedImageMessageCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/revise_image.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    OrientationTypes,
)


class ReviseImage(BaseModel):
    revise_image: Optional["ReviseImageReviseImage"] = Field(alias="reviseImage")


class ReviseImageReviseImage(BaseModel):
    conversation: Optional["ReviseImageReviseImageConversation"]
    message: Optional["ReviseImageReviseImageMessage"]
    message_count: Optional[int] = Field(alias="messageCount")


class ReviseImageReviseImageConversation(BaseModel):
    id: str


class ReviseImageReviseImageMessage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[List[Optional["ReviseImageReviseImageMessageCitations"]]]
    tool_calls: Optional[List[Optional["ReviseImageReviseImageMessageToolCalls"]]] = (
        Field(alias="toolCalls")
    )
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class ReviseImageReviseImageMessageCitations(BaseModel):
    content: Optional["ReviseImageReviseImageMessageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class ReviseImageReviseImageMessageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["ReviseImageReviseImageMessageCitationsContentVideo"]
    audio: Optional["ReviseImageReviseImageMessageCitationsContentAudio"]
    image: Optional["ReviseImageReviseImageMessageCitationsContentImage"]
    document: Optional["ReviseImageReviseImageMessageCitationsContentDocument"]


class ReviseImageReviseImageMessageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class ReviseImageReviseImageMessageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class ReviseImageReviseImageMessageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class ReviseImageReviseImageMessageCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class ReviseImageReviseImageMessageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


ReviseImage.model_rebuild()
ReviseImageReviseImage.model_rebuild()
ReviseImageReviseImageMessage.model_rebuild()
ReviseImageReviseImageMessageCitations.model_rebuild()
ReviseImageReviseImageMessageCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/revise_text.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    ConversationRoleTypes,
    EntityState,
    FileTypes,
    ImageProjectionTypes,
    ModelServiceTypes,
    OrientationTypes,
)


class ReviseText(BaseModel):
    revise_text: Optional["ReviseTextReviseText"] = Field(alias="reviseText")


class ReviseTextReviseText(BaseModel):
    conversation: Optional["ReviseTextReviseTextConversation"]
    message: Optional["ReviseTextReviseTextMessage"]
    message_count: Optional[int] = Field(alias="messageCount")


class ReviseTextReviseTextConversation(BaseModel):
    id: str


class ReviseTextReviseTextMessage(BaseModel):
    role: ConversationRoleTypes
    author: Optional[str]
    message: Optional[str]
    citations: Optional[List[Optional["ReviseTextReviseTextMessageCitations"]]]
    tool_calls: Optional[List[Optional["ReviseTextReviseTextMessageToolCalls"]]] = (
        Field(alias="toolCalls")
    )
    tokens: Optional[int]
    throughput: Optional[float]
    completion_time: Optional[Any] = Field(alias="completionTime")
    timestamp: Optional[Any]
    model_service: Optional[ModelServiceTypes] = Field(alias="modelService")
    model: Optional[str]
    data: Optional[str]
    mime_type: Optional[str] = Field(alias="mimeType")
    tool_call_id: Optional[str] = Field(alias="toolCallId")
    tool_call_response: Optional[str] = Field(alias="toolCallResponse")


class ReviseTextReviseTextMessageCitations(BaseModel):
    content: Optional["ReviseTextReviseTextMessageCitationsContent"]
    index: Optional[int]
    text: str
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_number: Optional[int] = Field(alias="pageNumber")
    frame_number: Optional[int] = Field(alias="frameNumber")


class ReviseTextReviseTextMessageCitationsContent(BaseModel):
    id: str
    name: str
    state: EntityState
    original_date: Optional[Any] = Field(alias="originalDate")
    identifier: Optional[str]
    uri: Optional[Any]
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    format: Optional[str]
    format_name: Optional[str] = Field(alias="formatName")
    file_extension: Optional[str] = Field(alias="fileExtension")
    file_name: Optional[str] = Field(alias="fileName")
    file_size: Optional[Any] = Field(alias="fileSize")
    master_uri: Optional[Any] = Field(alias="masterUri")
    image_uri: Optional[Any] = Field(alias="imageUri")
    text_uri: Optional[Any] = Field(alias="textUri")
    audio_uri: Optional[Any] = Field(alias="audioUri")
    transcript_uri: Optional[Any] = Field(alias="transcriptUri")
    summary: Optional[str]
    custom_summary: Optional[str] = Field(alias="customSummary")
    keywords: Optional[List[str]]
    bullets: Optional[List[str]]
    headlines: Optional[List[str]]
    posts: Optional[List[str]]
    chapters: Optional[List[str]]
    questions: Optional[List[str]]
    video: Optional["ReviseTextReviseTextMessageCitationsContentVideo"]
    audio: Optional["ReviseTextReviseTextMessageCitationsContentAudio"]
    image: Optional["ReviseTextReviseTextMessageCitationsContentImage"]
    document: Optional["ReviseTextReviseTextMessageCitationsContentDocument"]


class ReviseTextReviseTextMessageCitationsContentVideo(BaseModel):
    width: Optional[int]
    height: Optional[int]
    duration: Optional[Any]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    title: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]


class ReviseTextReviseTextMessageCitationsContentAudio(BaseModel):
    keywords: Optional[List[Optional[str]]]
    author: Optional[str]
    series: Optional[str]
    episode: Optional[str]
    episode_type: Optional[str] = Field(alias="episodeType")
    season: Optional[str]
    publisher: Optional[str]
    copyright: Optional[str]
    genre: Optional[str]
    title: Optional[str]
    description: Optional[str]
    bitrate: Optional[int]
    channels: Optional[int]
    sample_rate: Optional[int] = Field(alias="sampleRate")
    bits_per_sample: Optional[int] = Field(alias="bitsPerSample")
    duration: Optional[Any]


class ReviseTextReviseTextMessageCitationsContentImage(BaseModel):
    width: Optional[int]
    height: Optional[int]
    resolution_x: Optional[int] = Field(alias="resolutionX")
    resolution_y: Optional[int] = Field(alias="resolutionY")
    bits_per_component: Optional[int] = Field(alias="bitsPerComponent")
    components: Optional[int]
    projection_type: Optional[ImageProjectionTypes] = Field(alias="projectionType")
    orientation: Optional[OrientationTypes]
    description: Optional[str]
    make: Optional[str]
    model: Optional[str]
    software: Optional[str]
    lens: Optional[str]
    focal_length: Optional[float] = Field(alias="focalLength")
    exposure_time: Optional[str] = Field(alias="exposureTime")
    f_number: Optional[str] = Field(alias="fNumber")
    iso: Optional[str]
    heading: Optional[float]
    pitch: Optional[float]


class ReviseTextReviseTextMessageCitationsContentDocument(BaseModel):
    title: Optional[str]
    subject: Optional[str]
    summary: Optional[str]
    author: Optional[str]
    publisher: Optional[str]
    description: Optional[str]
    keywords: Optional[List[Optional[str]]]
    page_count: Optional[int] = Field(alias="pageCount")
    worksheet_count: Optional[int] = Field(alias="worksheetCount")
    slide_count: Optional[int] = Field(alias="slideCount")
    word_count: Optional[int] = Field(alias="wordCount")
    line_count: Optional[int] = Field(alias="lineCount")
    paragraph_count: Optional[int] = Field(alias="paragraphCount")
    is_encrypted: Optional[bool] = Field(alias="isEncrypted")
    has_digital_signature: Optional[bool] = Field(alias="hasDigitalSignature")


class ReviseTextReviseTextMessageToolCalls(BaseModel):
    id: str
    name: str
    arguments: str


ReviseText.model_rebuild()
ReviseTextReviseText.model_rebuild()
ReviseTextReviseTextMessage.model_rebuild()
ReviseTextReviseTextMessageCitations.model_rebuild()
ReviseTextReviseTextMessageCitationsContent.model_rebuild()



================================================
FILE: graphlit_api/screenshot_page.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ObservableTypes,
    OccurrenceTypes,
)


class ScreenshotPage(BaseModel):
    screenshot_page: Optional["ScreenshotPageScreenshotPage"] = Field(
        alias="screenshotPage"
    )


class ScreenshotPageScreenshotPage(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    uri: Optional[Any]
    collections: Optional[List[Optional["ScreenshotPageScreenshotPageCollections"]]]
    observations: Optional[List[Optional["ScreenshotPageScreenshotPageObservations"]]]


class ScreenshotPageScreenshotPageCollections(BaseModel):
    id: str
    name: str


class ScreenshotPageScreenshotPageObservations(BaseModel):
    id: str
    type: ObservableTypes
    observable: "ScreenshotPageScreenshotPageObservationsObservable"
    related: Optional["ScreenshotPageScreenshotPageObservationsRelated"]
    related_type: Optional[ObservableTypes] = Field(alias="relatedType")
    relation: Optional[str]
    occurrences: Optional[
        List[Optional["ScreenshotPageScreenshotPageObservationsOccurrences"]]
    ]
    state: EntityState


class ScreenshotPageScreenshotPageObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class ScreenshotPageScreenshotPageObservationsRelated(BaseModel):
    id: str
    name: Optional[str]


class ScreenshotPageScreenshotPageObservationsOccurrences(BaseModel):
    type: Optional[OccurrenceTypes]
    confidence: Optional[float]
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_index: Optional[int] = Field(alias="pageIndex")
    bounding_box: Optional[
        "ScreenshotPageScreenshotPageObservationsOccurrencesBoundingBox"
    ] = Field(alias="boundingBox")


class ScreenshotPageScreenshotPageObservationsOccurrencesBoundingBox(BaseModel):
    left: Optional[float]
    top: Optional[float]
    width: Optional[float]
    height: Optional[float]


ScreenshotPage.model_rebuild()
ScreenshotPageScreenshotPage.model_rebuild()
ScreenshotPageScreenshotPageObservations.model_rebuild()
ScreenshotPageScreenshotPageObservationsOccurrences.model_rebuild()



================================================
FILE: graphlit_api/search_web.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel


class SearchWeb(BaseModel):
    search_web: Optional["SearchWebSearchWeb"] = Field(alias="searchWeb")


class SearchWebSearchWeb(BaseModel):
    results: Optional[List["SearchWebSearchWebResults"]]


class SearchWebSearchWebResults(BaseModel):
    uri: Any
    text: Optional[str]
    title: Optional[str]
    score: Optional[float]


SearchWeb.model_rebuild()
SearchWebSearchWeb.model_rebuild()



================================================
FILE: graphlit_api/send_notification.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class SendNotification(BaseModel):
    send_notification: Optional["SendNotificationSendNotification"] = Field(
        alias="sendNotification"
    )


class SendNotificationSendNotification(BaseModel):
    result: Optional[bool]


SendNotification.model_rebuild()



================================================
FILE: graphlit_api/specification_exists.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class SpecificationExists(BaseModel):
    specification_exists: Optional["SpecificationExistsSpecificationExists"] = Field(
        alias="specificationExists"
    )


class SpecificationExistsSpecificationExists(BaseModel):
    result: Optional[bool]


SpecificationExists.model_rebuild()



================================================
FILE: graphlit_api/suggest_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import List, Optional

from pydantic import Field

from .base_model import BaseModel


class SuggestConversation(BaseModel):
    suggest_conversation: Optional["SuggestConversationSuggestConversation"] = Field(
        alias="suggestConversation"
    )


class SuggestConversationSuggestConversation(BaseModel):
    prompts: Optional[List[Optional[str]]]


SuggestConversation.model_rebuild()



================================================
FILE: graphlit_api/summarize_contents.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import SummarizationTypes


class SummarizeContents(BaseModel):
    summarize_contents: Optional[
        List[Optional["SummarizeContentsSummarizeContents"]]
    ] = Field(alias="summarizeContents")


class SummarizeContentsSummarizeContents(BaseModel):
    specification: Optional["SummarizeContentsSummarizeContentsSpecification"]
    content: Optional["SummarizeContentsSummarizeContentsContent"]
    type: SummarizationTypes
    items: Optional[List["SummarizeContentsSummarizeContentsItems"]]
    error: Optional[str]


class SummarizeContentsSummarizeContentsSpecification(BaseModel):
    id: str


class SummarizeContentsSummarizeContentsContent(BaseModel):
    id: str


class SummarizeContentsSummarizeContentsItems(BaseModel):
    text: Optional[str]
    tokens: int
    summarization_time: Optional[Any] = Field(alias="summarizationTime")


SummarizeContents.model_rebuild()
SummarizeContentsSummarizeContents.model_rebuild()



================================================
FILE: graphlit_api/summarize_text.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import SummarizationTypes


class SummarizeText(BaseModel):
    summarize_text: Optional["SummarizeTextSummarizeText"] = Field(
        alias="summarizeText"
    )


class SummarizeTextSummarizeText(BaseModel):
    specification: Optional["SummarizeTextSummarizeTextSpecification"]
    content: Optional["SummarizeTextSummarizeTextContent"]
    type: SummarizationTypes
    items: Optional[List["SummarizeTextSummarizeTextItems"]]
    error: Optional[str]


class SummarizeTextSummarizeTextSpecification(BaseModel):
    id: str


class SummarizeTextSummarizeTextContent(BaseModel):
    id: str


class SummarizeTextSummarizeTextItems(BaseModel):
    text: Optional[str]
    tokens: int
    summarization_time: Optional[Any] = Field(alias="summarizationTime")


SummarizeText.model_rebuild()
SummarizeTextSummarizeText.model_rebuild()



================================================
FILE: graphlit_api/update_alert.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import AlertTypes, EntityState


class UpdateAlert(BaseModel):
    update_alert: Optional["UpdateAlertUpdateAlert"] = Field(alias="updateAlert")


class UpdateAlertUpdateAlert(BaseModel):
    id: str
    name: str
    state: EntityState
    type: AlertTypes


UpdateAlert.model_rebuild()



================================================
FILE: graphlit_api/update_category.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateCategory(BaseModel):
    update_category: Optional["UpdateCategoryUpdateCategory"] = Field(
        alias="updateCategory"
    )


class UpdateCategoryUpdateCategory(BaseModel):
    id: str
    name: str


UpdateCategory.model_rebuild()



================================================
FILE: graphlit_api/update_collection.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import CollectionTypes, EntityState


class UpdateCollection(BaseModel):
    update_collection: Optional["UpdateCollectionUpdateCollection"] = Field(
        alias="updateCollection"
    )


class UpdateCollectionUpdateCollection(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[CollectionTypes]


UpdateCollection.model_rebuild()



================================================
FILE: graphlit_api/update_content.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    ContentTypes,
    EntityState,
    FileTypes,
    ObservableTypes,
    OccurrenceTypes,
)


class UpdateContent(BaseModel):
    update_content: Optional["UpdateContentUpdateContent"] = Field(
        alias="updateContent"
    )


class UpdateContentUpdateContent(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ContentTypes]
    file_type: Optional[FileTypes] = Field(alias="fileType")
    mime_type: Optional[str] = Field(alias="mimeType")
    uri: Optional[Any]
    collections: Optional[List[Optional["UpdateContentUpdateContentCollections"]]]
    observations: Optional[List[Optional["UpdateContentUpdateContentObservations"]]]


class UpdateContentUpdateContentCollections(BaseModel):
    id: str
    name: str


class UpdateContentUpdateContentObservations(BaseModel):
    id: str
    type: ObservableTypes
    observable: "UpdateContentUpdateContentObservationsObservable"
    related: Optional["UpdateContentUpdateContentObservationsRelated"]
    related_type: Optional[ObservableTypes] = Field(alias="relatedType")
    relation: Optional[str]
    occurrences: Optional[
        List[Optional["UpdateContentUpdateContentObservationsOccurrences"]]
    ]
    state: EntityState


class UpdateContentUpdateContentObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class UpdateContentUpdateContentObservationsRelated(BaseModel):
    id: str
    name: Optional[str]


class UpdateContentUpdateContentObservationsOccurrences(BaseModel):
    type: Optional[OccurrenceTypes]
    confidence: Optional[float]
    start_time: Optional[Any] = Field(alias="startTime")
    end_time: Optional[Any] = Field(alias="endTime")
    page_index: Optional[int] = Field(alias="pageIndex")
    bounding_box: Optional[
        "UpdateContentUpdateContentObservationsOccurrencesBoundingBox"
    ] = Field(alias="boundingBox")


class UpdateContentUpdateContentObservationsOccurrencesBoundingBox(BaseModel):
    left: Optional[float]
    top: Optional[float]
    width: Optional[float]
    height: Optional[float]


UpdateContent.model_rebuild()
UpdateContentUpdateContent.model_rebuild()
UpdateContentUpdateContentObservations.model_rebuild()
UpdateContentUpdateContentObservationsOccurrences.model_rebuild()



================================================
FILE: graphlit_api/update_conversation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import ConversationTypes, EntityState


class UpdateConversation(BaseModel):
    update_conversation: Optional["UpdateConversationUpdateConversation"] = Field(
        alias="updateConversation"
    )


class UpdateConversationUpdateConversation(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[ConversationTypes]


UpdateConversation.model_rebuild()



================================================
FILE: graphlit_api/update_event.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateEvent(BaseModel):
    update_event: Optional["UpdateEventUpdateEvent"] = Field(alias="updateEvent")


class UpdateEventUpdateEvent(BaseModel):
    id: str
    name: str


UpdateEvent.model_rebuild()



================================================
FILE: graphlit_api/update_feed.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState, FeedTypes


class UpdateFeed(BaseModel):
    update_feed: Optional["UpdateFeedUpdateFeed"] = Field(alias="updateFeed")


class UpdateFeedUpdateFeed(BaseModel):
    id: str
    name: str
    state: EntityState
    type: FeedTypes


UpdateFeed.model_rebuild()



================================================
FILE: graphlit_api/update_label.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateLabel(BaseModel):
    update_label: Optional["UpdateLabelUpdateLabel"] = Field(alias="updateLabel")


class UpdateLabelUpdateLabel(BaseModel):
    id: str
    name: str


UpdateLabel.model_rebuild()



================================================
FILE: graphlit_api/update_medical_condition.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalCondition(BaseModel):
    update_medical_condition: Optional[
        "UpdateMedicalConditionUpdateMedicalCondition"
    ] = Field(alias="updateMedicalCondition")


class UpdateMedicalConditionUpdateMedicalCondition(BaseModel):
    id: str
    name: str


UpdateMedicalCondition.model_rebuild()



================================================
FILE: graphlit_api/update_medical_contraindication.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalContraindication(BaseModel):
    update_medical_contraindication: Optional[
        "UpdateMedicalContraindicationUpdateMedicalContraindication"
    ] = Field(alias="updateMedicalContraindication")


class UpdateMedicalContraindicationUpdateMedicalContraindication(BaseModel):
    id: str
    name: str


UpdateMedicalContraindication.model_rebuild()



================================================
FILE: graphlit_api/update_medical_device.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalDevice(BaseModel):
    update_medical_device: Optional["UpdateMedicalDeviceUpdateMedicalDevice"] = Field(
        alias="updateMedicalDevice"
    )


class UpdateMedicalDeviceUpdateMedicalDevice(BaseModel):
    id: str
    name: str


UpdateMedicalDevice.model_rebuild()



================================================
FILE: graphlit_api/update_medical_drug.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalDrug(BaseModel):
    update_medical_drug: Optional["UpdateMedicalDrugUpdateMedicalDrug"] = Field(
        alias="updateMedicalDrug"
    )


class UpdateMedicalDrugUpdateMedicalDrug(BaseModel):
    id: str
    name: str


UpdateMedicalDrug.model_rebuild()



================================================
FILE: graphlit_api/update_medical_drug_class.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalDrugClass(BaseModel):
    update_medical_drug_class: Optional[
        "UpdateMedicalDrugClassUpdateMedicalDrugClass"
    ] = Field(alias="updateMedicalDrugClass")


class UpdateMedicalDrugClassUpdateMedicalDrugClass(BaseModel):
    id: str
    name: str


UpdateMedicalDrugClass.model_rebuild()



================================================
FILE: graphlit_api/update_medical_guideline.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalGuideline(BaseModel):
    update_medical_guideline: Optional[
        "UpdateMedicalGuidelineUpdateMedicalGuideline"
    ] = Field(alias="updateMedicalGuideline")


class UpdateMedicalGuidelineUpdateMedicalGuideline(BaseModel):
    id: str
    name: str


UpdateMedicalGuideline.model_rebuild()



================================================
FILE: graphlit_api/update_medical_indication.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalIndication(BaseModel):
    update_medical_indication: Optional[
        "UpdateMedicalIndicationUpdateMedicalIndication"
    ] = Field(alias="updateMedicalIndication")


class UpdateMedicalIndicationUpdateMedicalIndication(BaseModel):
    id: str
    name: str


UpdateMedicalIndication.model_rebuild()



================================================
FILE: graphlit_api/update_medical_procedure.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalProcedure(BaseModel):
    update_medical_procedure: Optional[
        "UpdateMedicalProcedureUpdateMedicalProcedure"
    ] = Field(alias="updateMedicalProcedure")


class UpdateMedicalProcedureUpdateMedicalProcedure(BaseModel):
    id: str
    name: str


UpdateMedicalProcedure.model_rebuild()



================================================
FILE: graphlit_api/update_medical_study.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalStudy(BaseModel):
    update_medical_study: Optional["UpdateMedicalStudyUpdateMedicalStudy"] = Field(
        alias="updateMedicalStudy"
    )


class UpdateMedicalStudyUpdateMedicalStudy(BaseModel):
    id: str
    name: str


UpdateMedicalStudy.model_rebuild()



================================================
FILE: graphlit_api/update_medical_test.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalTest(BaseModel):
    update_medical_test: Optional["UpdateMedicalTestUpdateMedicalTest"] = Field(
        alias="updateMedicalTest"
    )


class UpdateMedicalTestUpdateMedicalTest(BaseModel):
    id: str
    name: str


UpdateMedicalTest.model_rebuild()



================================================
FILE: graphlit_api/update_medical_therapy.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateMedicalTherapy(BaseModel):
    update_medical_therapy: Optional["UpdateMedicalTherapyUpdateMedicalTherapy"] = (
        Field(alias="updateMedicalTherapy")
    )


class UpdateMedicalTherapyUpdateMedicalTherapy(BaseModel):
    id: str
    name: str


UpdateMedicalTherapy.model_rebuild()



================================================
FILE: graphlit_api/update_observation.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState


class UpdateObservation(BaseModel):
    update_observation: Optional["UpdateObservationUpdateObservation"] = Field(
        alias="updateObservation"
    )


class UpdateObservationUpdateObservation(BaseModel):
    id: str
    state: EntityState


UpdateObservation.model_rebuild()



================================================
FILE: graphlit_api/update_organization.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateOrganization(BaseModel):
    update_organization: Optional["UpdateOrganizationUpdateOrganization"] = Field(
        alias="updateOrganization"
    )


class UpdateOrganizationUpdateOrganization(BaseModel):
    id: str
    name: str


UpdateOrganization.model_rebuild()



================================================
FILE: graphlit_api/update_person.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdatePerson(BaseModel):
    update_person: Optional["UpdatePersonUpdatePerson"] = Field(alias="updatePerson")


class UpdatePersonUpdatePerson(BaseModel):
    id: str
    name: str


UpdatePerson.model_rebuild()



================================================
FILE: graphlit_api/update_place.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdatePlace(BaseModel):
    update_place: Optional["UpdatePlaceUpdatePlace"] = Field(alias="updatePlace")


class UpdatePlaceUpdatePlace(BaseModel):
    id: str
    name: str


UpdatePlace.model_rebuild()



================================================
FILE: graphlit_api/update_product.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateProduct(BaseModel):
    update_product: Optional["UpdateProductUpdateProduct"] = Field(
        alias="updateProduct"
    )


class UpdateProductUpdateProduct(BaseModel):
    id: str
    name: str


UpdateProduct.model_rebuild()



================================================
FILE: graphlit_api/update_project.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateProject(BaseModel):
    update_project: Optional["UpdateProjectUpdateProject"] = Field(
        alias="updateProject"
    )


class UpdateProjectUpdateProject(BaseModel):
    id: str
    name: str


UpdateProject.model_rebuild()



================================================
FILE: graphlit_api/update_repo.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateRepo(BaseModel):
    update_repo: Optional["UpdateRepoUpdateRepo"] = Field(alias="updateRepo")


class UpdateRepoUpdateRepo(BaseModel):
    id: str
    name: str


UpdateRepo.model_rebuild()



================================================
FILE: graphlit_api/update_software.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpdateSoftware(BaseModel):
    update_software: Optional["UpdateSoftwareUpdateSoftware"] = Field(
        alias="updateSoftware"
    )


class UpdateSoftwareUpdateSoftware(BaseModel):
    id: str
    name: str


UpdateSoftware.model_rebuild()



================================================
FILE: graphlit_api/update_specification.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState, ModelServiceTypes, SpecificationTypes


class UpdateSpecification(BaseModel):
    update_specification: Optional["UpdateSpecificationUpdateSpecification"] = Field(
        alias="updateSpecification"
    )


class UpdateSpecificationUpdateSpecification(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[SpecificationTypes]
    service_type: Optional[ModelServiceTypes] = Field(alias="serviceType")


UpdateSpecification.model_rebuild()



================================================
FILE: graphlit_api/update_user.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState, UserTypes


class UpdateUser(BaseModel):
    update_user: Optional["UpdateUserUpdateUser"] = Field(alias="updateUser")


class UpdateUserUpdateUser(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[UserTypes]
    identifier: str


UpdateUser.model_rebuild()



================================================
FILE: graphlit_api/update_workflow.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AssemblyAIModels,
    AzureDocumentIntelligenceModels,
    AzureDocumentIntelligenceVersions,
    ContentClassificationServiceTypes,
    ContentIndexingServiceTypes,
    ContentTypes,
    DeepgramModels,
    EntityEnrichmentServiceTypes,
    EntityExtractionServiceTypes,
    EntityState,
    FilePreparationServiceTypes,
    FileTypes,
    IntegrationServiceTypes,
    LinkTypes,
    ObservableTypes,
    RegexSourceTypes,
    StoragePolicyTypes,
    SummarizationTypes,
)


class UpdateWorkflow(BaseModel):
    update_workflow: Optional["UpdateWorkflowUpdateWorkflow"] = Field(
        alias="updateWorkflow"
    )


class UpdateWorkflowUpdateWorkflow(BaseModel):
    id: str
    name: str
    state: EntityState
    ingestion: Optional["UpdateWorkflowUpdateWorkflowIngestion"]
    indexing: Optional["UpdateWorkflowUpdateWorkflowIndexing"]
    preparation: Optional["UpdateWorkflowUpdateWorkflowPreparation"]
    extraction: Optional["UpdateWorkflowUpdateWorkflowExtraction"]
    classification: Optional["UpdateWorkflowUpdateWorkflowClassification"]
    enrichment: Optional["UpdateWorkflowUpdateWorkflowEnrichment"]
    storage: Optional["UpdateWorkflowUpdateWorkflowStorage"]
    actions: Optional[List[Optional["UpdateWorkflowUpdateWorkflowActions"]]]


class UpdateWorkflowUpdateWorkflowIngestion(BaseModel):
    if_: Optional["UpdateWorkflowUpdateWorkflowIngestionIf"] = Field(alias="if")
    collections: Optional[
        List[Optional["UpdateWorkflowUpdateWorkflowIngestionCollections"]]
    ]
    observations: Optional[
        List[Optional["UpdateWorkflowUpdateWorkflowIngestionObservations"]]
    ]
    enable_email_collections: Optional[bool] = Field(alias="enableEmailCollections")


class UpdateWorkflowUpdateWorkflowIngestionIf(BaseModel):
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")


class UpdateWorkflowUpdateWorkflowIngestionCollections(BaseModel):
    id: str


class UpdateWorkflowUpdateWorkflowIngestionObservations(BaseModel):
    type: ObservableTypes
    observable: "UpdateWorkflowUpdateWorkflowIngestionObservationsObservable"


class UpdateWorkflowUpdateWorkflowIngestionObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class UpdateWorkflowUpdateWorkflowIndexing(BaseModel):
    jobs: Optional[List[Optional["UpdateWorkflowUpdateWorkflowIndexingJobs"]]]


class UpdateWorkflowUpdateWorkflowIndexingJobs(BaseModel):
    connector: Optional["UpdateWorkflowUpdateWorkflowIndexingJobsConnector"]


class UpdateWorkflowUpdateWorkflowIndexingJobsConnector(BaseModel):
    type: Optional[ContentIndexingServiceTypes]
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")


class UpdateWorkflowUpdateWorkflowPreparation(BaseModel):
    enable_unblocked_capture: Optional[bool] = Field(alias="enableUnblockedCapture")
    disable_smart_capture: Optional[bool] = Field(alias="disableSmartCapture")
    summarizations: Optional[
        List[Optional["UpdateWorkflowUpdateWorkflowPreparationSummarizations"]]
    ]
    jobs: Optional[List[Optional["UpdateWorkflowUpdateWorkflowPreparationJobs"]]]


class UpdateWorkflowUpdateWorkflowPreparationSummarizations(BaseModel):
    type: SummarizationTypes
    specification: Optional[
        "UpdateWorkflowUpdateWorkflowPreparationSummarizationsSpecification"
    ]
    tokens: Optional[int]
    items: Optional[int]
    prompt: Optional[str]


class UpdateWorkflowUpdateWorkflowPreparationSummarizationsSpecification(BaseModel):
    id: str


class UpdateWorkflowUpdateWorkflowPreparationJobs(BaseModel):
    connector: Optional["UpdateWorkflowUpdateWorkflowPreparationJobsConnector"]


class UpdateWorkflowUpdateWorkflowPreparationJobsConnector(BaseModel):
    type: FilePreparationServiceTypes
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    azure_document: Optional[
        "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorAzureDocument"
    ] = Field(alias="azureDocument")
    deepgram: Optional["UpdateWorkflowUpdateWorkflowPreparationJobsConnectorDeepgram"]
    assembly_ai: Optional[
        "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorAssemblyAi"
    ] = Field(alias="assemblyAI")
    page: Optional["UpdateWorkflowUpdateWorkflowPreparationJobsConnectorPage"]
    document: Optional["UpdateWorkflowUpdateWorkflowPreparationJobsConnectorDocument"]
    email: Optional["UpdateWorkflowUpdateWorkflowPreparationJobsConnectorEmail"]
    model_document: Optional[
        "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorModelDocument"
    ] = Field(alias="modelDocument")
    mistral: Optional["UpdateWorkflowUpdateWorkflowPreparationJobsConnectorMistral"]


class UpdateWorkflowUpdateWorkflowPreparationJobsConnectorAzureDocument(BaseModel):
    version: Optional[AzureDocumentIntelligenceVersions]
    model: Optional[AzureDocumentIntelligenceModels]
    endpoint: Optional[Any]
    key: Optional[str]


class UpdateWorkflowUpdateWorkflowPreparationJobsConnectorDeepgram(BaseModel):
    model: Optional[DeepgramModels]
    key: Optional[str]
    enable_redaction: Optional[bool] = Field(alias="enableRedaction")
    enable_speaker_diarization: Optional[bool] = Field(alias="enableSpeakerDiarization")
    detect_language: Optional[bool] = Field(alias="detectLanguage")
    language: Optional[str]


class UpdateWorkflowUpdateWorkflowPreparationJobsConnectorAssemblyAi(BaseModel):
    model: Optional[AssemblyAIModels]
    key: Optional[str]
    enable_redaction: Optional[bool] = Field(alias="enableRedaction")
    enable_speaker_diarization: Optional[bool] = Field(alias="enableSpeakerDiarization")
    detect_language: Optional[bool] = Field(alias="detectLanguage")
    language: Optional[str]


class UpdateWorkflowUpdateWorkflowPreparationJobsConnectorPage(BaseModel):
    enable_screenshot: Optional[bool] = Field(alias="enableScreenshot")


class UpdateWorkflowUpdateWorkflowPreparationJobsConnectorDocument(BaseModel):
    include_images: Optional[bool] = Field(alias="includeImages")


class UpdateWorkflowUpdateWorkflowPreparationJobsConnectorEmail(BaseModel):
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class UpdateWorkflowUpdateWorkflowPreparationJobsConnectorModelDocument(BaseModel):
    specification: Optional[
        "UpdateWorkflowUpdateWorkflowPreparationJobsConnectorModelDocumentSpecification"
    ]


class UpdateWorkflowUpdateWorkflowPreparationJobsConnectorModelDocumentSpecification(
    BaseModel
):
    id: str


class UpdateWorkflowUpdateWorkflowPreparationJobsConnectorMistral(BaseModel):
    key: Optional[str]


class UpdateWorkflowUpdateWorkflowExtraction(BaseModel):
    jobs: Optional[List[Optional["UpdateWorkflowUpdateWorkflowExtractionJobs"]]]


class UpdateWorkflowUpdateWorkflowExtractionJobs(BaseModel):
    connector: Optional["UpdateWorkflowUpdateWorkflowExtractionJobsConnector"]


class UpdateWorkflowUpdateWorkflowExtractionJobsConnector(BaseModel):
    type: EntityExtractionServiceTypes
    content_types: Optional[List[ContentTypes]] = Field(alias="contentTypes")
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    extracted_types: Optional[List[ObservableTypes]] = Field(alias="extractedTypes")
    extracted_count: Optional[int] = Field(alias="extractedCount")
    azure_text: Optional[
        "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorAzureText"
    ] = Field(alias="azureText")
    azure_image: Optional[
        "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorAzureImage"
    ] = Field(alias="azureImage")
    model_image: Optional[
        "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelImage"
    ] = Field(alias="modelImage")
    model_text: Optional[
        "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelText"
    ] = Field(alias="modelText")


class UpdateWorkflowUpdateWorkflowExtractionJobsConnectorAzureText(BaseModel):
    confidence_threshold: Optional[float] = Field(alias="confidenceThreshold")
    enable_pii: Optional[bool] = Field(alias="enablePII")


class UpdateWorkflowUpdateWorkflowExtractionJobsConnectorAzureImage(BaseModel):
    confidence_threshold: Optional[float] = Field(alias="confidenceThreshold")


class UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelImage(BaseModel):
    specification: Optional[
        "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelImageSpecification"
    ]


class UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelImageSpecification(
    BaseModel
):
    id: str


class UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelText(BaseModel):
    specification: Optional[
        "UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelTextSpecification"
    ]


class UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelTextSpecification(
    BaseModel
):
    id: str


class UpdateWorkflowUpdateWorkflowClassification(BaseModel):
    jobs: Optional[List[Optional["UpdateWorkflowUpdateWorkflowClassificationJobs"]]]


class UpdateWorkflowUpdateWorkflowClassificationJobs(BaseModel):
    connector: Optional["UpdateWorkflowUpdateWorkflowClassificationJobsConnector"]


class UpdateWorkflowUpdateWorkflowClassificationJobsConnector(BaseModel):
    type: ContentClassificationServiceTypes
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")
    model: Optional["UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModel"]
    regex: Optional["UpdateWorkflowUpdateWorkflowClassificationJobsConnectorRegex"]


class UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModel(BaseModel):
    specification: Optional[
        "UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModelSpecification"
    ]
    rules: Optional[
        List[
            Optional[
                "UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModelRules"
            ]
        ]
    ]


class UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModelSpecification(
    BaseModel
):
    id: str


class UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModelRules(BaseModel):
    then: Optional[str]
    if_: Optional[str] = Field(alias="if")


class UpdateWorkflowUpdateWorkflowClassificationJobsConnectorRegex(BaseModel):
    rules: Optional[
        List[
            Optional[
                "UpdateWorkflowUpdateWorkflowClassificationJobsConnectorRegexRules"
            ]
        ]
    ]


class UpdateWorkflowUpdateWorkflowClassificationJobsConnectorRegexRules(BaseModel):
    then: Optional[str]
    type: Optional[RegexSourceTypes]
    path: Optional[str]
    matches: Optional[str]


class UpdateWorkflowUpdateWorkflowEnrichment(BaseModel):
    link: Optional["UpdateWorkflowUpdateWorkflowEnrichmentLink"]
    jobs: Optional[List[Optional["UpdateWorkflowUpdateWorkflowEnrichmentJobs"]]]


class UpdateWorkflowUpdateWorkflowEnrichmentLink(BaseModel):
    enable_crawling: Optional[bool] = Field(alias="enableCrawling")
    allowed_domains: Optional[List[str]] = Field(alias="allowedDomains")
    excluded_domains: Optional[List[str]] = Field(alias="excludedDomains")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")
    allowed_links: Optional[List[LinkTypes]] = Field(alias="allowedLinks")
    excluded_links: Optional[List[LinkTypes]] = Field(alias="excludedLinks")
    allowed_files: Optional[List[FileTypes]] = Field(alias="allowedFiles")
    excluded_files: Optional[List[FileTypes]] = Field(alias="excludedFiles")
    allow_content_domain: Optional[bool] = Field(alias="allowContentDomain")
    maximum_links: Optional[int] = Field(alias="maximumLinks")


class UpdateWorkflowUpdateWorkflowEnrichmentJobs(BaseModel):
    connector: Optional["UpdateWorkflowUpdateWorkflowEnrichmentJobsConnector"]


class UpdateWorkflowUpdateWorkflowEnrichmentJobsConnector(BaseModel):
    type: Optional[EntityEnrichmentServiceTypes]
    enriched_types: Optional[List[Optional[ObservableTypes]]] = Field(
        alias="enrichedTypes"
    )
    fhir: Optional["UpdateWorkflowUpdateWorkflowEnrichmentJobsConnectorFhir"]
    diffbot: Optional["UpdateWorkflowUpdateWorkflowEnrichmentJobsConnectorDiffbot"]


class UpdateWorkflowUpdateWorkflowEnrichmentJobsConnectorFhir(BaseModel):
    endpoint: Optional[Any]


class UpdateWorkflowUpdateWorkflowEnrichmentJobsConnectorDiffbot(BaseModel):
    key: Optional[Any]


class UpdateWorkflowUpdateWorkflowStorage(BaseModel):
    policy: Optional["UpdateWorkflowUpdateWorkflowStoragePolicy"]


class UpdateWorkflowUpdateWorkflowStoragePolicy(BaseModel):
    type: Optional[StoragePolicyTypes]
    allow_duplicates: Optional[bool] = Field(alias="allowDuplicates")


class UpdateWorkflowUpdateWorkflowActions(BaseModel):
    connector: Optional["UpdateWorkflowUpdateWorkflowActionsConnector"]


class UpdateWorkflowUpdateWorkflowActionsConnector(BaseModel):
    type: IntegrationServiceTypes
    uri: Optional[str]
    slack: Optional["UpdateWorkflowUpdateWorkflowActionsConnectorSlack"]
    email: Optional["UpdateWorkflowUpdateWorkflowActionsConnectorEmail"]
    twitter: Optional["UpdateWorkflowUpdateWorkflowActionsConnectorTwitter"]


class UpdateWorkflowUpdateWorkflowActionsConnectorSlack(BaseModel):
    token: str
    channel: str


class UpdateWorkflowUpdateWorkflowActionsConnectorEmail(BaseModel):
    from_: str = Field(alias="from")
    subject: str
    to: List[str]


class UpdateWorkflowUpdateWorkflowActionsConnectorTwitter(BaseModel):
    consumer_key: str = Field(alias="consumerKey")
    consumer_secret: str = Field(alias="consumerSecret")
    access_token_key: str = Field(alias="accessTokenKey")
    access_token_secret: str = Field(alias="accessTokenSecret")


UpdateWorkflow.model_rebuild()
UpdateWorkflowUpdateWorkflow.model_rebuild()
UpdateWorkflowUpdateWorkflowIngestion.model_rebuild()
UpdateWorkflowUpdateWorkflowIngestionObservations.model_rebuild()
UpdateWorkflowUpdateWorkflowIndexing.model_rebuild()
UpdateWorkflowUpdateWorkflowIndexingJobs.model_rebuild()
UpdateWorkflowUpdateWorkflowPreparation.model_rebuild()
UpdateWorkflowUpdateWorkflowPreparationSummarizations.model_rebuild()
UpdateWorkflowUpdateWorkflowPreparationJobs.model_rebuild()
UpdateWorkflowUpdateWorkflowPreparationJobsConnector.model_rebuild()
UpdateWorkflowUpdateWorkflowPreparationJobsConnectorModelDocument.model_rebuild()
UpdateWorkflowUpdateWorkflowExtraction.model_rebuild()
UpdateWorkflowUpdateWorkflowExtractionJobs.model_rebuild()
UpdateWorkflowUpdateWorkflowExtractionJobsConnector.model_rebuild()
UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelImage.model_rebuild()
UpdateWorkflowUpdateWorkflowExtractionJobsConnectorModelText.model_rebuild()
UpdateWorkflowUpdateWorkflowClassification.model_rebuild()
UpdateWorkflowUpdateWorkflowClassificationJobs.model_rebuild()
UpdateWorkflowUpdateWorkflowClassificationJobsConnector.model_rebuild()
UpdateWorkflowUpdateWorkflowClassificationJobsConnectorModel.model_rebuild()
UpdateWorkflowUpdateWorkflowClassificationJobsConnectorRegex.model_rebuild()
UpdateWorkflowUpdateWorkflowEnrichment.model_rebuild()
UpdateWorkflowUpdateWorkflowEnrichmentJobs.model_rebuild()
UpdateWorkflowUpdateWorkflowEnrichmentJobsConnector.model_rebuild()
UpdateWorkflowUpdateWorkflowStorage.model_rebuild()
UpdateWorkflowUpdateWorkflowActions.model_rebuild()
UpdateWorkflowUpdateWorkflowActionsConnector.model_rebuild()



================================================
FILE: graphlit_api/upsert_category.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpsertCategory(BaseModel):
    upsert_category: Optional["UpsertCategoryUpsertCategory"] = Field(
        alias="upsertCategory"
    )


class UpsertCategoryUpsertCategory(BaseModel):
    id: str
    name: str


UpsertCategory.model_rebuild()



================================================
FILE: graphlit_api/upsert_label.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class UpsertLabel(BaseModel):
    upsert_label: Optional["UpsertLabelUpsertLabel"] = Field(alias="upsertLabel")


class UpsertLabelUpsertLabel(BaseModel):
    id: str
    name: str


UpsertLabel.model_rebuild()



================================================
FILE: graphlit_api/upsert_specification.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import EntityState, ModelServiceTypes, SpecificationTypes


class UpsertSpecification(BaseModel):
    upsert_specification: Optional["UpsertSpecificationUpsertSpecification"] = Field(
        alias="upsertSpecification"
    )


class UpsertSpecificationUpsertSpecification(BaseModel):
    id: str
    name: str
    state: EntityState
    type: Optional[SpecificationTypes]
    service_type: Optional[ModelServiceTypes] = Field(alias="serviceType")


UpsertSpecification.model_rebuild()



================================================
FILE: graphlit_api/upsert_workflow.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Any, List, Optional

from pydantic import Field

from .base_model import BaseModel
from .enums import (
    AssemblyAIModels,
    AzureDocumentIntelligenceModels,
    AzureDocumentIntelligenceVersions,
    ContentClassificationServiceTypes,
    ContentIndexingServiceTypes,
    ContentTypes,
    DeepgramModels,
    EntityEnrichmentServiceTypes,
    EntityExtractionServiceTypes,
    EntityState,
    FilePreparationServiceTypes,
    FileTypes,
    IntegrationServiceTypes,
    LinkTypes,
    ObservableTypes,
    RegexSourceTypes,
    StoragePolicyTypes,
    SummarizationTypes,
)


class UpsertWorkflow(BaseModel):
    upsert_workflow: Optional["UpsertWorkflowUpsertWorkflow"] = Field(
        alias="upsertWorkflow"
    )


class UpsertWorkflowUpsertWorkflow(BaseModel):
    id: str
    name: str
    state: EntityState
    ingestion: Optional["UpsertWorkflowUpsertWorkflowIngestion"]
    indexing: Optional["UpsertWorkflowUpsertWorkflowIndexing"]
    preparation: Optional["UpsertWorkflowUpsertWorkflowPreparation"]
    extraction: Optional["UpsertWorkflowUpsertWorkflowExtraction"]
    classification: Optional["UpsertWorkflowUpsertWorkflowClassification"]
    enrichment: Optional["UpsertWorkflowUpsertWorkflowEnrichment"]
    storage: Optional["UpsertWorkflowUpsertWorkflowStorage"]
    actions: Optional[List[Optional["UpsertWorkflowUpsertWorkflowActions"]]]


class UpsertWorkflowUpsertWorkflowIngestion(BaseModel):
    if_: Optional["UpsertWorkflowUpsertWorkflowIngestionIf"] = Field(alias="if")
    collections: Optional[
        List[Optional["UpsertWorkflowUpsertWorkflowIngestionCollections"]]
    ]
    observations: Optional[
        List[Optional["UpsertWorkflowUpsertWorkflowIngestionObservations"]]
    ]
    enable_email_collections: Optional[bool] = Field(alias="enableEmailCollections")


class UpsertWorkflowUpsertWorkflowIngestionIf(BaseModel):
    types: Optional[List[ContentTypes]]
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    formats: Optional[List[Optional[str]]]
    file_extensions: Optional[List[str]] = Field(alias="fileExtensions")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")


class UpsertWorkflowUpsertWorkflowIngestionCollections(BaseModel):
    id: str


class UpsertWorkflowUpsertWorkflowIngestionObservations(BaseModel):
    type: ObservableTypes
    observable: "UpsertWorkflowUpsertWorkflowIngestionObservationsObservable"


class UpsertWorkflowUpsertWorkflowIngestionObservationsObservable(BaseModel):
    id: str
    name: Optional[str]


class UpsertWorkflowUpsertWorkflowIndexing(BaseModel):
    jobs: Optional[List[Optional["UpsertWorkflowUpsertWorkflowIndexingJobs"]]]


class UpsertWorkflowUpsertWorkflowIndexingJobs(BaseModel):
    connector: Optional["UpsertWorkflowUpsertWorkflowIndexingJobsConnector"]


class UpsertWorkflowUpsertWorkflowIndexingJobsConnector(BaseModel):
    type: Optional[ContentIndexingServiceTypes]
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")


class UpsertWorkflowUpsertWorkflowPreparation(BaseModel):
    enable_unblocked_capture: Optional[bool] = Field(alias="enableUnblockedCapture")
    disable_smart_capture: Optional[bool] = Field(alias="disableSmartCapture")
    summarizations: Optional[
        List[Optional["UpsertWorkflowUpsertWorkflowPreparationSummarizations"]]
    ]
    jobs: Optional[List[Optional["UpsertWorkflowUpsertWorkflowPreparationJobs"]]]


class UpsertWorkflowUpsertWorkflowPreparationSummarizations(BaseModel):
    type: SummarizationTypes
    specification: Optional[
        "UpsertWorkflowUpsertWorkflowPreparationSummarizationsSpecification"
    ]
    tokens: Optional[int]
    items: Optional[int]
    prompt: Optional[str]


class UpsertWorkflowUpsertWorkflowPreparationSummarizationsSpecification(BaseModel):
    id: str


class UpsertWorkflowUpsertWorkflowPreparationJobs(BaseModel):
    connector: Optional["UpsertWorkflowUpsertWorkflowPreparationJobsConnector"]


class UpsertWorkflowUpsertWorkflowPreparationJobsConnector(BaseModel):
    type: FilePreparationServiceTypes
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    azure_document: Optional[
        "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorAzureDocument"
    ] = Field(alias="azureDocument")
    deepgram: Optional["UpsertWorkflowUpsertWorkflowPreparationJobsConnectorDeepgram"]
    assembly_ai: Optional[
        "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorAssemblyAi"
    ] = Field(alias="assemblyAI")
    page: Optional["UpsertWorkflowUpsertWorkflowPreparationJobsConnectorPage"]
    document: Optional["UpsertWorkflowUpsertWorkflowPreparationJobsConnectorDocument"]
    email: Optional["UpsertWorkflowUpsertWorkflowPreparationJobsConnectorEmail"]
    model_document: Optional[
        "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorModelDocument"
    ] = Field(alias="modelDocument")
    mistral: Optional["UpsertWorkflowUpsertWorkflowPreparationJobsConnectorMistral"]


class UpsertWorkflowUpsertWorkflowPreparationJobsConnectorAzureDocument(BaseModel):
    version: Optional[AzureDocumentIntelligenceVersions]
    model: Optional[AzureDocumentIntelligenceModels]
    endpoint: Optional[Any]
    key: Optional[str]


class UpsertWorkflowUpsertWorkflowPreparationJobsConnectorDeepgram(BaseModel):
    model: Optional[DeepgramModels]
    key: Optional[str]
    enable_redaction: Optional[bool] = Field(alias="enableRedaction")
    enable_speaker_diarization: Optional[bool] = Field(alias="enableSpeakerDiarization")
    detect_language: Optional[bool] = Field(alias="detectLanguage")
    language: Optional[str]


class UpsertWorkflowUpsertWorkflowPreparationJobsConnectorAssemblyAi(BaseModel):
    model: Optional[AssemblyAIModels]
    key: Optional[str]
    enable_redaction: Optional[bool] = Field(alias="enableRedaction")
    enable_speaker_diarization: Optional[bool] = Field(alias="enableSpeakerDiarization")
    detect_language: Optional[bool] = Field(alias="detectLanguage")
    language: Optional[str]


class UpsertWorkflowUpsertWorkflowPreparationJobsConnectorPage(BaseModel):
    enable_screenshot: Optional[bool] = Field(alias="enableScreenshot")


class UpsertWorkflowUpsertWorkflowPreparationJobsConnectorDocument(BaseModel):
    include_images: Optional[bool] = Field(alias="includeImages")


class UpsertWorkflowUpsertWorkflowPreparationJobsConnectorEmail(BaseModel):
    include_attachments: Optional[bool] = Field(alias="includeAttachments")


class UpsertWorkflowUpsertWorkflowPreparationJobsConnectorModelDocument(BaseModel):
    specification: Optional[
        "UpsertWorkflowUpsertWorkflowPreparationJobsConnectorModelDocumentSpecification"
    ]


class UpsertWorkflowUpsertWorkflowPreparationJobsConnectorModelDocumentSpecification(
    BaseModel
):
    id: str


class UpsertWorkflowUpsertWorkflowPreparationJobsConnectorMistral(BaseModel):
    key: Optional[str]


class UpsertWorkflowUpsertWorkflowExtraction(BaseModel):
    jobs: Optional[List[Optional["UpsertWorkflowUpsertWorkflowExtractionJobs"]]]


class UpsertWorkflowUpsertWorkflowExtractionJobs(BaseModel):
    connector: Optional["UpsertWorkflowUpsertWorkflowExtractionJobsConnector"]


class UpsertWorkflowUpsertWorkflowExtractionJobsConnector(BaseModel):
    type: EntityExtractionServiceTypes
    content_types: Optional[List[ContentTypes]] = Field(alias="contentTypes")
    file_types: Optional[List[FileTypes]] = Field(alias="fileTypes")
    extracted_types: Optional[List[ObservableTypes]] = Field(alias="extractedTypes")
    extracted_count: Optional[int] = Field(alias="extractedCount")
    azure_text: Optional[
        "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorAzureText"
    ] = Field(alias="azureText")
    azure_image: Optional[
        "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorAzureImage"
    ] = Field(alias="azureImage")
    model_image: Optional[
        "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelImage"
    ] = Field(alias="modelImage")
    model_text: Optional[
        "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelText"
    ] = Field(alias="modelText")


class UpsertWorkflowUpsertWorkflowExtractionJobsConnectorAzureText(BaseModel):
    confidence_threshold: Optional[float] = Field(alias="confidenceThreshold")
    enable_pii: Optional[bool] = Field(alias="enablePII")


class UpsertWorkflowUpsertWorkflowExtractionJobsConnectorAzureImage(BaseModel):
    confidence_threshold: Optional[float] = Field(alias="confidenceThreshold")


class UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelImage(BaseModel):
    specification: Optional[
        "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelImageSpecification"
    ]


class UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelImageSpecification(
    BaseModel
):
    id: str


class UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelText(BaseModel):
    specification: Optional[
        "UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelTextSpecification"
    ]


class UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelTextSpecification(
    BaseModel
):
    id: str


class UpsertWorkflowUpsertWorkflowClassification(BaseModel):
    jobs: Optional[List[Optional["UpsertWorkflowUpsertWorkflowClassificationJobs"]]]


class UpsertWorkflowUpsertWorkflowClassificationJobs(BaseModel):
    connector: Optional["UpsertWorkflowUpsertWorkflowClassificationJobsConnector"]


class UpsertWorkflowUpsertWorkflowClassificationJobsConnector(BaseModel):
    type: ContentClassificationServiceTypes
    content_type: Optional[ContentTypes] = Field(alias="contentType")
    file_type: Optional[FileTypes] = Field(alias="fileType")
    model: Optional["UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModel"]
    regex: Optional["UpsertWorkflowUpsertWorkflowClassificationJobsConnectorRegex"]


class UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModel(BaseModel):
    specification: Optional[
        "UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModelSpecification"
    ]
    rules: Optional[
        List[
            Optional[
                "UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModelRules"
            ]
        ]
    ]


class UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModelSpecification(
    BaseModel
):
    id: str


class UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModelRules(BaseModel):
    then: Optional[str]
    if_: Optional[str] = Field(alias="if")


class UpsertWorkflowUpsertWorkflowClassificationJobsConnectorRegex(BaseModel):
    rules: Optional[
        List[
            Optional[
                "UpsertWorkflowUpsertWorkflowClassificationJobsConnectorRegexRules"
            ]
        ]
    ]


class UpsertWorkflowUpsertWorkflowClassificationJobsConnectorRegexRules(BaseModel):
    then: Optional[str]
    type: Optional[RegexSourceTypes]
    path: Optional[str]
    matches: Optional[str]


class UpsertWorkflowUpsertWorkflowEnrichment(BaseModel):
    link: Optional["UpsertWorkflowUpsertWorkflowEnrichmentLink"]
    jobs: Optional[List[Optional["UpsertWorkflowUpsertWorkflowEnrichmentJobs"]]]


class UpsertWorkflowUpsertWorkflowEnrichmentLink(BaseModel):
    enable_crawling: Optional[bool] = Field(alias="enableCrawling")
    allowed_domains: Optional[List[str]] = Field(alias="allowedDomains")
    excluded_domains: Optional[List[str]] = Field(alias="excludedDomains")
    allowed_paths: Optional[List[str]] = Field(alias="allowedPaths")
    excluded_paths: Optional[List[str]] = Field(alias="excludedPaths")
    allowed_links: Optional[List[LinkTypes]] = Field(alias="allowedLinks")
    excluded_links: Optional[List[LinkTypes]] = Field(alias="excludedLinks")
    allowed_files: Optional[List[FileTypes]] = Field(alias="allowedFiles")
    excluded_files: Optional[List[FileTypes]] = Field(alias="excludedFiles")
    allow_content_domain: Optional[bool] = Field(alias="allowContentDomain")
    maximum_links: Optional[int] = Field(alias="maximumLinks")


class UpsertWorkflowUpsertWorkflowEnrichmentJobs(BaseModel):
    connector: Optional["UpsertWorkflowUpsertWorkflowEnrichmentJobsConnector"]


class UpsertWorkflowUpsertWorkflowEnrichmentJobsConnector(BaseModel):
    type: Optional[EntityEnrichmentServiceTypes]
    enriched_types: Optional[List[Optional[ObservableTypes]]] = Field(
        alias="enrichedTypes"
    )
    fhir: Optional["UpsertWorkflowUpsertWorkflowEnrichmentJobsConnectorFhir"]
    diffbot: Optional["UpsertWorkflowUpsertWorkflowEnrichmentJobsConnectorDiffbot"]


class UpsertWorkflowUpsertWorkflowEnrichmentJobsConnectorFhir(BaseModel):
    endpoint: Optional[Any]


class UpsertWorkflowUpsertWorkflowEnrichmentJobsConnectorDiffbot(BaseModel):
    key: Optional[Any]


class UpsertWorkflowUpsertWorkflowStorage(BaseModel):
    policy: Optional["UpsertWorkflowUpsertWorkflowStoragePolicy"]


class UpsertWorkflowUpsertWorkflowStoragePolicy(BaseModel):
    type: Optional[StoragePolicyTypes]
    allow_duplicates: Optional[bool] = Field(alias="allowDuplicates")


class UpsertWorkflowUpsertWorkflowActions(BaseModel):
    connector: Optional["UpsertWorkflowUpsertWorkflowActionsConnector"]


class UpsertWorkflowUpsertWorkflowActionsConnector(BaseModel):
    type: IntegrationServiceTypes
    uri: Optional[str]
    slack: Optional["UpsertWorkflowUpsertWorkflowActionsConnectorSlack"]
    email: Optional["UpsertWorkflowUpsertWorkflowActionsConnectorEmail"]
    twitter: Optional["UpsertWorkflowUpsertWorkflowActionsConnectorTwitter"]


class UpsertWorkflowUpsertWorkflowActionsConnectorSlack(BaseModel):
    token: str
    channel: str


class UpsertWorkflowUpsertWorkflowActionsConnectorEmail(BaseModel):
    from_: str = Field(alias="from")
    subject: str
    to: List[str]


class UpsertWorkflowUpsertWorkflowActionsConnectorTwitter(BaseModel):
    consumer_key: str = Field(alias="consumerKey")
    consumer_secret: str = Field(alias="consumerSecret")
    access_token_key: str = Field(alias="accessTokenKey")
    access_token_secret: str = Field(alias="accessTokenSecret")


UpsertWorkflow.model_rebuild()
UpsertWorkflowUpsertWorkflow.model_rebuild()
UpsertWorkflowUpsertWorkflowIngestion.model_rebuild()
UpsertWorkflowUpsertWorkflowIngestionObservations.model_rebuild()
UpsertWorkflowUpsertWorkflowIndexing.model_rebuild()
UpsertWorkflowUpsertWorkflowIndexingJobs.model_rebuild()
UpsertWorkflowUpsertWorkflowPreparation.model_rebuild()
UpsertWorkflowUpsertWorkflowPreparationSummarizations.model_rebuild()
UpsertWorkflowUpsertWorkflowPreparationJobs.model_rebuild()
UpsertWorkflowUpsertWorkflowPreparationJobsConnector.model_rebuild()
UpsertWorkflowUpsertWorkflowPreparationJobsConnectorModelDocument.model_rebuild()
UpsertWorkflowUpsertWorkflowExtraction.model_rebuild()
UpsertWorkflowUpsertWorkflowExtractionJobs.model_rebuild()
UpsertWorkflowUpsertWorkflowExtractionJobsConnector.model_rebuild()
UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelImage.model_rebuild()
UpsertWorkflowUpsertWorkflowExtractionJobsConnectorModelText.model_rebuild()
UpsertWorkflowUpsertWorkflowClassification.model_rebuild()
UpsertWorkflowUpsertWorkflowClassificationJobs.model_rebuild()
UpsertWorkflowUpsertWorkflowClassificationJobsConnector.model_rebuild()
UpsertWorkflowUpsertWorkflowClassificationJobsConnectorModel.model_rebuild()
UpsertWorkflowUpsertWorkflowClassificationJobsConnectorRegex.model_rebuild()
UpsertWorkflowUpsertWorkflowEnrichment.model_rebuild()
UpsertWorkflowUpsertWorkflowEnrichmentJobs.model_rebuild()
UpsertWorkflowUpsertWorkflowEnrichmentJobsConnector.model_rebuild()
UpsertWorkflowUpsertWorkflowStorage.model_rebuild()
UpsertWorkflowUpsertWorkflowActions.model_rebuild()
UpsertWorkflowUpsertWorkflowActionsConnector.model_rebuild()



================================================
FILE: graphlit_api/workflow_exists.py
================================================
# Generated by ariadne-codegen
# Source: ./documents

from typing import Optional

from pydantic import Field

from .base_model import BaseModel


class WorkflowExists(BaseModel):
    workflow_exists: Optional["WorkflowExistsWorkflowExists"] = Field(
        alias="workflowExists"
    )


class WorkflowExistsWorkflowExists(BaseModel):
    result: Optional[bool]


WorkflowExists.model_rebuild()



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: "[BUG]"
labels: ''
assignees: ''

---

### Steps to Reproduce
1. [Step 1]
2. [Step 2]
3. [Step 3]
4. [More steps as necessary...]

### Expected Behavior
[A clear and concise description of what you expected to happen.]

### Actual Behavior
[A clear and concise description of what actually happened. Include any error messages or screenshots if possible.]

### Environment
- Library version: [e.g., 1.0.0]
- Operating System: [e.g., macOS, Windows, Linux]
- Browser (if applicable): [e.g., Chrome, Safari]
- Other relevant software versions (e.g., Node.js, Python):

### Possible Solution
[If you have a suggestion for how to fix the bug, please describe it here. Otherwise, leave it blank.]

### Additional Context
[Add any other context about the problem here, such as specific circumstances where the bug occurs and does not occur, whether the issue is sporadic or consistent, etc.]

### Logs and Screenshots
[If applicable, add logs and screenshots to help explain your problem.]

---
Please replace all text in brackets ([ ]) with the appropriate information and be as detailed as possible. This will help us to understand and fix the bug more efficiently.


